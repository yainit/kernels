From 2b32a7d82223d76ace432305b18c5816cadff878 Mon Sep 17 00:00:00 2001
From: Florian Westphal <fw () strlen ! de>
Date: Thu, 10 Mar 2016 00:56:02 -0800
Subject: [PATCH] netfilter: x_tables: deal with bogus nextoffset values

Ben Hawkes says:

 In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it
 is possible for a user-supplied ipt_entry structure to have a large
 next_offset field. This field is not bounds checked prior to writing a
 counter value at the supplied offset.

Problem is that xt_entry_foreach() macro stops iterating once e->next_offset
is out of bounds, assuming this is the last entry.

With malformed data thats not necessarily the case so we can
write outside of allocated area later as we might not have walked the
entire blob.

Fix this by simplifying mark_source_chains -- it already has to check
if nextoff is in range to catch invalid jumps, so just do the check
when we move to a next entry as well.

Signed-off-by: Florian Westphal <fw@strlen.de>
---
 net/ipv4/netfilter/arp_tables.c | 8 ++++++++
 net/ipv4/netfilter/ip_tables.c  | 8 ++++++++
 net/ipv6/netfilter/ip6_tables.c | 6 ++++++
 3 files changed, 22 insertions(+)

diff -iwBEr -U 4 linux-4.8h/net/ipv4/netfilter/arp_tables.c linux-4.8s/net/ipv4/netfilter/arp_tables.c
--- linux-4.8h/net/ipv4/netfilter/arp_tables.c	2016-11-23 16:43:13.884325561 +0000
+++ linux-4.8s/net/ipv4/netfilter/arp_tables.c	2016-11-23 16:33:31.930387665 +0000
@@ -375,8 +375,12 @@
 
 				/* Move along one */
 				size = e->next_offset;
 				if (!next_offset_ok(newinfo, pos + size))
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 					return 0;
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
@@ -398,8 +402,12 @@
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
 					if (newpos >= newinfo->size)
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 						return 0;
 				}
 
 				if (!next_offset_ok(newinfo, newpos))
diff -iwBEr -U 4 linux-4.8h/net/ipv4/netfilter/ip_tables.c linux-4.8s/net/ipv4/netfilter/ip_tables.c
--- linux-4.8h/net/ipv4/netfilter/ip_tables.c	2016-11-23 16:43:13.884325561 +0000
+++ linux-4.8s/net/ipv4/netfilter/ip_tables.c	2016-11-23 16:33:31.931387665 +0000
@@ -446,8 +446,12 @@
 				/* Move along one */
 				size = e->next_offset;
 				if (!next_offset_ok(newinfo, pos + size))
 					return 0;
+
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
+
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
 				if (pos + size >= newinfo->size)
 					return 0;
@@ -469,8 +473,12 @@
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
 					if (newpos >= newinfo->size)
 						return 0;
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 				}
 
 				if (!next_offset_ok(newinfo, newpos))
 					return 0;
diff -iwBEr -U 4 linux-4.8h/net/ipv6/netfilter/ip6_tables.c linux-4.8s/net/ipv6/netfilter/ip6_tables.c
--- linux-4.8h/net/ipv6/netfilter/ip6_tables.c	2016-11-23 16:43:13.885325561 +0000
+++ linux-4.8s/net/ipv6/netfilter/ip6_tables.c	2016-11-23 16:33:31.932387665 +0000
@@ -473,8 +473,10 @@
 				} while (oldpos == pos + e->next_offset);
 
 				/* Move along one */
 				size = e->next_offset;
+				if (pos + size > newinfo->size - sizeof(*e))
+					return 0;
 				if (!next_offset_ok(newinfo, pos + size))
 					return 0;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
@@ -496,8 +498,12 @@
 						(entry0 + newpos);
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
+
+				if (newpos > newinfo->size - sizeof(*e))
+					return 0;
+
 					if (newpos >= newinfo->size)
 						return 0;
 				}
 
