diff -uNr linux-3.18.7/Documentation/devicetree/bindings/arm/pmu.txt linux-3.18.7-14.15/Documentation/devicetree/bindings/arm/pmu.txt
--- linux-3.18.7/Documentation/devicetree/bindings/arm/pmu.txt	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/Documentation/devicetree/bindings/arm/pmu.txt	2015-02-21 12:47:52.407421205 +0000
@@ -7,6 +7,7 @@
 Required properties:
 
 - compatible : should be one of
+	"apm,potenza-pmu"
 	"arm,armv8-pmuv3"
 	"arm,cortex-a17-pmu"
 	"arm,cortex-a15-pmu"
diff -uNr linux-3.18.7/Documentation/kernel-parameters.txt linux-3.18.7-14.15/Documentation/kernel-parameters.txt
--- linux-3.18.7/Documentation/kernel-parameters.txt	2015-02-21 12:52:13.276394545 +0000
+++ linux-3.18.7-14.15/Documentation/kernel-parameters.txt	2015-02-21 12:47:52.408421205 +0000
@@ -734,6 +734,10 @@
 			/proc/<pid>/coredump_filter.
 			See also Documentation/filesystems/proc.txt.
 
+	cpufreq_driver= [X86] Allow only the named cpu frequency scaling driver
+			to register. Example: cpufreq_driver=powernow-k8
+			Format: { none | STRING }
+
 	cpuidle.off=1	[CPU_IDLE]
 			disable the cpuidle sub-system
 
diff -uNr linux-3.18.7/arch/arm/boot/compressed/Makefile linux-3.18.7-14.15/arch/arm/boot/compressed/Makefile
--- linux-3.18.7/arch/arm/boot/compressed/Makefile	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/boot/compressed/Makefile	2015-02-21 12:47:52.414421205 +0000
@@ -3,6 +3,7 @@
 #
 # create a compressed vmlinuz image from the original vmlinux
 #
+KBUILD_CFLAGS := $(filter-out -fstack-protector, $(KBUILD_CFLAGS)) -fno-stack-protector
 
 OBJS		=
 
diff -uNr linux-3.18.7/arch/arm/mach-highbank/Makefile linux-3.18.7-14.15/arch/arm/mach-highbank/Makefile
--- linux-3.18.7/arch/arm/mach-highbank/Makefile	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/mach-highbank/Makefile	2015-02-21 12:47:52.431421203 +0000
@@ -1,3 +1,5 @@
+KBUILD_CFLAGS += -I$(srctree)/arch/arm/mach-highbank/include
+
 obj-y					:= highbank.o system.o smc.o
 
 plus_sec := $(call as-instr,.arch_extension sec,+sec)
diff -uNr linux-3.18.7/arch/arm/mach-omap2/omap_hwmod.h linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod.h
--- linux-3.18.7/arch/arm/mach-omap2/omap_hwmod.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod.h	2015-02-21 12:47:52.439421202 +0000
@@ -41,6 +41,7 @@
 extern struct omap_hwmod_sysc_fields omap_hwmod_sysc_type1;
 extern struct omap_hwmod_sysc_fields omap_hwmod_sysc_type2;
 extern struct omap_hwmod_sysc_fields omap_hwmod_sysc_type3;
+extern struct omap_hwmod_sysc_fields omap_hwmod_sysc_type4;
 
 /*
  * OCP SYSCONFIG bit shifts/masks TYPE1. These are for IPs compliant
@@ -81,6 +82,16 @@
 #define SYSC_TYPE3_MIDLEMODE_SHIFT	2
 #define SYSC_TYPE3_MIDLEMODE_MASK	(0x3 << SYSC_TYPE3_MIDLEMODE_SHIFT)
 
+/*
+ * OCP SYSCONFIG bit shifts/masks TYPE4.
+ */
+#define SYSC_TYPE4_SIDLEMODE_SHIFT	2
+#define SYSC_TYPE4_SIDLEMODE_MASK	(0x3 << SYSC_TYPE4_SIDLEMODE_SHIFT)
+#define SYSC_TYPE4_SOFTRESET_SHIFT	1
+#define SYSC_TYPE4_SOFTRESET_MASK	(1 << SYSC_TYPE4_SOFTRESET_SHIFT)
+#define SYSC_TYPE4_AUTOIDLE_SHIFT	0
+#define SYSC_TYPE4_AUTOIDLE_MASK	(1 << SYSC_TYPE4_AUTOIDLE_SHIFT)
+
 /* OCP SYSSTATUS bit shifts/masks */
 #define SYSS_RESETDONE_SHIFT		0
 #define SYSS_RESETDONE_MASK		(1 << SYSS_RESETDONE_SHIFT)
diff -uNr linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c
--- linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c	2015-02-21 12:47:52.440421202 +0000
@@ -210,6 +210,7 @@
 	.sysc_offs	= 0x84,
 	.syss_offs	= 0x88,
 	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+	.sysc_fields    = &omap_hwmod_sysc_type4,
 };
 
 static struct omap_hwmod_class am33xx_aes0_hwmod_class = {
diff -uNr linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_44xx_data.c linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_44xx_data.c
--- linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_44xx_data.c	2015-02-21 12:47:52.444421202 +0000
@@ -4696,6 +4696,59 @@
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+/*
+    Crypto modules AES0/1 belong to:
+	PD_L4_PER power domain
+	CD_L4_SEC clock domain
+	On the L3, the AES modules are mapped to
+	L3_CLK2: Peripherals and multimedia sub clock domain
+*/
+
+static struct omap_hwmod_class_sysconfig omap4_aes1_sysc = {
+	.rev_offs	= 0x80,
+	.sysc_offs	= 0x84,
+	.syss_offs	= 0x88,
+	.sysc_flags	= SYSS_HAS_RESET_STATUS,
+	.sysc_fields	= &omap_hwmod_sysc_type4,
+};
+
+static struct omap_hwmod_class omap4_aes1_hwmod_class = {
+	.name		= "aes1",
+	.sysc		= &omap4_aes1_sysc,
+};
+
+static struct omap_hwmod omap4_aes1_hwmod = {
+	.name		= "aes",
+	.class		= &omap4_aes1_hwmod_class,
+	.clkdm_name	= "l4_secure_clkdm",
+	.main_clk	= "aes1_fck",
+	.prcm		= {
+		.omap4	= {
+			.clkctrl_offs = OMAP4_CM_L4SEC_AES1_CLKCTRL_OFFSET,
+			.context_offs = OMAP4_RM_L4SEC_AES1_CONTEXT_OFFSET,
+			.modulemode	= MODULEMODE_SWCTRL,
+		},
+	},
+};
+
+/* l3_main_2 -> aes1 */
+static struct omap_hwmod_addr_space omap4_aes1_addrs[] = {
+	{
+		.pa_start	= 0x4B500000,
+		.pa_end		= 0x4B500000 + SZ_1M - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap4_l3_main_2__aes1 = {
+	.master		= &omap44xx_l3_main_2_hwmod,
+	.slave		= &omap4_aes1_hwmod,
+	.clk		= "aes1_fck",
+	.addr		= omap4_aes1_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 static struct omap_hwmod_ocp_if *omap44xx_hwmod_ocp_ifs[] __initdata = {
 	&omap44xx_l3_main_1__dmm,
 	&omap44xx_mpu__dmm,
@@ -4841,6 +4894,7 @@
 	&omap44xx_l4_abe__wd_timer3_dma,
 	&omap44xx_mpu__emif1,
 	&omap44xx_mpu__emif2,
+	&omap4_l3_main_2__aes1,
 	NULL,
 };
 
diff -uNr linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_common_data.c linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_common_data.c
--- linux-3.18.7/arch/arm/mach-omap2/omap_hwmod_common_data.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm/mach-omap2/omap_hwmod_common_data.c	2015-02-21 12:47:52.447421201 +0000
@@ -59,6 +59,16 @@
 	.sidle_shift	= SYSC_TYPE3_SIDLEMODE_SHIFT,
 };
 
+/**
+ * struct omap_hwmod_sysc_type4 - TYPE4 sysconfig scheme.
+ * Used by some IPs on AM33xx
+ */
+struct omap_hwmod_sysc_fields omap_hwmod_sysc_type4 = {
+	.sidle_shift	= SYSC_TYPE4_SIDLEMODE_SHIFT,
+	.srst_shift	= SYSC_TYPE4_SOFTRESET_SHIFT,
+	.autoidle_shift	= SYSC_TYPE4_AUTOIDLE_SHIFT,
+};
+
 struct omap_dss_dispc_dev_attr omap2_3_dss_dispc_dev_attr = {
 	.manager_count		= 2,
 	.has_framedonetv_irq	= 0
diff -uNr linux-3.18.7/arch/arm64/boot/dts/apm-storm.dtsi linux-3.18.7-14.15/arch/arm64/boot/dts/apm-storm.dtsi
--- linux-3.18.7/arch/arm64/boot/dts/apm-storm.dtsi	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm64/boot/dts/apm-storm.dtsi	2015-02-21 12:47:52.458421200 +0000
@@ -97,6 +97,11 @@
 		clock-frequency = <50000000>;
 	};
 
+	pmu {
+		compatible = "apm,potenza-pmu", "arm,armv8-pmuv3";
+		interrupts = <1 12 0xff04>;
+	};
+
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <2>;
diff -uNr linux-3.18.7/arch/arm64/kernel/psci.c linux-3.18.7-14.15/arch/arm64/kernel/psci.c
--- linux-3.18.7/arch/arm64/kernel/psci.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm64/kernel/psci.c	2015-02-21 12:47:52.463421200 +0000
@@ -113,9 +113,14 @@
  * The following two functions are invoked via the invoke_psci_fn pointer
  * and will not be inlined, allowing us to piggyback on the AAPCS.
  */
-static noinline int __invoke_psci_fn_hvc(u64 function_id, u64 arg0, u64 arg1,
-					 u64 arg2)
+static noinline int __invoke_psci_fn_hvc(u64 _function_id, u64 _arg0,
+					 u64 _arg1, u64 _arg2)
 {
+	register u64 function_id asm("x0") = _function_id;
+	register u64 arg0 asm("x1") = _arg0;
+	register u64 arg1 asm("x2") = _arg1;
+	register u64 arg2 asm("x3") = _arg2;
+
 	asm volatile(
 			__asmeq("%0", "x0")
 			__asmeq("%1", "x1")
@@ -128,9 +133,14 @@
 	return function_id;
 }
 
-static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
-					 u64 arg2)
+static noinline int __invoke_psci_fn_smc(u64 _function_id, u64 _arg0,
+					 u64 _arg1, u64 _arg2)
 {
+	register u64 function_id asm("x0") = _function_id;
+	register u64 arg0 asm("x1") = _arg0;
+	register u64 arg1 asm("x2") = _arg1;
+	register u64 arg2 asm("x3") = _arg2;
+
 	asm volatile(
 			__asmeq("%0", "x0")
 			__asmeq("%1", "x1")
diff -uNr linux-3.18.7/arch/arm64/lib/copy_from_user.S linux-3.18.7-14.15/arch/arm64/lib/copy_from_user.S
--- linux-3.18.7/arch/arm64/lib/copy_from_user.S	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm64/lib/copy_from_user.S	2015-02-21 12:47:52.470421199 +0000
@@ -15,7 +15,6 @@
  */
 
 #include <linux/linkage.h>
-#include <asm/assembler.h>
 
 /*
  * Copy from user space to a kernel buffer (alignment handled by the hardware)
@@ -28,39 +27,63 @@
  *	x0 - bytes not copied
  */
 ENTRY(__copy_from_user)
-	add	x4, x1, x2			// upper user buffer boundary
-	subs	x2, x2, #8
-	b.mi	2f
-1:
-USER(9f, ldr	x3, [x1], #8	)
-	subs	x2, x2, #8
-	str	x3, [x0], #8
-	b.pl	1b
-2:	adds	x2, x2, #4
-	b.mi	3f
-USER(9f, ldr	w3, [x1], #4	)
-	sub	x2, x2, #4
-	str	w3, [x0], #4
-3:	adds	x2, x2, #2
-	b.mi	4f
-USER(9f, ldrh	w3, [x1], #2	)
-	sub	x2, x2, #2
-	strh	w3, [x0], #2
-4:	adds	x2, x2, #1
-	b.mi	5f
-USER(9f, ldrb	w3, [x1]	)
-	strb	w3, [x0]
-5:	mov	x0, #0
-	ret
+#include "copy_template.S"
 ENDPROC(__copy_from_user)
 
 	.section .fixup,"ax"
-	.align	2
-9:	sub	x2, x4, x1
-	mov	x3, x2
-10:	strb	wzr, [x0], #1			// zero remaining buffer space
-	subs	x3, x3, #1
-	b.ne	10b
-	mov	x0, x2				// bytes not copied
+	.align    2
+8:
+	/*
+	 * Count bytes remain
+	 * dst points to (dst + tmp1)
+	 */
+	mov	x0, count
+	sub	dst, dst, tmp1
+	b	.Lfinalize
+9:
+	/*
+	 * 16 bytes remain
+	 * dst is accurate
+	 */
+	mov	x0, #16
+	b	.Lfinalize
+10:
+	/*
+	 * count is accurate
+	 * dst is accurate
+	 */
+	mov	x0, count
+	b	.Lfinalize
+11:
+	/*
+	 *(count + tmp2) bytes remain
+	 * dst points to the start of the remaining bytes
+	 */
+	add	x0, count, tmp2
+	b	.Lfinalize
+12:
+	/*
+	 * (count + 128) bytes remain
+	 * dst is accurate
+	 */
+	add	x0, count, #128
+	b	.Lfinalize
+13:
+	/*
+	 * (count + 128) bytes remain
+	 * dst is pre-biased to (dst + 16)
+	 */
+	add	x0, count, #128
+	add	dst, dst, #16
+.Lfinalize:
+	/*
+	 * Zeroize remaining destination-buffer
+	 */
+	mov	count, x0
+20:
+	/* Zero remaining buffer space */
+	strb	wzr, [dst], #1
+	subs	count, count, #1
+	b.ne	20b
 	ret
 	.previous
diff -uNr linux-3.18.7/arch/arm64/lib/copy_template.S linux-3.18.7-14.15/arch/arm64/lib/copy_template.S
--- linux-3.18.7/arch/arm64/lib/copy_template.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm64/lib/copy_template.S	2015-02-21 12:47:52.471421199 +0000
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2013, Applied Micro Circuits Corporation
+ * Copyright (c) 2012-2013, Linaro Limited
+ *
+ * Author: Feng Kan <fkan@apm.com>
+ * Author: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
+ *
+ * The code is adopted from the memcpy routine by Linaro Limited.
+ *
+ * This file is free software: you may copy, redistribute and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *      1 Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *      2 Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in the
+ *        documentation and/or other materials provided with the distribution.
+ *      3 Neither the name of the Linaro nor the
+ *        names of its contributors may be used to endorse or promote products
+ *        derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <asm/assembler.h>
+
+dstin	.req x0
+src	.req x1
+count	.req x2
+tmp1	.req x3
+tmp1w	.req w3
+tmp2	.req x4
+tmp2w	.req w4
+tmp3	.req x5
+tmp3w	.req w5
+dst	.req x6
+
+A_l	.req x7
+A_h	.req x8
+B_l	.req x9
+B_h	.req x10
+C_l	.req x11
+C_h	.req x12
+D_l	.req x13
+D_h	.req x14
+
+	mov	dst, dstin
+	cmp	count, #64
+	b.ge	.Lcpy_not_short
+	cmp	count, #15
+	b.le	.Ltail15tiny
+
+	/*
+	 * Deal with small copies quickly by dropping straight into the
+	 * exit block.
+	 */
+.Ltail63:
+	/*
+	 * Copy up to 48 bytes of data.  At this point we only need the
+	 * bottom 6 bits of count to be accurate.
+	 */
+	ands	tmp1, count, #0x30
+	b.eq	.Ltail15
+	add	dst, dst, tmp1
+	add	src, src, tmp1
+	cmp	tmp1w, #0x20
+	b.eq	1f
+	b.lt	2f
+	USER(8f, ldp A_l, A_h, [src, #-48])
+	USER(8f, stp A_l, A_h, [dst, #-48])
+1:
+	USER(8f, ldp A_l, A_h, [src, #-32])
+	USER(8f, stp A_l, A_h, [dst, #-32])
+2:
+	USER(8f, ldp A_l, A_h, [src, #-16])
+	USER(8f, stp A_l, A_h, [dst, #-16])
+
+.Ltail15:
+	ands	count, count, #15
+	beq	1f
+	add	src, src, count
+	USER(9f, ldp A_l, A_h, [src, #-16])
+	add	dst, dst, count
+	USER(9f, stp A_l, A_h, [dst, #-16])
+1:
+	b	.Lsuccess
+
+.Ltail15tiny:
+	/*
+	 * Copy up to 15 bytes of data.  Does not assume additional data
+	 * being copied.
+	 */
+	tbz	count, #3, 1f
+	USER(10f, ldr tmp1, [src], #8)
+	USER(10f, str tmp1, [dst], #8)
+1:
+	tbz	count, #2, 1f
+	USER(10f, ldr tmp1w, [src], #4)
+	USER(10f, str tmp1w, [dst], #4)
+1:
+	tbz	count, #1, 1f
+	USER(10f, ldrh tmp1w, [src], #2)
+	USER(10f, strh tmp1w, [dst], #2)
+1:
+	tbz	count, #0, 1f
+	USER(10f, ldrb tmp1w, [src])
+	USER(10f, strb tmp1w, [dst])
+1:
+	b	.Lsuccess
+
+.Lcpy_not_short:
+	/*
+	 * We don't much care about the alignment of DST, but we want SRC
+	 * to be 128-bit (16 byte) aligned so that we don't cross cache line
+	 * boundaries on both loads and stores.
+	 */
+	neg	tmp2, src
+	ands	tmp2, tmp2, #15		/* Bytes to reach alignment.  */
+	b.eq	2f
+	sub	count, count, tmp2
+	/*
+	 * Copy more data than needed; it's faster than jumping
+	 * around copying sub-Quadword quantities.  We know that
+	 * it can't overrun.
+	 */
+	USER(11f, ldp A_l, A_h, [src])
+	add	src, src, tmp2
+	USER(11f, stp A_l, A_h, [dst])
+	add	dst, dst, tmp2
+	/* There may be less than 63 bytes to go now.  */
+	cmp	count, #63
+	b.le	.Ltail63
+2:
+	subs	count, count, #128
+	b.ge	.Lcpy_body_large
+	/*
+	 * Less than 128 bytes to copy, so handle 64 here and then jump
+	 * to the tail.
+	 */
+	USER(12f, ldp A_l, A_h, [src])
+	USER(12f, ldp B_l, B_h, [src, #16])
+	USER(12f, ldp C_l, C_h, [src, #32])
+	USER(12f, ldp D_l, D_h, [src, #48])
+	USER(12f, stp A_l, A_h, [dst])
+	USER(12f, stp B_l, B_h, [dst, #16])
+	USER(12f, stp C_l, C_h, [dst, #32])
+	USER(12f, stp D_l, D_h, [dst, #48])
+	tst	count, #0x3f
+	add	src, src, #64
+	add	dst, dst, #64
+	b.ne	.Ltail63
+	b	.Lsuccess
+
+	/*
+	 * Critical loop.  Start at a new cache line boundary.  Assuming
+	 * 64 bytes per line this ensures the entire loop is in one line.
+	 */
+	.p2align 6
+.Lcpy_body_large:
+	/* There are at least 128 bytes to copy.  */
+	USER(12f, ldp A_l, A_h, [src, #0])
+	sub	dst, dst, #16			/* Pre-bias.  */
+	USER(13f, ldp B_l, B_h, [src, #16])
+	USER(13f, ldp C_l, C_h, [src, #32])
+	USER(13f, ldp D_l, D_h, [src, #48]!)	/* src += 64 - Pre-bias. */
+1:
+	USER(13f, stp A_l, A_h, [dst, #16])
+	USER(13f, ldp A_l, A_h, [src, #16])
+	USER(13f, stp B_l, B_h, [dst, #32])
+	USER(13f, ldp B_l, B_h, [src, #32])
+	USER(13f, stp C_l, C_h, [dst, #48])
+	USER(13f, ldp C_l, C_h, [src, #48])
+	USER(13f, stp D_l, D_h, [dst, #64]!)
+	USER(13f, ldp D_l, D_h, [src, #64]!)
+	subs	count, count, #64
+	b.ge	1b
+	USER(13f, stp A_l, A_h, [dst, #16])
+	USER(13f, stp B_l, B_h, [dst, #32])
+	USER(13f, stp C_l, C_h, [dst, #48])
+	USER(13f, stp D_l, D_h, [dst, #64])
+	add	src, src, #16
+	add	dst, dst, #64 + 16
+	tst	count, #0x3f
+	b.ne	.Ltail63
+.Lsuccess:
+	/* Nothing left to copy */
+	mov	x0, #0
+	ret
diff -uNr linux-3.18.7/arch/arm64/lib/copy_to_user.S linux-3.18.7-14.15/arch/arm64/lib/copy_to_user.S
--- linux-3.18.7/arch/arm64/lib/copy_to_user.S	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/arm64/lib/copy_to_user.S	2015-02-21 12:47:52.471421199 +0000
@@ -15,7 +15,6 @@
  */
 
 #include <linux/linkage.h>
-#include <asm/assembler.h>
 
 /*
  * Copy to user space from a kernel buffer (alignment handled by the hardware)
@@ -28,34 +27,38 @@
  *	x0 - bytes not copied
  */
 ENTRY(__copy_to_user)
-	add	x4, x0, x2			// upper user buffer boundary
-	subs	x2, x2, #8
-	b.mi	2f
-1:
-	ldr	x3, [x1], #8
-	subs	x2, x2, #8
-USER(9f, str	x3, [x0], #8	)
-	b.pl	1b
-2:	adds	x2, x2, #4
-	b.mi	3f
-	ldr	w3, [x1], #4
-	sub	x2, x2, #4
-USER(9f, str	w3, [x0], #4	)
-3:	adds	x2, x2, #2
-	b.mi	4f
-	ldrh	w3, [x1], #2
-	sub	x2, x2, #2
-USER(9f, strh	w3, [x0], #2	)
-4:	adds	x2, x2, #1
-	b.mi	5f
-	ldrb	w3, [x1]
-USER(9f, strb	w3, [x0]	)
-5:	mov	x0, #0
-	ret
+#include "copy_template.S"
 ENDPROC(__copy_to_user)
 
 	.section .fixup,"ax"
-	.align	2
-9:	sub	x0, x4, x0			// bytes not copied
+	.align    2
+8:
+10:
+	/*
+	 * count is accurate
+	 */
+	mov	x0, count
+	b	.Lfinalize
+9:
+	/*
+	 * 16 bytes remain
+	 */
+	mov	x0, #16
+	b	.Lfinalize
+11:
+	/*
+	 *(count + tmp2) bytes remain
+	 * dst points to the start of the remaining bytes
+	 */
+	add	x0, count, tmp2
+	b	.Lfinalize
+12:
+13:
+	/*
+	 * (count + 128) bytes remain
+	 */
+	add	x0, count, #128
+	b	.Lfinalize
+.Lfinalize:
 	ret
 	.previous
diff -uNr linux-3.18.7/arch/powerpc/Kconfig linux-3.18.7-14.15/arch/powerpc/Kconfig
--- linux-3.18.7/arch/powerpc/Kconfig	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/Kconfig	2015-02-21 12:47:52.508421195 +0000
@@ -403,7 +403,9 @@
 
 config KEXEC
 	bool "kexec system call"
-	depends on (PPC_BOOK3S || FSL_BOOKE || (44x && !SMP))
+	depends on (PPC_BOOK3S || FSL_BOOKE || (44x && !SMP))  || PPC_BOOK3E
+	select CRYPTO
+	select CRYPTO_SHA256
 	help
 	  kexec is a system call that implements the ability to shutdown your
 	  current kernel, and to start another kernel.  It is like a reboot
diff -uNr linux-3.18.7/arch/powerpc/Makefile linux-3.18.7-14.15/arch/powerpc/Makefile
--- linux-3.18.7/arch/powerpc/Makefile	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/Makefile	2015-02-21 12:47:52.509421195 +0000
@@ -239,7 +239,7 @@
 all: zImage
 
 # With make 3.82 we cannot mix normal and wildcard targets
-BOOT_TARGETS1 := zImage zImage.initrd uImage
+BOOT_TARGETS1 := zImage zImage.initrd uImage vmlinux.strip
 BOOT_TARGETS2 := zImage% dtbImage% treeImage.% cuImage.% simpleImage.% uImage.%
 
 PHONY += $(BOOT_TARGETS1) $(BOOT_TARGETS2)
diff -uNr linux-3.18.7/arch/powerpc/include/asm/exception-64e.h linux-3.18.7-14.15/arch/powerpc/include/asm/exception-64e.h
--- linux-3.18.7/arch/powerpc/include/asm/exception-64e.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/include/asm/exception-64e.h	2015-02-21 12:47:52.511421195 +0000
@@ -203,10 +203,21 @@
 #define TLB_MISS_STATS_SAVE_INFO_BOLTED
 #endif
 
+#ifndef CONFIG_RELOCATABLE
 #define SET_IVOR(vector_number, vector_offset)	\
 	li	r3,vector_offset@l; 		\
 	ori	r3,r3,interrupt_base_book3e@l;	\
 	mtspr	SPRN_IVOR##vector_number,r3;
+#else /* !CONFIG_RELOCATABLE */
+/* In relocatable case the value of the constant expression 'expr' is only
+ * offset. So instead, we should loads the address of label 'name'.
+ */
+#define SET_IVOR(vector_number, vector_offset)	\
+	LOAD_REG_ADDR(r3,interrupt_base_book3e);\
+	rlwinm	r3,r3,0,15,0;			\
+	ori	r3,r3,vector_offset@l;		\
+	mtspr	SPRN_IVOR##vector_number,r3;
+#endif /* CONFIG_RELOCATABLE */
 
 #endif /* _ASM_POWERPC_EXCEPTION_64E_H */
 
diff -uNr linux-3.18.7/arch/powerpc/include/asm/kvm_booke.h linux-3.18.7-14.15/arch/powerpc/include/asm/kvm_booke.h
--- linux-3.18.7/arch/powerpc/include/asm/kvm_booke.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/include/asm/kvm_booke.h	2015-02-21 12:47:52.513421195 +0000
@@ -100,6 +100,11 @@
 	return vcpu->arch.pc;
 }
 
+static inline bool kvmppc_is_bigendian(struct kvm_vcpu *vcpu)
+{
+	return 1;
+}
+
 static inline ulong kvmppc_get_fault_dar(struct kvm_vcpu *vcpu)
 {
 	return vcpu->arch.fault_dear;
diff -uNr linux-3.18.7/arch/powerpc/include/asm/page.h linux-3.18.7-14.15/arch/powerpc/include/asm/page.h
--- linux-3.18.7/arch/powerpc/include/asm/page.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/include/asm/page.h	2015-02-21 12:47:52.514421194 +0000
@@ -109,6 +109,8 @@
 /* See Description below for VIRT_PHYS_OFFSET */
 #ifdef CONFIG_RELOCATABLE_PPC32
 #define VIRT_PHYS_OFFSET virt_phys_offset
+#elif defined(CONFIG_PPC_BOOK3E_64)
+#define VIRT_PHYS_OFFSET (KERNELBASE - MEMORY_START)
 #else
 #define VIRT_PHYS_OFFSET (KERNELBASE - PHYSICAL_START)
 #endif
diff -uNr linux-3.18.7/arch/powerpc/include/asm/sections.h linux-3.18.7-14.15/arch/powerpc/include/asm/sections.h
--- linux-3.18.7/arch/powerpc/include/asm/sections.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/include/asm/sections.h	2015-02-21 12:47:52.516421194 +0000
@@ -8,8 +8,13 @@
 
 #ifdef __powerpc64__
 
+#ifdef CONFIG_PPC_BOOK3E
+extern char interrupt_base_book3e[];
+extern char interrupt_end_book3e[];
+#else
 extern char __start_interrupts[];
 extern char __end_interrupts[];
+#endif
 
 extern char __prom_init_toc_start[];
 extern char __prom_init_toc_end[];
@@ -26,9 +31,13 @@
 							unsigned long end)
 {
 	unsigned long real_start, real_end;
+#ifdef CONFIG_PPC_BOOK3E
+	real_start = interrupt_base_book3e - _stext;
+	real_end = interrupt_end_book3e - _stext;
+#else
 	real_start = __start_interrupts - _stext;
 	real_end = __end_interrupts - _stext;
-
+#endif
 	return start < (unsigned long)__va(real_end) &&
 		(unsigned long)__va(real_start) < end;
 }
diff -uNr linux-3.18.7/arch/powerpc/include/asm/smp.h linux-3.18.7-14.15/arch/powerpc/include/asm/smp.h
--- linux-3.18.7/arch/powerpc/include/asm/smp.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/include/asm/smp.h	2015-02-21 12:47:52.518421194 +0000
@@ -199,6 +199,7 @@
 extern unsigned long __secondary_hold_spinloop;
 extern unsigned long __secondary_hold_acknowledge;
 extern char __secondary_hold;
+extern unsigned long __run_at_kexec;
 
 extern void __early_start(void);
 #endif /* __ASSEMBLY__ */
diff -uNr linux-3.18.7/arch/powerpc/kernel/exceptions-64e.S linux-3.18.7-14.15/arch/powerpc/kernel/exceptions-64e.S
--- linux-3.18.7/arch/powerpc/kernel/exceptions-64e.S	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/kernel/exceptions-64e.S	2015-02-21 12:47:52.523421194 +0000
@@ -1348,7 +1348,15 @@
  * r4 = MAS0 w/TLBSEL & ESEL for the temp mapping
  */
 	/* Now we branch the new virtual address mapped by this entry */
+#ifdef CONFIG_RELOCATABLE
+	/* We have to find out address from lr. */
+	bl	1f		/* Find our address */
+1:	mflr	r6
+	addi	r6,r6,(2f - 1b)
+	tovirt(r6,r6)
+#else
 	LOAD_REG_IMMEDIATE(r6,2f)
+#endif
 	lis	r7,MSR_KERNEL@h
 	ori	r7,r7,MSR_KERNEL@l
 	mtspr	SPRN_SRR0,r6
@@ -1580,9 +1588,17 @@
 	mflr	r28
 	b	3b
 
-init_core_book3e:
+_GLOBAL(init_core_book3e)
 	/* Establish the interrupt vector base */
+#ifdef CONFIG_RELOCATABLE
+/* In relocatable case the value of the constant expression 'expr' is only
+ * offset. So instead, we should loads the address of label 'name'.
+ */
+	tovirt(r2,r2)
+	LOAD_REG_ADDR(r3, interrupt_base_book3e)
+#else
 	LOAD_REG_IMMEDIATE(r3, interrupt_base_book3e)
+#endif
 	mtspr	SPRN_IVPR,r3
 	sync
 	blr
diff -uNr linux-3.18.7/arch/powerpc/kernel/head_64.S linux-3.18.7-14.15/arch/powerpc/kernel/head_64.S
--- linux-3.18.7/arch/powerpc/kernel/head_64.S	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/kernel/head_64.S	2015-02-21 12:47:52.524421193 +0000
@@ -91,6 +91,10 @@
 __secondary_hold_acknowledge:
 	.llong	0x0
 
+	.globl	__run_at_kexec
+__run_at_kexec:
+	.llong	0x0	/* Flag for the secondary kernel from kexec. */
+
 #ifdef CONFIG_RELOCATABLE
 	/* This flag is set to 1 by a loader if the kernel should run
 	 * at the loaded address instead of the linked address.  This
@@ -126,6 +130,10 @@
 	/* Grab our physical cpu number */
 	mr	r24,r3
 	/* stash r4 for book3e */
+#ifdef CONFIG_PPC_FSL_BOOK3E
+	/* we need to setup initial TLB entry. */
+	li	r4,0
+#endif
 	mr	r25,r4
 
 	/* Tell the master cpu we're here */
@@ -441,12 +449,31 @@
 	/* process relocations for the final address of the kernel */
 	lis	r25,PAGE_OFFSET@highest	/* compute virtual base of kernel */
 	sldi	r25,r25,32
+#if defined(CONFIG_PPC_BOOK3E)
+	tovirt(r26,r26)			/* on booke, we already run at PAGE_OFFSET */
+#endif
+#if defined(CONFIG_KEXEC) || defined(CONFIG_CRASH_DUMP)
+	/* If relocated we need to restore this flag on that relocated address. */
+	ld	r7,__run_at_kexec-_stext(r26)
+	std	r7,__run_at_kexec-_stext(r26)
+#endif
+
 	lwz	r7,__run_at_load-_stext(r26)
+#if defined(CONFIG_PPC_BOOK3E)
+	tophys(r26,r26)			/* Restore for the remains. */
+#endif
 	cmplwi	cr0,r7,1	/* flagged to stay where we are ? */
 	bne	1f
 	add	r25,r25,r26
 1:	mr	r3,r25
 	bl	relocate
+#if defined(CONFIG_PPC_BOOK3E)
+	/* In relocatable case we always have to load the address of label 'name'
+	 * to set IVPR. So after .relocate we have to update IVPR with current
+	 * address of label.
+	 */
+	bl	.init_core_book3e
+#endif
 #endif
 
 /*
@@ -461,12 +488,12 @@
 	tovirt(r3,r3)			/* on booke, we already run at PAGE_OFFSET */
 #endif
 	mr.	r4,r26			/* In some cases the loader may  */
+#if defined(CONFIG_PPC_BOOK3E)
+	tovirt(r4,r4)
+#endif
 	beq	9f			/* have already put us at zero */
 	li	r6,0x100		/* Start offset, the first 0x100 */
 					/* bytes were copied earlier.	 */
-#ifdef CONFIG_PPC_BOOK3E
-	tovirt(r6,r6)			/* on booke, we already run at PAGE_OFFSET */
-#endif
 
 #ifdef CONFIG_RELOCATABLE
 /*
@@ -474,12 +501,24 @@
  * variable __run_at_load, if it is set the kernel is treated as relocatable
  * kernel, otherwise it will be moved to PHYSICAL_START
  */
+#if defined(CONFIG_PPC_BOOK3E)
+	tovirt(r26,r26)			/* on booke, we already run at PAGE_OFFSET */
+#endif
 	lwz	r7,__run_at_load-_stext(r26)
+#if defined(CONFIG_PPC_BOOK3E)
+	tophys(r26,r26)			/* Restore for the remains. */
+#endif
 	cmplwi	cr0,r7,1
 	bne	3f
 
+#ifdef CONFIG_PPC_BOOK3E
+	LOAD_REG_ADDR(r5, interrupt_end_book3e)
+	LOAD_REG_ADDR(r11, _stext)
+	sub	r5,r5,r11
+#else
 	/* just copy interrupts */
 	LOAD_REG_IMMEDIATE(r5, __end_interrupts - _stext)
+#endif
 	b	5f
 3:
 #endif
@@ -498,6 +537,9 @@
 p_end:	.llong	_end - _stext
 
 4:	/* Now copy the rest of the kernel up to _end */
+#if defined(CONFIG_PPC_BOOK3E)
+	tovirt(r26,r26)
+#endif
 	addis	r5,r26,(p_end - _stext)@ha
 	ld	r5,(p_end - _stext)@l(r5)	/* get _end */
 5:	bl	copy_and_flush		/* copy the rest */
diff -uNr linux-3.18.7/arch/powerpc/kernel/machine_kexec_64.c linux-3.18.7-14.15/arch/powerpc/kernel/machine_kexec_64.c
--- linux-3.18.7/arch/powerpc/kernel/machine_kexec_64.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/kernel/machine_kexec_64.c	2015-02-21 12:47:52.527421193 +0000
@@ -30,72 +30,6 @@
 #include <asm/smp.h>
 #include <asm/hw_breakpoint.h>
 
-int default_machine_kexec_prepare(struct kimage *image)
-{
-	int i;
-	unsigned long begin, end;	/* limits of segment */
-	unsigned long low, high;	/* limits of blocked memory range */
-	struct device_node *node;
-	const unsigned long *basep;
-	const unsigned int *sizep;
-
-	if (!ppc_md.hpte_clear_all)
-		return -ENOENT;
-
-	/*
-	 * Since we use the kernel fault handlers and paging code to
-	 * handle the virtual mode, we must make sure no destination
-	 * overlaps kernel static data or bss.
-	 */
-	for (i = 0; i < image->nr_segments; i++)
-		if (image->segment[i].mem < __pa(_end))
-			return -ETXTBSY;
-
-	/*
-	 * For non-LPAR, we absolutely can not overwrite the mmu hash
-	 * table, since we are still using the bolted entries in it to
-	 * do the copy.  Check that here.
-	 *
-	 * It is safe if the end is below the start of the blocked
-	 * region (end <= low), or if the beginning is after the
-	 * end of the blocked region (begin >= high).  Use the
-	 * boolean identity !(a || b)  === (!a && !b).
-	 */
-	if (htab_address) {
-		low = __pa(htab_address);
-		high = low + htab_size_bytes;
-
-		for (i = 0; i < image->nr_segments; i++) {
-			begin = image->segment[i].mem;
-			end = begin + image->segment[i].memsz;
-
-			if ((begin < high) && (end > low))
-				return -ETXTBSY;
-		}
-	}
-
-	/* We also should not overwrite the tce tables */
-	for_each_node_by_type(node, "pci") {
-		basep = of_get_property(node, "linux,tce-base", NULL);
-		sizep = of_get_property(node, "linux,tce-size", NULL);
-		if (basep == NULL || sizep == NULL)
-			continue;
-
-		low = *basep;
-		high = low + (*sizep);
-
-		for (i = 0; i < image->nr_segments; i++) {
-			begin = image->segment[i].mem;
-			end = begin + image->segment[i].memsz;
-
-			if ((begin < high) && (end > low))
-				return -ETXTBSY;
-		}
-	}
-
-	return 0;
-}
-
 #define IND_FLAGS (IND_DESTINATION | IND_INDIRECTION | IND_DONE | IND_SOURCE)
 
 static void copy_segments(unsigned long ind)
@@ -367,6 +301,87 @@
 	/* NOTREACHED */
 }
 
+#ifdef CONFIG_PPC_BOOK3E
+int default_machine_kexec_prepare(struct kimage *image)
+{
+	int i;
+	/*
+	 * Since we use the kernel fault handlers and paging code to
+	 * handle the virtual mode, we must make sure no destination
+	 * overlaps kernel static data or bss.
+	 */
+	for (i = 0; i < image->nr_segments; i++)
+		if (image->segment[i].mem < __pa(_end))
+			return -ETXTBSY;
+	return 0;
+}
+#else /* CONFIG_PPC_BOOK3E */
+int default_machine_kexec_prepare(struct kimage *image)
+{
+	int i;
+	unsigned long begin, end;	/* limits of segment */
+	unsigned long low, high;	/* limits of blocked memory range */
+	struct device_node *node;
+	const unsigned long *basep;
+	const unsigned int *sizep;
+
+	if (!ppc_md.hpte_clear_all)
+		return -ENOENT;
+
+	/*
+	 * Since we use the kernel fault handlers and paging code to
+	 * handle the virtual mode, we must make sure no destination
+	 * overlaps kernel static data or bss.
+	 */
+	for (i = 0; i < image->nr_segments; i++)
+		if (image->segment[i].mem < __pa(_end))
+			return -ETXTBSY;
+
+	/*
+	 * For non-LPAR, we absolutely can not overwrite the mmu hash
+	 * table, since we are still using the bolted entries in it to
+	 * do the copy.  Check that here.
+	 *
+	 * It is safe if the end is below the start of the blocked
+	 * region (end <= low), or if the beginning is after the
+	 * end of the blocked region (begin >= high).  Use the
+	 * boolean identity !(a || b)  === (!a && !b).
+	 */
+	if (htab_address) {
+		low = __pa(htab_address);
+		high = low + htab_size_bytes;
+
+		for (i = 0; i < image->nr_segments; i++) {
+			begin = image->segment[i].mem;
+			end = begin + image->segment[i].memsz;
+
+			if ((begin < high) && (end > low))
+				return -ETXTBSY;
+		}
+	}
+
+	/* We also should not overwrite the tce tables */
+	for_each_node_by_type(node, "pci") {
+		basep = of_get_property(node, "linux,tce-base", NULL);
+		sizep = of_get_property(node, "linux,tce-size", NULL);
+		if (basep == NULL || sizep == NULL)
+			continue;
+
+		low = *basep;
+		high = low + (*sizep);
+
+		for (i = 0; i < image->nr_segments; i++) {
+			begin = image->segment[i].mem;
+			end = begin + image->segment[i].memsz;
+
+			if ((begin < high) && (end > low))
+				return -ETXTBSY;
+		}
+	}
+
+	return 0;
+}
+
 /* Values we need to export to the second kernel via the device tree. */
 static unsigned long htab_base;
 static unsigned long htab_size;
@@ -413,3 +428,4 @@
 	return 0;
 }
 late_initcall(export_htab_values);
+#endif /* !CONFIG_PPC_BOOK3E */
diff -uNr linux-3.18.7/arch/powerpc/kernel/misc_64.S linux-3.18.7-14.15/arch/powerpc/kernel/misc_64.S
--- linux-3.18.7/arch/powerpc/kernel/misc_64.S	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/kernel/misc_64.S	2015-02-21 12:47:52.532421193 +0000
@@ -487,6 +487,49 @@
 
 
 #ifdef CONFIG_KEXEC
+#ifdef CONFIG_PPC_BOOK3E
+/* BOOK3E have no a real MMU mode so we have to setup the initial TLB
+ * for a core to map v:0 to p:0 as 1:1. This current implementation
+ * assume that 1G is enough for kexec.
+ */
+#include <asm/mmu.h>
+kexec_create_tlb:
+	/* Invalidate all TLBs to avoid any TLB conflict. */
+	PPC_TLBILX_ALL(0,R0)
+	sync
+	isync
+
+	mfspr	r10,SPRN_TLB1CFG
+	andi.	r10,r10,TLBnCFG_N_ENTRY	/* Extract # entries */
+	subi	r10,r10,1		/* Often its always safe to use last */
+	lis	r9,MAS0_TLBSEL(1)@h
+	rlwimi	r9,r10,16,4,15		/* Setup MAS0 = TLBSEL | ESEL(r9) */
+
+/* Setup a temp mapping v:0 to p:0 as 1:1 and return to it.
+ */
+#ifdef CONFIG_SMP
+#define M_IF_SMP	MAS2_M
+#else
+#define M_IF_SMP	0
+#endif
+	mtspr	SPRN_MAS0,r9
+
+	lis	r9,(MAS1_VALID|MAS1_IPROT)@h
+	ori	r9,r9,(MAS1_TSIZE(BOOK3E_PAGESZ_1GB))@l
+	mtspr	SPRN_MAS1,r9
+
+	LOAD_REG_IMMEDIATE(r9, 0x0 | M_IF_SMP)
+	mtspr	SPRN_MAS2,r9
+
+	LOAD_REG_IMMEDIATE(r9, 0x0 | MAS3_SR | MAS3_SW | MAS3_SX)
+	mtspr	SPRN_MAS3,r9
+	li	r9,0
+	mtspr	SPRN_MAS7,r9
+
+	tlbwe
+	isync
+	blr
+#endif
 
 /* kexec_smp_wait(void)
  *
@@ -500,6 +543,10 @@
  */
 _GLOBAL(kexec_smp_wait)
 	lhz	r3,PACAHWCPUID(r13)
+#ifdef CONFIG_PPC_BOOK3E
+	/* Create a 1:1 mapping. */
+	bl	kexec_create_tlb
+#endif
 	bl	real_mode
 
 	li	r4,KEXEC_STATE_REAL_MODE
@@ -516,6 +563,7 @@
  * don't overwrite r3 here, it is live for kexec_wait above.
  */
 real_mode:	/* assume normal blr return */
+#ifndef CONFIG_PPC_BOOK3E
 1:	li	r9,MSR_RI
 	li	r10,MSR_DR|MSR_IR
 	mflr	r11		/* return address to SRR0 */
@@ -527,7 +575,10 @@
 	mtspr	SPRN_SRR1,r10
 	mtspr	SPRN_SRR0,r11
 	rfid
-
+#else
+	/* the real mode is nothing for book3e. */
+	blr
+#endif
 
 /*
  * kexec_sequence(newstack, start, image, control, clear_all())
@@ -570,9 +621,15 @@
 	lhz	r25,PACAHWCPUID(r13)	/* get our phys cpu from paca */
 
 	/* disable interrupts, we are overwriting kernel data next */
+#ifndef CONFIG_PPC_BOOK3E
 	mfmsr	r3
 	rlwinm	r3,r3,0,17,15
 	mtmsrd	r3,1
+#else
+	wrteei	0
+	/* Create a 1:1 mapping. */
+	bl	kexec_create_tlb
+#endif
 
 	/* copy dest pages, flush whole dest image */
 	mr	r3,r29
@@ -589,11 +646,18 @@
 	bl	copy_and_flush	/* (dest, src, copy limit, start offset) */
 1:	/* assume normal blr return */
 
+	/* notify we're going into kexec kernel for SMP. */
+	LOAD_REG_ADDR(r3,__run_at_kexec)
+	li	r4,1
+	std	r4,0(r3)
+	sync
+
 	/* release other cpus to the new kernel secondary start at 0x60 */
 	mflr	r5
 	li	r6,1
 	stw	r6,kexec_flag-1b(5)
 
+#ifndef CONFIG_PPC_BOOK3E
 	/* clear out hardware hash page table and tlb */
 #if !defined(_CALL_ELF) || _CALL_ELF != 2
 	ld	r12,0(r27)		/* deref function descriptor */
@@ -602,6 +666,7 @@
 #endif
 	mtctr	r12
 	bctrl				/* ppc_md.hpte_clear_all(void); */
+#endif
 
 /*
  *   kexec image calling is:
diff -uNr linux-3.18.7/arch/powerpc/kernel/pci-common.c linux-3.18.7-14.15/arch/powerpc/kernel/pci-common.c
--- linux-3.18.7/arch/powerpc/kernel/pci-common.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/kernel/pci-common.c	2015-02-21 12:47:52.532421193 +0000
@@ -211,6 +211,7 @@
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(pci_find_hose_for_OF_device);
 
 /*
  * Reads the interrupt pin to determine if interrupt is use by card.
@@ -1448,9 +1449,15 @@
 	return pci_enable_resources(dev, mask);
 }
 
+/* Before assuming too much here, take care to realize that we need sign
+ * extension from 32-bit pointers to 64-bit resource addresses to work.
+ */
 resource_size_t pcibios_io_space_offset(struct pci_controller *hose)
 {
-	return (unsigned long) hose->io_base_virt - _IO_BASE;
+	long vbase = (long)hose->io_base_virt;
+	long io_base = _IO_BASE;
+
+	return (resource_size_t)(vbase - io_base);
 }
 
 static void pcibios_setup_phb_resources(struct pci_controller *hose,
@@ -1570,6 +1577,7 @@
 {
 	return pci_bus_find_capability(fake_pci_bus(hose, bus), devfn, cap);
 }
+EXPORT_SYMBOL_GPL(early_find_capability);
 
 struct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)
 {
diff -uNr linux-3.18.7/arch/powerpc/lib/feature-fixups.c linux-3.18.7-14.15/arch/powerpc/lib/feature-fixups.c
--- linux-3.18.7/arch/powerpc/lib/feature-fixups.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/lib/feature-fixups.c	2015-02-21 12:47:52.537421192 +0000
@@ -141,8 +141,11 @@
 
 	src = (int *)(KERNELBASE + PHYSICAL_START);
 	dest = (int *)KERNELBASE;
+#ifdef CONFIG_PPC_BOOK3E
+	length = (interrupt_end_book3e - _stext) / sizeof(int);
+#else
 	length = (__end_interrupts - _stext) / sizeof(int);
-
+#endif
 	while (length--) {
 		patch_instruction(dest, *src);
 		src++;
diff -uNr linux-3.18.7/arch/powerpc/platforms/85xx/smp.c linux-3.18.7-14.15/arch/powerpc/platforms/85xx/smp.c
--- linux-3.18.7/arch/powerpc/platforms/85xx/smp.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/powerpc/platforms/85xx/smp.c	2015-02-21 12:47:52.543421192 +0000
@@ -196,6 +196,9 @@
 	int hw_cpu = get_hard_smp_processor_id(nr);
 	int ioremappable;
 	int ret = 0;
+#ifdef CONFIG_PPC64
+	unsigned long *ptr = NULL;
+#endif
 
 	WARN_ON(nr < 0 || nr >= NR_CPUS);
 	WARN_ON(hw_cpu < 0 || hw_cpu >= NR_CPUS);
@@ -309,11 +312,18 @@
 #else
 	smp_generic_kick_cpu(nr);
 
-	flush_spin_table(spin_table);
-	out_be32(&spin_table->pir, hw_cpu);
-	out_be64((u64 *)(&spin_table->addr_h),
-		__pa(ppc_function_entry(generic_secondary_smp_init)));
-	flush_spin_table(spin_table);
+	ptr  = (unsigned long *)((unsigned long)&__run_at_kexec);
+	/* We shouldn't access spin_table from the bootloader to up any
+	 * secondary cpu for kexec kernel, and kexec kernel already
+	 * know how to jump to generic_secondary_smp_init.
+	 */
+	if (!*ptr) {
+		flush_spin_table(spin_table);
+		out_be32(&spin_table->pir, hw_cpu);
+		out_be64((u64 *)(&spin_table->addr_h),
+		 __pa((u64)*((unsigned long long *)generic_secondary_smp_init)));
+		flush_spin_table(spin_table);
+	}
 #endif
 
 	local_irq_restore(flags);
@@ -331,13 +341,14 @@
 	.cpu_disable	= generic_cpu_disable,
 	.cpu_die	= generic_cpu_die,
 #endif
-#ifdef CONFIG_KEXEC
+#if defined(CONFIG_KEXEC) && defined(CONFIG_PPC32)
 	.give_timebase	= smp_generic_give_timebase,
 	.take_timebase	= smp_generic_take_timebase,
 #endif
 };
 
 #ifdef CONFIG_KEXEC
+#ifdef CONFIG_PPC32
 atomic_t kexec_down_cpus = ATOMIC_INIT(0);
 
 void mpc85xx_smp_kexec_cpu_down(int crash_shutdown, int secondary)
@@ -356,6 +367,14 @@
 	if (ppc_md.kexec_cpu_down)
 		ppc_md.kexec_cpu_down(0,1);
 }
+#else
+void mpc85xx_smp_kexec_cpu_down(int crash_shutdown, int secondary)
+{
+	local_irq_disable();
+	hard_irq_disable();
+	mpic_teardown_this_cpu(secondary);
+}
+#endif
 
 static void map_and_flush(unsigned long paddr)
 {
@@ -407,11 +426,14 @@
 
 static void mpc85xx_smp_machine_kexec(struct kimage *image)
 {
+#ifdef CONFIG_PPC32
 	int timeout = INT_MAX;
 	int i, num_cpus = num_present_cpus();
+#endif
 
 	mpc85xx_smp_flush_dcache_kexec(image);
 
+#ifdef CONFIG_PPC32
 	if (image->type == KEXEC_TYPE_DEFAULT)
 		smp_call_function(mpc85xx_smp_kexec_down, NULL, 0);
 
@@ -429,6 +451,7 @@
 		if ( i == smp_processor_id() ) continue;
 		mpic_reset_core(i);
 	}
+#endif
 
 	default_machine_kexec(image);
 }
diff -uNr linux-3.18.7/arch/x86/include/asm/dma-mapping.h linux-3.18.7-14.15/arch/x86/include/asm/dma-mapping.h
--- linux-3.18.7/arch/x86/include/asm/dma-mapping.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/x86/include/asm/dma-mapping.h	2015-02-21 12:47:52.641421181 +0000
@@ -163,8 +163,6 @@
 {
 	struct dma_map_ops *ops = get_dma_ops(dev);
 
-	WARN_ON(irqs_disabled());       /* for portability */
-
 	if (dma_release_from_coherent(dev, get_order(size), vaddr))
 		return;
 
diff -uNr linux-3.18.7/arch/x86/kernel/reboot.c linux-3.18.7-14.15/arch/x86/kernel/reboot.c
--- linux-3.18.7/arch/x86/kernel/reboot.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/arch/x86/kernel/reboot.c	2015-02-21 12:47:52.684421177 +0000
@@ -396,7 +396,46 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "VGN-Z540N"),
 		},
 	},
-
+	{	/* Handle problems with rebooting on the Latitude E6520. */
+		.callback = set_pci_reboot,
+		.ident = "Dell Latitude E6520",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6520"),
+		},
+	},
+	{       /* Handle problems with rebooting on the OptiPlex 790. */
+		.callback = set_pci_reboot,
+		.ident = "Dell OptiPlex 790",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 790"),
+		},
+	},
+	{	/* Handle problems with rebooting on the OptiPlex 990. */
+		.callback = set_pci_reboot,
+		.ident = "Dell OptiPlex 990",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 990"),
+		},
+	},
+	{       /* Handle problems with rebooting on the Latitude E6220. */
+		.callback = set_pci_reboot,
+		.ident = "Dell Latitude E6220",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Latitude E6220"),
+		},
+	},
+	{	/* Handle problems with rebooting on the OptiPlex 390. */
+		.callback = set_pci_reboot,
+		.ident = "Dell OptiPlex 390",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex 390"),
+		},
+	},
 	{ }
 };
 
diff -uNr linux-3.18.7/arch/x86/kvm/x86.c linux-3.18.7-14.15/arch/x86/kvm/x86.c
--- linux-3.18.7/arch/x86/kvm/x86.c	2015-02-21 12:52:13.845394487 +0000
+++ linux-3.18.7-14.15/arch/x86/kvm/x86.c	2015-02-21 12:47:52.703421175 +0000
@@ -5760,7 +5760,7 @@
 		goto out;
 	}
 	if (ops->disabled_by_bios()) {
-		printk(KERN_ERR "kvm: disabled by bios\n");
+		printk(KERN_WARNING "kvm: disabled by bios\n");
 		r = -EOPNOTSUPP;
 		goto out;
 	}
diff -uNr linux-3.18.7/arch/x86/tools/calc_run_size.pl linux-3.18.7-14.15/arch/x86/tools/calc_run_size.pl
--- linux-3.18.7/arch/x86/tools/calc_run_size.pl	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/arch/x86/tools/calc_run_size.pl	2014-12-07 22:21:05.000000000 +0000
@@ -0,0 +1,39 @@
+#!/usr/bin/perl
+#
+# Calculate the amount of space needed to run the kernel, including room for
+# the .bss and .brk sections.
+#
+# Usage:
+# objdump -h a.out | perl calc_run_size.pl
+use strict;
+
+my $mem_size = 0;
+my $file_offset = 0;
+
+my $sections=" *[0-9]+ \.(?:bss|brk) +";
+while (<>) {
+	if (/^$sections([0-9a-f]+) +(?:[0-9a-f]+ +){2}([0-9a-f]+)/) {
+		my $size = hex($1);
+		my $offset = hex($2);
+		$mem_size += $size;
+		if ($file_offset == 0) {
+			$file_offset = $offset;
+		} elsif ($file_offset != $offset) {
+			# BFD linker shows the same file offset in ELF.
+			# Gold linker shows them as consecutive.
+			next if ($file_offset + $mem_size == $offset + $size);
+
+			printf STDERR "file_offset: 0x%lx\n", $file_offset;
+			printf STDERR "mem_size: 0x%lx\n", $mem_size;
+			printf STDERR "offset: 0x%lx\n", $offset;
+			printf STDERR "size: 0x%lx\n", $size;
+
+			die ".bss and .brk are non-contiguous\n";
+		}
+	}
+}
+
+if ($file_offset == 0) {
+	die "Never found .bss or .brk file offset\n";
+}
+printf("%d\n", $mem_size + $file_offset);
diff -uNr linux-3.18.7/block/scsi_ioctl.c linux-3.18.7-14.15/block/scsi_ioctl.c
--- linux-3.18.7/block/scsi_ioctl.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/block/scsi_ioctl.c	2015-02-21 12:47:52.727421173 +0000
@@ -28,6 +28,9 @@
 #include <linux/slab.h>
 #include <linux/times.h>
 #include <linux/uio.h>
+#include <linux/fd.h>
+#include <linux/raid/md_u.h>
+#include <linux/mtio.h>
 #include <asm/uaccess.h>
 
 #include <scsi/scsi.h>
@@ -716,8 +719,17 @@
 	case SG_GET_RESERVED_SIZE:
 	case SG_SET_RESERVED_SIZE:
 	case SG_EMULATED_HOST:
+	case BLKFLSBUF:
+	case BLKROSET:
 		return 0;
 	case CDROM_GET_CAPABILITY:
+	case CDROM_DRIVE_STATUS:
+	case FDGETPRM:
+	case RAID_VERSION:
+	case MTIOCGET:
+#ifdef CONFIG_COMPAT
+	case 0x801c6d02:        /* MTIOCGET32 */
+#endif
 		/* Keep this until we remove the printk below.  udev sends it
 		 * and we do not want to spam dmesg about it.   CD-ROMs do
 		 * not have partitions, so we get here only for disks.
diff -uNr linux-3.18.7/drivers/acpi/blacklist.c linux-3.18.7-14.15/drivers/acpi/blacklist.c
--- linux-3.18.7/drivers/acpi/blacklist.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/acpi/blacklist.c	2015-02-21 12:47:53.670421076 +0000
@@ -300,6 +300,85 @@
 	},
 
 	/*
+	 * The following Lenovo models have a broken workaround in the
+	 * acpi_video backlight implementation to meet the Windows 8
+	 * requirement of 101 backlight levels. Reverting to pre-Win8
+	 * behavior fixes the problem.
+	 */
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad L430",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad L430"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad T430",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T430"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad T430s",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T430s"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad T530",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T530"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad W530",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad W530"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad X1 Carbon",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X1 Carbon"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad X230",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X230"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad Edge E330",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad Edge E330"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Dell Inspiron 5537",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 5537"),
+		},
+	},
+
+	/*
 	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.
 	 * Linux ignores it, except for the machines enumerated below.
 	 */
diff -uNr linux-3.18.7/drivers/block/nbd.c linux-3.18.7-14.15/drivers/block/nbd.c
--- linux-3.18.7/drivers/block/nbd.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/block/nbd.c	2015-02-21 12:47:53.715421072 +0000
@@ -57,7 +57,7 @@
 
 static unsigned int nbds_max = 16;
 static struct nbd_device *nbd_dev;
-static int max_part;
+static int max_part = 15;
 
 /*
  * Use just one lock (or at most 1 per NIC). Two arguments for this:
diff -uNr linux-3.18.7/drivers/bluetooth/ath3k.c linux-3.18.7-14.15/drivers/bluetooth/ath3k.c
--- linux-3.18.7/drivers/bluetooth/ath3k.c	2015-02-21 12:52:14.177394453 +0000
+++ linux-3.18.7-14.15/drivers/bluetooth/ath3k.c	2015-02-21 12:47:53.716421072 +0000
@@ -170,6 +170,8 @@
 #define USB_REQ_DFU_DNLOAD	1
 #define BULK_SIZE		4096
 #define FW_HDR_SIZE		20
+#define TIMEGAP_USEC_MIN	50
+#define TIMEGAP_USEC_MAX	100
 
 static int ath3k_load_firmware(struct usb_device *udev,
 				const struct firmware *firmware)
@@ -201,6 +203,9 @@
 	pipe = usb_sndbulkpipe(udev, 0x02);
 
 	while (count) {
+		/* workaround the compatibility issue with xHCI controller*/
+		usleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);
+
 		size = min_t(uint, count, BULK_SIZE);
 		memcpy(send_buf, firmware->data + sent, size);
 
@@ -298,6 +303,9 @@
 	pipe = usb_sndbulkpipe(udev, 0x02);
 
 	while (count) {
+		/* workaround the compatibility issue with xHCI controller*/
+		usleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);
+
 		size = min_t(uint, count, BULK_SIZE);
 		memcpy(send_buf, firmware->data + sent, size);
 
diff -uNr linux-3.18.7/drivers/cdrom/cdrom.c linux-3.18.7-14.15/drivers/cdrom/cdrom.c
--- linux-3.18.7/drivers/cdrom/cdrom.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/cdrom/cdrom.c	2015-02-21 12:47:53.724421071 +0000
@@ -289,7 +289,7 @@
 /* default compatibility mode */
 static bool autoclose=1;
 static bool autoeject;
-static bool lockdoor = 1;
+static bool lockdoor = 0;
 /* will we ever get to use this... sigh. */
 static bool check_media_type;
 /* automatically restart mrw format */
diff -uNr linux-3.18.7/drivers/char/tpm/tpm_ibmvtpm.c linux-3.18.7-14.15/drivers/char/tpm/tpm_ibmvtpm.c
--- linux-3.18.7/drivers/char/tpm/tpm_ibmvtpm.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/char/tpm/tpm_ibmvtpm.c	2015-02-21 12:47:53.727421071 +0000
@@ -307,6 +307,14 @@
 static unsigned long tpm_ibmvtpm_get_desired_dma(struct vio_dev *vdev)
 {
 	struct ibmvtpm_dev *ibmvtpm = ibmvtpm_get_data(&vdev->dev);
+
+	/* ibmvtpm initializes at probe time, so the data we are
+	* asking for may not be set yet. Estimate that 4K required
+	* for TCE-mapped buffer in addition to CRQ.
+	*/
+	if (!ibmvtpm)
+		return CRQ_RES_BUF_SIZE + PAGE_SIZE;
+
 	return CRQ_RES_BUF_SIZE + ibmvtpm->rtce_size;
 }
 
diff -uNr linux-3.18.7/drivers/cpufreq/cpufreq.c linux-3.18.7-14.15/drivers/cpufreq/cpufreq.c
--- linux-3.18.7/drivers/cpufreq/cpufreq.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/cpufreq/cpufreq.c	2015-02-21 12:47:53.748421068 +0000
@@ -2413,6 +2413,20 @@
  *               REGISTER / UNREGISTER CPUFREQ DRIVER                *
  *********************************************************************/
 
+static char cpufreq_driver_name[CPUFREQ_NAME_LEN];
+
+static int __init cpufreq_driver_setup(char *str)
+{
+	strlcpy(cpufreq_driver_name, str, CPUFREQ_NAME_LEN);
+	return 1;
+}
+
+/*
+ * Set this name to only allow one specific cpu freq driver, e.g.,
+ * cpufreq_driver=powernow-k8
+ */
+__setup("cpufreq_driver=", cpufreq_driver_setup);
+
 /**
  * cpufreq_register_driver - register a CPU Frequency driver
  * @driver_data: A struct cpufreq_driver containing the values#
@@ -2439,7 +2453,13 @@
 	     (!!driver_data->get_intermediate != !!driver_data->target_intermediate))
 		return -EINVAL;
 
-	pr_debug("trying to register driver %s\n", driver_data->name);
+	pr_debug("trying to register driver %s, cpufreq_driver=%s\n",
+		driver_data->name, cpufreq_driver_name);
+
+	if (cpufreq_driver_name[0])
+		if (!driver_data->name ||
+			strcmp(cpufreq_driver_name, driver_data->name))
+				return -EINVAL;
 
 	if (driver_data->setpolicy)
 		driver_data->flags |= CPUFREQ_CONST_LOOPS;
diff -uNr linux-3.18.7/drivers/cpufreq/intel_pstate.c linux-3.18.7-14.15/drivers/cpufreq/intel_pstate.c
--- linux-3.18.7/drivers/cpufreq/intel_pstate.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/cpufreq/intel_pstate.c	2015-02-21 12:47:53.748421068 +0000
@@ -1018,6 +1018,8 @@
 	intel_pstate_debug_expose_params();
 	intel_pstate_sysfs_expose_params();
 
+	pr_info("Consider also installing thermald for improved thermal control.\n");
+
 	return rc;
 out:
 	get_online_cpus();
diff -uNr linux-3.18.7/drivers/firmware/efi/efi.c linux-3.18.7-14.15/drivers/firmware/efi/efi.c
--- linux-3.18.7/drivers/firmware/efi/efi.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/firmware/efi/efi.c	2015-02-21 12:47:53.763421067 +0000
@@ -112,15 +112,24 @@
 EFI_ATTR_SHOW(runtime);
 EFI_ATTR_SHOW(config_table);
 
+static ssize_t fw_platform_size_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", efi_enabled(EFI_64BIT) ? 64 : 32);
+}
+
 static struct kobj_attribute efi_attr_fw_vendor = __ATTR_RO(fw_vendor);
 static struct kobj_attribute efi_attr_runtime = __ATTR_RO(runtime);
 static struct kobj_attribute efi_attr_config_table = __ATTR_RO(config_table);
+static struct kobj_attribute efi_attr_fw_platform_size =
+	__ATTR_RO(fw_platform_size);
 
 static struct attribute *efi_subsys_attrs[] = {
 	&efi_attr_systab.attr,
 	&efi_attr_fw_vendor.attr,
 	&efi_attr_runtime.attr,
 	&efi_attr_config_table.attr,
+	&efi_attr_fw_platform_size.attr,
 	NULL,
 };
 
diff -uNr linux-3.18.7/drivers/gpu/drm/drm_crtc_helper.c linux-3.18.7-14.15/drivers/gpu/drm/drm_crtc_helper.c
--- linux-3.18.7/drivers/gpu/drm/drm_crtc_helper.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/gpu/drm/drm_crtc_helper.c	2015-02-21 12:47:53.778421065 +0000
@@ -560,13 +560,12 @@
 				if (new_encoder == NULL)
 					/* don't break so fail path works correct */
 					fail = 1;
+				break;
 
 				if (connector->dpms != DRM_MODE_DPMS_ON) {
 					DRM_DEBUG_KMS("connector dpms not on, full mode switch\n");
 					mode_changed = true;
 				}
-
-				break;
 			}
 		}
 
diff -uNr linux-3.18.7/drivers/gpu/drm/nouveau/nouveau_bios.c linux-3.18.7-14.15/drivers/gpu/drm/nouveau/nouveau_bios.c
--- linux-3.18.7/drivers/gpu/drm/nouveau/nouveau_bios.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/gpu/drm/nouveau/nouveau_bios.c	2015-02-21 12:47:53.831421060 +0000
@@ -350,7 +350,7 @@
 		/* Apple cards don't have the fp table; the laptops use DDC */
 		/* The table is also missing on some x86 IGPs */
 #ifndef __powerpc__
-		NV_ERROR(drm, "Pointer to flat panel table invalid\n");
+		NV_WARN(drm, "Pointer to flat panel table invalid\n");
 #endif
 		bios->digital_min_front_porch = 0x4b;
 		return 0;
@@ -934,7 +934,7 @@
 
 	tmdstableptr = ROM16(bios->data[bitentry->offset]);
 	if (!tmdstableptr) {
-		NV_ERROR(drm, "Pointer to TMDS table invalid\n");
+		NV_WARN(drm, "Pointer to TMDS table invalid\n");
 		return -EINVAL;
 	}
 
diff -uNr linux-3.18.7/drivers/hid/Kconfig linux-3.18.7-14.15/drivers/hid/Kconfig
--- linux-3.18.7/drivers/hid/Kconfig	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/hid/Kconfig	2015-02-21 12:47:53.914421051 +0000
@@ -27,7 +27,7 @@
 
 config HID_BATTERY_STRENGTH
 	bool "Battery level reporting for HID devices"
-	depends on HID && POWER_SUPPLY && HID = POWER_SUPPLY
+	depends on HID && POWER_SUPPLY
 	default n
 	---help---
 	This option adds support of reporting battery strength (for HID devices
diff -uNr linux-3.18.7/drivers/input/mouse/cypress_ps2.c linux-3.18.7-14.15/drivers/input/mouse/cypress_ps2.c
--- linux-3.18.7/drivers/input/mouse/cypress_ps2.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/input/mouse/cypress_ps2.c	2015-02-21 12:47:53.950421048 +0000
@@ -390,7 +390,9 @@
 	if (ret < 0)
 		return ret;
 
+#if ( CYPRESS_SIMULATED_MT != 1 )
 	__set_bit(INPUT_PROP_SEMI_MT, input->propbit);
+#endif
 
 	input_abs_set_res(input, ABS_X, cytp->tp_res_x);
 	input_abs_set_res(input, ABS_Y, cytp->tp_res_y);
@@ -478,6 +480,22 @@
 			((packet[5] & 0x0f) << 8) | packet[7];
 		if (cytp->mode & CYTP_BIT_ABS_PRESSURE)
 			report_data->contacts[1].z = report_data->contacts[0].z;
+#if ( CYPRESS_SIMULATED_MT == 1 )
+		/* simulate contact positions for >2 fingers */
+		if ( report_data->contact_cnt >= 3 ) {
+			int i;
+			for ( i=1; i<report_data->contact_cnt; i++ ) {
+			    report_data->contacts[i].x =
+					    report_data->contacts[0].x
+					    + 100*(i)*((i%2)?-1:1);
+			    report_data->contacts[i].y =
+					    report_data->contacts[0].y;
+			    if (cytp->mode & CYTP_BIT_ABS_PRESSURE)
+				    report_data->contacts[i].z =
+					    report_data->contacts[0].z;
+			}
+		}
+#endif
 	}
 
 	report_data->left = (header_byte & BTN_LEFT_BIT) ? 1 : 0;
diff -uNr linux-3.18.7/drivers/input/mouse/cypress_ps2.h linux-3.18.7-14.15/drivers/input/mouse/cypress_ps2.h
--- linux-3.18.7/drivers/input/mouse/cypress_ps2.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/input/mouse/cypress_ps2.h	2015-02-21 12:47:53.952421048 +0000
@@ -130,7 +130,18 @@
 #define RESP_REMOTE_BIT     0x40
 #define RESP_SMBUS_BIT      0x80
 
-#define CYTP_MAX_MT_SLOTS 2
+/*
+ * CYPRESS_SIMULATED_MT
+ *   set to 1 for simulated multitouch (up to 5 contact points)
+ *   set to 0 for SEMI_MT (only 2 corner points, and count of fingers)
+ */
+#define CYPRESS_SIMULATED_MT 1
+
+#if ( CYPRESS_SIMULATED_MT == 1 )
+# define CYTP_MAX_MT_SLOTS 5
+#else
+# define CYTP_MAX_MT_SLOTS 2
+#endif
 
 struct cytp_contact {
 	int x;
diff -uNr linux-3.18.7/drivers/md/bcache/writeback.h linux-3.18.7-14.15/drivers/md/bcache/writeback.h
--- linux-3.18.7/drivers/md/bcache/writeback.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/md/bcache/writeback.h	2015-02-21 12:47:53.977421045 +0000
@@ -63,7 +63,8 @@
 
 static inline void bch_writeback_queue(struct cached_dev *dc)
 {
-	wake_up_process(dc->writeback_thread);
+	if (!IS_ERR_OR_NULL(dc->writeback_thread))
+		wake_up_process(dc->writeback_thread);
 }
 
 static inline void bch_writeback_add(struct cached_dev *dc)
diff -uNr linux-3.18.7/drivers/md/dm-crypt.c linux-3.18.7-14.15/drivers/md/dm-crypt.c
--- linux-3.18.7/drivers/md/dm-crypt.c	2015-02-21 12:52:14.712394398 +0000
+++ linux-3.18.7-14.15/drivers/md/dm-crypt.c	2015-02-21 12:47:53.980421045 +0000
@@ -1974,6 +1974,12 @@
 	return fn(ti, cc->dev, cc->start, ti->len, data);
 }
 
+static void crypt_io_hints(struct dm_target *ti,
+			    struct queue_limits *limits)
+{
+	limits->max_write_same_sectors = 0;
+}
+
 static struct target_type crypt_target = {
 	.name   = "crypt",
 	.version = {1, 13, 0},
@@ -1988,6 +1994,7 @@
 	.message = crypt_message,
 	.merge  = crypt_merge,
 	.iterate_devices = crypt_iterate_devices,
+	.io_hints = crypt_io_hints,
 };
 
 static int __init dm_crypt_init(void)
diff -uNr linux-3.18.7/drivers/md/dm.c linux-3.18.7-14.15/drivers/md/dm.c
--- linux-3.18.7/drivers/md/dm.c	2015-02-21 12:52:14.727394397 +0000
+++ linux-3.18.7-14.15/drivers/md/dm.c	2015-02-21 12:47:53.987421044 +0000
@@ -2952,6 +2952,7 @@
 {
 	return md->disk;
 }
+EXPORT_SYMBOL_GPL(dm_disk);
 
 struct kobject *dm_kobject(struct mapped_device *md)
 {
diff -uNr linux-3.18.7/drivers/media/usb/uvc/uvc_driver.c linux-3.18.7-14.15/drivers/media/usb/uvc/uvc_driver.c
--- linux-3.18.7/drivers/media/usb/uvc/uvc_driver.c	2015-02-21 12:52:14.773394392 +0000
+++ linux-3.18.7-14.15/drivers/media/usb/uvc/uvc_driver.c	2015-02-21 12:47:54.016421041 +0000
@@ -2247,6 +2247,15 @@
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
 	  .driver_info		= UVC_QUIRK_PROBE_DEF },
+	/* Alienware X51*/
+	{ .match_flags          = USB_DEVICE_ID_MATCH_DEVICE
+				  | USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor             = 0x05a9,
+	  .idProduct            = 0x2643,
+	  .bInterfaceClass      = USB_CLASS_VIDEO,
+	  .bInterfaceSubClass   = 1,
+	  .bInterfaceProtocol   = 0,
+	  .driver_info          = UVC_QUIRK_PROBE_DEF },
 	/* Apple Built-In iSight */
 	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 				| USB_DEVICE_ID_MATCH_INT_INFO,
diff -uNr linux-3.18.7/drivers/memstick/host/rtsx_usb_ms.c linux-3.18.7-14.15/drivers/memstick/host/rtsx_usb_ms.c
--- linux-3.18.7/drivers/memstick/host/rtsx_usb_ms.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/memstick/host/rtsx_usb_ms.c	2015-02-21 12:47:54.017421041 +0000
@@ -706,7 +706,8 @@
 		if (host->eject)
 			break;
 
-		msleep(1000);
+		if (msleep_interruptible(1000))
+			flush_signals(current);
 	}
 
 	complete(&host->detect_ms_exit);
diff -uNr linux-3.18.7/drivers/mfd/Makefile linux-3.18.7-14.15/drivers/mfd/Makefile
--- linux-3.18.7/drivers/mfd/Makefile	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/mfd/Makefile	2015-02-21 12:47:54.017421041 +0000
@@ -13,7 +13,7 @@
 obj-$(CONFIG_MFD_CROS_EC_I2C)	+= cros_ec_i2c.o
 obj-$(CONFIG_MFD_CROS_EC_SPI)	+= cros_ec_spi.o
 
-rtsx_pci-objs			:= rtsx_pcr.o rts5209.o rts5229.o rtl8411.o rts5227.o rts5249.o
+rtsx_pci-objs			:= rtsx_pcr.o rtsx_gops.o rts5209.o rts5229.o rtl8411.o rts5227.o rts5249.o
 obj-$(CONFIG_MFD_RTSX_PCI)	+= rtsx_pci.o
 obj-$(CONFIG_MFD_RTSX_USB)	+= rtsx_usb.o
 
diff -uNr linux-3.18.7/drivers/mfd/rts5227.c linux-3.18.7-14.15/drivers/mfd/rts5227.c
--- linux-3.18.7/drivers/mfd/rts5227.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/mfd/rts5227.c	2015-02-21 12:47:54.017421041 +0000
@@ -130,6 +130,12 @@
 
 static int rts5227_optimize_phy(struct rtsx_pcr *pcr)
 {
+	int err;
+
+	err = rtsx_gops_pm_reset(pcr);
+	if (err < 0)
+		return err;
+
 	/* Optimize RX sensitivity */
 	return rtsx_pci_write_phy_register(pcr, 0x00, 0xBA42);
 }
diff -uNr linux-3.18.7/drivers/mfd/rts5249.c linux-3.18.7-14.15/drivers/mfd/rts5249.c
--- linux-3.18.7/drivers/mfd/rts5249.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/mfd/rts5249.c	2015-02-21 12:47:54.017421041 +0000
@@ -130,6 +130,10 @@
 {
 	int err;
 
+	err = rtsx_gops_pm_reset(pcr);
+	if (err < 0)
+		return err;
+
 	err = rtsx_pci_write_phy_register(pcr, PHY_REG_REV,
 			PHY_REG_REV_RESV | PHY_REG_REV_RXIDLE_LATCHED |
 			PHY_REG_REV_P1_EN | PHY_REG_REV_RXIDLE_EN |
diff -uNr linux-3.18.7/drivers/mfd/rtsx_gops.c linux-3.18.7-14.15/drivers/mfd/rtsx_gops.c
--- linux-3.18.7/drivers/mfd/rtsx_gops.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/drivers/mfd/rtsx_gops.c	2015-02-21 12:47:54.018421041 +0000
@@ -0,0 +1,37 @@
+/* Driver for Realtek PCI-Express card reader
+ *
+ * Copyright(c) 2009-2013 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Micky Ching <micky_ching@realsil.com.cn>
+ */
+
+#include <linux/mfd/rtsx_pci.h>
+#include "rtsx_pcr.h"
+
+int rtsx_gops_pm_reset(struct rtsx_pcr *pcr)
+{
+	int err;
+
+	/* init aspm */
+	rtsx_pci_write_register(pcr, ASPM_FORCE_CTL, 0xFF, 0x00);
+	err = rtsx_pci_update_cfg_byte(pcr, LCTLR, ~LCTLR_ASPM_CTL_MASK, 0x00);
+	if (err < 0)
+		return err;
+
+	/* reset PM_CTRL3 before send buffer cmd */
+	return rtsx_pci_write_register(pcr, PM_CTRL3, D3_DELINK_MODE_EN, 0x00);
+}
diff -uNr linux-3.18.7/drivers/mfd/rtsx_pcr.h linux-3.18.7-14.15/drivers/mfd/rtsx_pcr.h
--- linux-3.18.7/drivers/mfd/rtsx_pcr.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/mfd/rtsx_pcr.h	2015-02-21 12:47:54.021421040 +0000
@@ -72,4 +72,7 @@
 	pcr->ms_pull_ctl_disable_tbl = __device##_ms_pull_ctl_disable_tbl; \
 } while (0)
 
+/* generic operations */
+int rtsx_gops_pm_reset(struct rtsx_pcr *pcr);
+
 #endif
diff -uNr linux-3.18.7/drivers/misc/mei/pci-me.c linux-3.18.7-14.15/drivers/misc/mei/pci-me.c
--- linux-3.18.7/drivers/misc/mei/pci-me.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/misc/mei/pci-me.c	2015-02-21 12:47:54.037421039 +0000
@@ -41,6 +41,9 @@
 #include "hw-me-regs.h"
 #include "hw-me.h"
 
+static bool disable_msi;
+module_param(disable_msi, bool, 0);
+
 /* mei_pci_tbl - PCI Device ID Table */
 static const struct pci_device_id mei_me_pci_tbl[] = {
 	{MEI_PCI_DEVICE(MEI_DEV_ID_82946GZ, mei_me_legacy_cfg)},
@@ -178,7 +181,8 @@
 		err = -ENOMEM;
 		goto free_device;
 	}
-	pci_enable_msi(pdev);
+	if (!disable_msi)
+		pci_enable_msi(pdev);
 
 	 /* request and enable interrupt */
 	if (pci_dev_msi_enabled(pdev))
diff -uNr linux-3.18.7/drivers/net/ethernet/broadcom/tg3.c linux-3.18.7-14.15/drivers/net/ethernet/broadcom/tg3.c
--- linux-3.18.7/drivers/net/ethernet/broadcom/tg3.c	2015-02-21 12:52:14.854394384 +0000
+++ linux-3.18.7-14.15/drivers/net/ethernet/broadcom/tg3.c	2015-02-21 12:47:54.089421034 +0000
@@ -329,6 +329,7 @@
 	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57785)},
 	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57761)},
 	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57765)},
+	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57786)},
 	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57791),
 	 .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},
 	{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57795),
diff -uNr linux-3.18.7/drivers/net/ethernet/freescale/xgmac_mdio.c linux-3.18.7-14.15/drivers/net/ethernet/freescale/xgmac_mdio.c
--- linux-3.18.7/drivers/net/ethernet/freescale/xgmac_mdio.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/net/ethernet/freescale/xgmac_mdio.c	2015-02-21 12:47:54.100421032 +0000
@@ -32,6 +32,10 @@
 	__be32	mdio_addr;	/* MDIO address */
 } __packed;
 
+/* Taken from memac_mdio.c */
+#define MDIO_STAT_ENC (1 << 6)
+#define MDIO_STAT_HOLD_15_CLK (7 << 2)
+
 #define MDIO_STAT_CLKDIV(x)	(((x>>1) & 0xff) << 8)
 #define MDIO_STAT_BSY		(1 << 0)
 #define MDIO_STAT_RD_ER		(1 << 1)
@@ -91,26 +95,39 @@
 static int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)
 {
 	struct tgec_mdio_controller __iomem *regs = bus->priv;
-	uint16_t dev_addr = regnum >> 16;
+	uint16_t dev_addr;
+	u32 mdio_ctl, mdio_stat;
 	int ret;
 
-	/* Setup the MII Mgmt clock speed */
-	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));
+	mdio_stat = in_be32(&regs->mdio_stat);
+	if (regnum & MII_ADDR_C45) {
+		/* Clause 45 (ie 10G) */
+		dev_addr = (regnum >> 16) & 0x1f;
+		mdio_stat |= MDIO_STAT_ENC | MDIO_STAT_HOLD_15_CLK;
+	} else {
+		/* Clause 22 (ie 1G) */
+		dev_addr = regnum & 0x1f;
+		mdio_stat &= ~MDIO_STAT_ENC;
+	}
+
+	out_be32(&regs->mdio_stat, mdio_stat);
 
 	ret = xgmac_wait_until_free(&bus->dev, regs);
 	if (ret)
 		return ret;
 
 	/* Set the port and dev addr */
-	out_be32(&regs->mdio_ctl,
-		 MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr));
+	mdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);
+	out_be32(&regs->mdio_ctl, mdio_ctl);
 
 	/* Set the register address */
-	out_be32(&regs->mdio_addr, regnum & 0xffff);
+	if (regnum & MII_ADDR_C45) {
+		out_be32(&regs->mdio_addr, regnum & 0xffff);
 
-	ret = xgmac_wait_until_free(&bus->dev, regs);
-	if (ret)
-		return ret;
+		ret = xgmac_wait_until_free(&bus->dev, regs);
+		if (ret)
+			return ret;
+	}
 
 	/* Write the value to the register */
 	out_be32(&regs->mdio_data, MDIO_DATA(value));
@@ -130,13 +147,22 @@
 static int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
 {
 	struct tgec_mdio_controller __iomem *regs = bus->priv;
-	uint16_t dev_addr = regnum >> 16;
+	uint16_t dev_addr;
+	uint32_t mdio_stat;
 	uint32_t mdio_ctl;
 	uint16_t value;
 	int ret;
 
-	/* Setup the MII Mgmt clock speed */
-	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));
+	mdio_stat = in_be32(&regs->mdio_stat);
+	if (regnum & MII_ADDR_C45) {
+		dev_addr = (regnum >> 16) & 0x1f;
+		mdio_stat |= MDIO_STAT_ENC | MDIO_STAT_HOLD_15_CLK;
+	} else {
+		dev_addr = regnum & 0x1f;
+		mdio_stat = ~MDIO_STAT_ENC;
+	}
+
+	out_be32(&regs->mdio_stat, mdio_stat);
 
 	ret = xgmac_wait_until_free(&bus->dev, regs);
 	if (ret)
@@ -147,11 +173,13 @@
 	out_be32(&regs->mdio_ctl, mdio_ctl);
 
 	/* Set the register address */
-	out_be32(&regs->mdio_addr, regnum & 0xffff);
+	if (regnum & MII_ADDR_C45) {
+		out_be32(&regs->mdio_addr, regnum & 0xffff);
 
-	ret = xgmac_wait_until_free(&bus->dev, regs);
-	if (ret)
-		return ret;
+		ret = xgmac_wait_until_free(&bus->dev, regs);
+		if (ret)
+			return ret;
+	}
 
 	/* Initiate the read */
 	out_be32(&regs->mdio_ctl, mdio_ctl | MDIO_CTL_READ);
@@ -162,8 +190,8 @@
 
 	/* Return all Fs if nothing was there */
 	if (in_be32(&regs->mdio_stat) & MDIO_STAT_RD_ER) {
-		dev_err(&bus->dev,
-			"Error while reading PHY%d reg at %d.%hhu\n",
+		dev_dbg(&bus->dev,
+			"Error while reading PHY%d reg at %d.%d\n",
 			phy_id, dev_addr, regnum);
 		return 0xffff;
 	}
@@ -183,7 +211,7 @@
 	mutex_lock(&bus->mdio_lock);
 
 	/* Setup the MII Mgmt clock speed */
-	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));
+	clrbits32(&regs->mdio_stat, MDIO_STAT_ENC);
 
 	ret = xgmac_wait_until_free(&bus->dev, regs);
 
@@ -258,6 +286,9 @@
 	{
 		.compatible = "fsl,fman-xmdio",
 	},
+	{
+		.compatible = "fsl,fman-memac-mdio",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, xgmac_mdio_match);
diff -uNr linux-3.18.7/drivers/net/ethernet/mellanox/mlx4/en_netdev.c linux-3.18.7-14.15/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
--- linux-3.18.7/drivers/net/ethernet/mellanox/mlx4/en_netdev.c	2015-02-21 12:52:14.865394382 +0000
+++ linux-3.18.7-14.15/drivers/net/ethernet/mellanox/mlx4/en_netdev.c	2015-02-21 12:47:54.107421032 +0000
@@ -2456,6 +2456,7 @@
 	netif_set_real_num_rx_queues(dev, prof->rx_ring_num);
 
 	SET_NETDEV_DEV(dev, &mdev->dev->pdev->dev);
+	dev->dev_id =  port - 1;
 	dev->dev_port = port - 1;
 
 	/*
diff -uNr linux-3.18.7/drivers/net/phy/fixed.c linux-3.18.7-14.15/drivers/net/phy/fixed.c
--- linux-3.18.7/drivers/net/phy/fixed.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/net/phy/fixed.c	2015-02-21 12:47:54.120421030 +0000
@@ -5,6 +5,7 @@
  *         Anton Vorontsov <avorontsov@ru.mvista.com>
  *
  * Copyright (c) 2006-2007 MontaVista Software, Inc.
+ * Copyright 2009 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -17,6 +18,7 @@
 #include <linux/platform_device.h>
 #include <linux/list.h>
 #include <linux/mii.h>
+#include <linux/mdio.h>
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
 #include <linux/err.h>
@@ -56,6 +58,9 @@
 		bmcr |= BMCR_FULLDPLX;
 
 		switch (fp->status.speed) {
+		case 10000:
+			fp->regs[MDIO_STAT2] = MDIO_STAT2_DEVPRST_VAL;
+			break;
 		case 1000:
 			bmsr |= BMSR_ESTATEN;
 			bmcr |= BMCR_SPEED1000;
@@ -76,6 +81,9 @@
 		}
 	} else {
 		switch (fp->status.speed) {
+		case 10000:
+			fp->regs[MDIO_STAT2] = MDIO_STAT2_DEVPRST_VAL;
+			break;
 		case 1000:
 			bmsr |= BMSR_ESTATEN;
 			bmcr |= BMCR_SPEED1000;
diff -uNr linux-3.18.7/drivers/net/phy/vitesse.c linux-3.18.7-14.15/drivers/net/phy/vitesse.c
--- linux-3.18.7/drivers/net/phy/vitesse.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/net/phy/vitesse.c	2015-02-21 12:47:54.122421030 +0000
@@ -74,7 +74,7 @@
 MODULE_AUTHOR("Kriston Carson");
 MODULE_LICENSE("GPL");
 
-static int vsc824x_add_skew(struct phy_device *phydev)
+int vsc824x_add_skew(struct phy_device *phydev)
 {
 	int err;
 	int extcon;
@@ -94,6 +94,7 @@
 
 	return err;
 }
+EXPORT_SYMBOL(vsc824x_add_skew);
 
 static int vsc824x_config_init(struct phy_device *phydev)
 {
diff -uNr linux-3.18.7/drivers/net/wireless/hostap/hostap_hw.c linux-3.18.7-14.15/drivers/net/wireless/hostap/hostap_hw.c
--- linux-3.18.7/drivers/net/wireless/hostap/hostap_hw.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/net/wireless/hostap/hostap_hw.c	2015-02-21 12:47:54.134421029 +0000
@@ -69,7 +69,7 @@
 module_param_string(essid, essid, sizeof(essid), 0444);
 MODULE_PARM_DESC(essid, "Host AP's ESSID");
 
-static int iw_mode[MAX_PARM_DEVICES] = { IW_MODE_MASTER, DEF_INTS };
+static int iw_mode[MAX_PARM_DEVICES] = { IW_MODE_INFRA, DEF_INTS };
 module_param_array(iw_mode, int, NULL, 0444);
 MODULE_PARM_DESC(iw_mode, "Initial operation mode");
 
diff -uNr linux-3.18.7/drivers/pci/quirks.c linux-3.18.7-14.15/drivers/pci/quirks.c
--- linux-3.18.7/drivers/pci/quirks.c	2015-02-21 12:52:14.970394372 +0000
+++ linux-3.18.7-14.15/drivers/pci/quirks.c	2015-02-21 12:47:54.182421024 +0000
@@ -41,6 +41,21 @@
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_ANY_ID, PCI_ANY_ID,
 				PCI_CLASS_BRIDGE_HOST, 8, quirk_mmio_always_on);
 
+/* The BAR0 ~ BAR4 of Marvell 9125 device can't be accessed
+*  by IO resource file, and need to skip the files
+*/
+static void quirk_marvell_mask_bar(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 5; i++)
+		if (dev->resource[i].start)
+			dev->resource[i].start =
+				dev->resource[i].end = 0;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL_EXT, 0x9125,
+				quirk_marvell_mask_bar);
+
 /* The Mellanox Tavor device gives false positive parity errors
  * Mark this device with a broken_parity_status, to allow
  * PCI scanning code to "skip" this now blacklisted device.
diff -uNr linux-3.18.7/drivers/pci/rom.c linux-3.18.7-14.15/drivers/pci/rom.c
--- linux-3.18.7/drivers/pci/rom.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/pci/rom.c	2015-02-21 12:47:54.182421024 +0000
@@ -71,6 +71,7 @@
 {
 	void __iomem *image;
 	int last_image;
+	unsigned length;
 
 	image = rom;
 	do {
@@ -93,9 +94,9 @@
 		if (readb(pds + 3) != 'R')
 			break;
 		last_image = readb(pds + 21) & 0x80;
-		/* this length is reliable */
-		image += readw(pds + 16) * 512;
-	} while (!last_image);
+		length = readw(pds + 16);
+		image += length * 512;
+	} while (length && !last_image);
 
 	/* never return a size larger than the PCI resource window */
 	/* there are known ROMs that get the size wrong */
diff -uNr linux-3.18.7/drivers/platform/x86/intel_ips.c linux-3.18.7-14.15/drivers/platform/x86/intel_ips.c
--- linux-3.18.7/drivers/platform/x86/intel_ips.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/platform/x86/intel_ips.c	2015-02-21 12:47:54.187421023 +0000
@@ -1501,6 +1501,14 @@
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP ProBook"),
 		},
 	},
+	{
+		.callback = ips_blacklist_callback,
+		.ident = "G60JX",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G60JX"),
+		},
+	},
 	{ }	/* terminating entry */
 };
 
diff -uNr linux-3.18.7/drivers/pnp/isapnp/core.c linux-3.18.7-14.15/drivers/pnp/isapnp/core.c
--- linux-3.18.7/drivers/pnp/isapnp/core.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/pnp/isapnp/core.c	2015-02-21 12:47:54.187421023 +0000
@@ -41,6 +41,7 @@
 #include <linux/init.h>
 #include <linux/isapnp.h>
 #include <linux/mutex.h>
+#include <linux/async.h>
 #include <asm/io.h>
 
 #include "../base.h"
@@ -990,7 +991,7 @@
 	.disable = isapnp_disable_resources,
 };
 
-static int __init isapnp_init(void)
+static int __init real_isapnp_init(void)
 {
 	int cards;
 	struct pnp_card *card;
@@ -1084,6 +1085,16 @@
 	return 0;
 }
 
+static void __init async_isapnp_init(void *unused, async_cookie_t cookie)
+{
+	(void)real_isapnp_init();
+}
+
+static int __init isapnp_init(void)
+{
+	async_schedule(async_isapnp_init, NULL);
+	return 0;
+}
 device_initcall(isapnp_init);
 
 /* format is: noisapnp */
diff -uNr linux-3.18.7/drivers/rtc/interface.c linux-3.18.7-14.15/drivers/rtc/interface.c
--- linux-3.18.7/drivers/rtc/interface.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/rtc/interface.c	2015-02-21 12:47:54.198421022 +0000
@@ -780,9 +780,23 @@
  */
 static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)
 {
+	struct timerqueue_node *next = timerqueue_getnext(&rtc->timerqueue);
+	struct rtc_time tm;
+	ktime_t now;
+
 	timer->enabled = 1;
+	__rtc_read_time(rtc, &tm);
+	now = rtc_tm_to_ktime(tm);
+
+	/* Skip over expired timers */
+	while (next) {
+		if (next->expires.tv64 >= now.tv64)
+			break;
+		next = timerqueue_iterate_next(next);
+	}
+
 	timerqueue_add(&rtc->timerqueue, &timer->node);
-	if (&timer->node == timerqueue_getnext(&rtc->timerqueue)) {
+	if (!next) {
 		struct rtc_wkalrm alarm;
 		int err;
 		alarm.time = rtc_ktime_to_tm(timer->node.expires);
diff -uNr linux-3.18.7/drivers/scsi/storvsc_drv.c linux-3.18.7-14.15/drivers/scsi/storvsc_drv.c
--- linux-3.18.7/drivers/scsi/storvsc_drv.c	2015-02-21 12:52:15.139394354 +0000
+++ linux-3.18.7-14.15/drivers/scsi/storvsc_drv.c	2015-02-21 12:47:54.235421019 +0000
@@ -1447,6 +1447,19 @@
 	 */
 	sdevice->sdev_bflags |= msft_blist_flags;
 
+	/*
+	 * If the host is WIN8 or WIN8 R2, claim conformance to SPC-3
+	 * if the device is a MSFT virtual device.
+	 */
+	if (!strncmp(sdevice->vendor, "Msft", 4)) {
+		switch (vmbus_proto_version) {
+		case VERSION_WIN8:
+		case VERSION_WIN8_1:
+			sdevice->scsi_level = SCSI_SPC_3;
+			break;
+		}
+	}
+
 	return 0;
 }
 
diff -uNr linux-3.18.7/drivers/tty/vt/vt.c linux-3.18.7-14.15/drivers/tty/vt/vt.c
--- linux-3.18.7/drivers/tty/vt/vt.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/tty/vt/vt.c	2015-02-21 12:47:54.274421015 +0000
@@ -102,6 +102,7 @@
 #include <linux/uaccess.h>
 #include <linux/kdb.h>
 #include <linux/ctype.h>
+#include <linux/screen_info.h>
 
 #define MAX_NR_CON_DRIVER 16
 
@@ -144,7 +145,7 @@
 
 static int con_open(struct tty_struct *, struct file *);
 static void vc_init(struct vc_data *vc, unsigned int rows,
-		    unsigned int cols, int do_clear);
+		    unsigned int cols, int do_clear, int mode);
 static void gotoxy(struct vc_data *vc, int new_x, int new_y);
 static void save_cur(struct vc_data *vc);
 static void reset_terminal(struct vc_data *vc, int do_clear);
@@ -165,6 +166,9 @@
 static int cur_default = CUR_DEFAULT;
 module_param(cur_default, int, S_IRUGO | S_IWUSR);
 
+int vt_handoff = 0;
+module_param_named(handoff, vt_handoff, int, S_IRUGO | S_IWUSR);
+
 /*
  * ignore_poke: don't unblank the screen when things are typed.  This is
  * mainly for the privacy of braille terminal users.
@@ -676,6 +680,13 @@
 		}
 		if (tty0dev)
 			sysfs_notify(&tty0dev->kobj, NULL, "active");
+		/*
+		 * If we are switching away from a transparent VT the contents
+		 * will be lost, convert it into a blank text console then
+		 * it will be repainted blank if we ever switch back.
+		 */
+		if (old_vc->vc_mode == KD_TRANSPARENT)
+			old_vc->vc_mode = KD_TEXT;
 	} else {
 		hide_cursor(vc);
 		redraw = 1;
@@ -789,7 +800,7 @@
 	    if (global_cursor_default == -1)
 		    global_cursor_default = 1;
 
-	    vc_init(vc, vc->vc_rows, vc->vc_cols, 1);
+	    vc_init(vc, vc->vc_rows, vc->vc_cols, 1, KD_TEXT);
 	    vcs_make_sysfs(currcons);
 	    atomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param);
 	}
@@ -2905,7 +2916,7 @@
 module_param_named(underline, default_underline_color, int, S_IRUGO | S_IWUSR);
 
 static void vc_init(struct vc_data *vc, unsigned int rows,
-		    unsigned int cols, int do_clear)
+		    unsigned int cols, int do_clear, int mode)
 {
 	int j, k ;
 
@@ -2916,7 +2927,7 @@
 
 	set_origin(vc);
 	vc->vc_pos = vc->vc_origin;
-	reset_vc(vc);
+	reset_vc(vc, mode);
 	for (j=k=0; j<16; j++) {
 		vc->vc_palette[k++] = default_red[j] ;
 		vc->vc_palette[k++] = default_grn[j] ;
@@ -2973,16 +2984,32 @@
 		mod_timer(&console_timer, jiffies + (blankinterval * HZ));
 	}
 
+	if (vt_handoff > 0 && vt_handoff <= MAX_NR_CONSOLES) {
+		currcons = vt_handoff - 1;
+		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
+		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
+		tty_port_init(&vc->port);
+		visual_init(vc, currcons, 1);
+		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);
+		vc_init(vc, vc->vc_rows, vc->vc_cols, 0, KD_TRANSPARENT);
+	}
 	for (currcons = 0; currcons < MIN_NR_CONSOLES; currcons++) {
+		if (currcons == vt_handoff - 1)
+			continue;
 		vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);
 		INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
 		tty_port_init(&vc->port);
 		visual_init(vc, currcons, 1);
 		vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_NOWAIT);
 		vc_init(vc, vc->vc_rows, vc->vc_cols,
-			currcons || !vc->vc_sw->con_save_screen);
+			currcons || !vc->vc_sw->con_save_screen, KD_TEXT);
 	}
 	currcons = fg_console = 0;
+	if (vt_handoff > 0) {
+		printk(KERN_INFO "vt handoff: transparent VT on vt#%d\n",
+								vt_handoff);
+		currcons = fg_console = vt_handoff - 1;
+	}
 	master_display_fg = vc = vc_cons[currcons].d;
 	set_origin(vc);
 	save_screen(vc);
diff -uNr linux-3.18.7/drivers/tty/vt/vt_ioctl.c linux-3.18.7-14.15/drivers/tty/vt/vt_ioctl.c
--- linux-3.18.7/drivers/tty/vt/vt_ioctl.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/tty/vt/vt_ioctl.c	2015-02-21 12:47:54.277421014 +0000
@@ -1046,9 +1046,9 @@
 	return ret;
 }
 
-void reset_vc(struct vc_data *vc)
+void reset_vc(struct vc_data *vc, int mode)
 {
-	vc->vc_mode = KD_TEXT;
+	vc->vc_mode = mode;
 	vt_reset_unicode(vc->vc_num);
 	vc->vt_mode.mode = VT_AUTO;
 	vc->vt_mode.waitv = 0;
@@ -1080,7 +1080,7 @@
 		 */
 		if (tty)
 			__do_SAK(tty);
-		reset_vc(vc);
+		reset_vc(vc, KD_TEXT);
 	}
 	console_unlock();
 }
@@ -1337,7 +1337,7 @@
 		 * this outside of VT_PROCESS but there is no single process
 		 * to account for and tracking tty count may be undesirable.
 		 */
-			reset_vc(vc);
+			reset_vc(vc, KD_TEXT);
 
 			if (old_vc_mode != vc->vc_mode) {
 				if (vc->vc_mode == KD_TEXT)
@@ -1409,7 +1409,7 @@
 		 * this outside of VT_PROCESS but there is no single process
 		 * to account for and tracking tty count may be undesirable.
 		 */
-		reset_vc(vc);
+		reset_vc(vc, KD_TEXT);
 
 		/*
 		 * Fall through to normal (VT_AUTO) handling of the switch...
diff -uNr linux-3.18.7/drivers/usb/phy/phy-fsl-usb.c linux-3.18.7-14.15/drivers/usb/phy/phy-fsl-usb.c
--- linux-3.18.7/drivers/usb/phy/phy-fsl-usb.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/drivers/usb/phy/phy-fsl-usb.c	2015-02-21 12:47:54.303421012 +0000
@@ -75,7 +75,7 @@
 	.otg_port = 1,
 };
 
-#ifdef CONFIG_PPC32
+#ifdef CONFIG_PPC
 static u32 _fsl_readl_be(const unsigned __iomem *p)
 {
 	return in_be32(p);
@@ -105,7 +105,7 @@
 #else
 #define fsl_readl(addr)		readl(addr)
 #define fsl_writel(val, addr)	writel(val, addr)
-#endif /* CONFIG_PPC32 */
+#endif /* CONFIG_PPC */
 
 /* Routines to access transceiver ULPI registers */
 u8 view_ulpi(u8 addr)
@@ -913,6 +913,7 @@
 	if (pdata->init && pdata->init(pdev) != 0)
 		return -EINVAL;
 
+#ifdef CONFIG_PPC
 	if (pdata->big_endian_mmio) {
 		_fsl_readl = _fsl_readl_be;
 		_fsl_writel = _fsl_writel_be;
@@ -920,6 +921,7 @@
 		_fsl_readl = _fsl_readl_le;
 		_fsl_writel = _fsl_writel_le;
 	}
+#endif
 
 	/* request irq */
 	p_otg->irq = platform_get_irq(pdev, 0);
diff -uNr linux-3.18.7/drivers/usb/storage/unusual_devs.h linux-3.18.7-14.15/drivers/usb/storage/unusual_devs.h
--- linux-3.18.7/drivers/usb/storage/unusual_devs.h	2015-02-21 12:52:15.331394335 +0000
+++ linux-3.18.7-14.15/drivers/usb/storage/unusual_devs.h	2015-02-21 12:47:54.313421011 +0000
@@ -1255,6 +1255,13 @@
 		USB_SC_DEVICE, USB_PR_DEVICE, option_ms_init,
 		0),
 
+/* Reported by Timo Aaltonen <tjaalton@ubuntu.com> */
+UNUSUAL_DEV( 0x0af0, 0x7011, 0x0000, 0x9999,
+		"Option",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, option_ms_init,
+		0 ),
+
 /* Reported by F. Aben <f.aben@option.com>
  * This device (wrongly) has a vendor-specific device descriptor.
  * The entry is needed so usb-storage can bind to it's mass-storage
diff -uNr linux-3.18.7/dropped.txt linux-3.18.7-14.15/dropped.txt
--- linux-3.18.7/dropped.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/dropped.txt	2015-02-21 12:47:54.326421009 +0000
@@ -0,0 +1,11 @@
+UBUNTU: SAUCE: (no-up) dell-wmi: Demote unknown WMI event message to pr_debug
+UBUNTU: SAUCE: (no-up) arm64: dts: Add X-Gene reboot driver dts node
+UBUNTU: SAUCE: (no-up) Add documentation for generic SYSCON reboot driver.
+UBUNTU: SAUCE: fix perf_regs definitions for arm64
+UBUNTU: SAUCE: aufs3 -- (no-up) aufs3-mmap.patch
+Revert "UBUNTU: SAUCE: aufs3 -- (no-up) aufs3-mmap.patch"
+UBUNTU: SAUCE: aufs3 -- (no-up) aufs3-mmap.patch
+UBUNTU: SAUCE: aufs3 -- avoid aufs3-mmap.patch include hell for arm64
+UBUNTU: SAUCE: (no-up) irqchip:gic: change access of gicc_ctrl register to read modify write.
+UBUNTU: SAUCE: (no-up) PCI: Increase BAR size quirk for IBM ipr SAS Crocodile adapters
+
diff -uNr linux-3.18.7/fs/exec.c linux-3.18.7-14.15/fs/exec.c
--- linux-3.18.7/fs/exec.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/exec.c	2015-02-21 12:47:54.428420999 +0000
@@ -57,6 +57,8 @@
 #include <linux/oom.h>
 #include <linux/compat.h>
 
+#include <trace/events/fs.h>
+
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
@@ -771,6 +773,8 @@
 
 	fsnotify_open(file);
 
+	trace_open_exec(name->name);
+
 	err = deny_write_access(file);
 	if (err)
 		goto exit;
diff -uNr linux-3.18.7/fs/ext4/inode.c linux-3.18.7-14.15/fs/ext4/inode.c
--- linux-3.18.7/fs/ext4/inode.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/ext4/inode.c	2015-02-21 12:47:54.429420999 +0000
@@ -3390,6 +3390,10 @@
 	unsigned int credits;
 	int ret = 0;
 
+	/* WORKAROUND: EXTENTS required (LP: #1292234) */
+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))
+		return -EOPNOTSUPP;
+
 	if (!S_ISREG(inode->i_mode))
 		return -EOPNOTSUPP;
 
diff -uNr linux-3.18.7/fs/namei.c linux-3.18.7-14.15/fs/namei.c
--- linux-3.18.7/fs/namei.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/namei.c	2015-02-21 12:47:54.451420997 +0000
@@ -703,8 +703,8 @@
 	path_put(link);
 }
 
-int sysctl_protected_symlinks __read_mostly = 0;
-int sysctl_protected_hardlinks __read_mostly = 0;
+int sysctl_protected_symlinks __read_mostly = 1;
+int sysctl_protected_hardlinks __read_mostly = 1;
 
 /**
  * may_follow_link - Check symlink following for unsafe situations
diff -uNr linux-3.18.7/fs/overlayfs/Kconfig linux-3.18.7-14.15/fs/overlayfs/Kconfig
--- linux-3.18.7/fs/overlayfs/Kconfig	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/overlayfs/Kconfig	2015-02-21 12:47:54.490420993 +0000
@@ -8,3 +8,10 @@
 	  merged with the 'upper' object.
 
 	  For more information see Documentation/filesystems/overlayfs.txt
+
+config OVERLAY_FS_V1
+	bool "Overlayfs filesystem (V1) format support"
+	help
+	  Support the older whiteout format overlayfs filesystems via
+	  the overlay module.  This is needed to support legacy kernels
+	  built using the original overlayfs patch set.
diff -uNr linux-3.18.7/fs/overlayfs/dir.c linux-3.18.7-14.15/fs/overlayfs/dir.c
--- linux-3.18.7/fs/overlayfs/dir.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/overlayfs/dir.c	2015-02-21 12:47:54.494420992 +0000
@@ -48,6 +48,34 @@
 	return temp;
 }
 
+#ifdef CONFIG_OVERLAY_FS_V1
+static const char *ovl_whiteout_symlink = "(overlay-whiteout)";
+int ovl_do_whiteout_v1(struct inode *workdir,
+			      struct dentry *dentry)
+{
+	int err;
+
+	err = vfs_symlink(workdir, dentry, ovl_whiteout_symlink);
+	if (err)
+		return err;
+
+	err = vfs_setxattr(dentry, ovl_whiteout_xattr, "y", 1, 0);
+	if (err)
+		vfs_unlink(workdir, dentry, NULL);
+
+	if (err) {
+		/*
+		 * There's no way to recover from failure to whiteout.
+		 * What should we do?  Log a big fat error and... ?
+		 */
+		pr_err("overlayfs: ERROR - failed to whiteout '%s'\n",
+		       dentry->d_name.name);
+	}
+
+	return err;
+}
+#endif
+
 /* caller holds i_mutex on workdir */
 static struct dentry *ovl_whiteout(struct dentry *workdir,
 				   struct dentry *dentry)
@@ -60,7 +88,7 @@
 	if (IS_ERR(whiteout))
 		return whiteout;
 
-	err = ovl_do_whiteout(wdir, whiteout);
+	err = ovl_do_whiteout(wdir, whiteout, dentry);
 	if (err) {
 		dput(whiteout);
 		whiteout = ERR_PTR(err);
@@ -676,6 +704,51 @@
 	return ovl_do_remove(dentry, true);
 }
 
+/*
+ * ovl_downgrade_whiteout -- build a symlink whiteout and install it
+ * over the existing chardev whiteout.
+ */
+static void ovl_downgrade_whiteout(struct dentry *old_upperdir,
+				   struct dentry *old)
+{
+	struct dentry *workdir = ovl_workdir(old);
+	struct dentry *legacy_whiteout = NULL;
+	struct dentry *whtdentry;
+	int err;
+
+	err = ovl_lock_rename_workdir(workdir, old_upperdir);
+	if (err)
+		goto out;
+
+	whtdentry = lookup_one_len(old->d_name.name, old_upperdir,
+				   old->d_name.len);
+	if (IS_ERR(whtdentry)) {
+		err = PTR_ERR(whtdentry);
+		goto out_unlock_workdir;
+	}
+
+	legacy_whiteout = ovl_whiteout(workdir, old);
+	if (IS_ERR(legacy_whiteout)) {
+		err = PTR_ERR(legacy_whiteout);
+		goto out_dput;
+	}
+
+	err = ovl_do_rename(workdir->d_inode, legacy_whiteout,
+			    old_upperdir->d_inode, whtdentry, 0);
+	if (err)
+		ovl_cleanup(workdir->d_inode, legacy_whiteout);
+
+out_dput:
+	dput(whtdentry);
+	dput(legacy_whiteout);
+out_unlock_workdir:
+	unlock_rename(workdir, old_upperdir);
+out:
+	if (err)
+		pr_err("overlayfs: dowgrade of '%pd2' whiteout failed (%i)\n",
+		       old, err);
+}
+
 static int ovl_rename2(struct inode *olddir, struct dentry *old,
 		       struct inode *newdir, struct dentry *new,
 		       unsigned int flags)
@@ -896,6 +969,9 @@
 	dput(newdentry);
 out_unlock:
 	unlock_rename(new_upperdir, old_upperdir);
+
+	if (!err && ovl_config_legacy(old) && flags & RENAME_WHITEOUT)
+		ovl_downgrade_whiteout(old_upperdir, old);
 out_revert_creds:
 	if (old_opaque || new_opaque) {
 		revert_creds(old_cred);
diff -uNr linux-3.18.7/fs/overlayfs/overlayfs.h linux-3.18.7-14.15/fs/overlayfs/overlayfs.h
--- linux-3.18.7/fs/overlayfs/overlayfs.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/overlayfs/overlayfs.h	2015-02-21 12:47:54.494420992 +0000
@@ -18,6 +18,7 @@
 	OVL_PATH_LOWER,
 };
 
+extern const char *ovl_whiteout_xattr;
 extern const char *ovl_opaque_xattr;
 
 static inline int ovl_do_rmdir(struct inode *dir, struct dentry *dentry)
@@ -117,12 +118,28 @@
 	return err;
 }
 
-static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry)
+#ifdef CONFIG_OVERLAY_FS_V1
+extern int ovl_config_legacy(struct dentry *dentry);
+#else
+#define ovl_config_legacy(x) (0)
+#endif
+
+int ovl_do_whiteout_v1(struct inode *dir, struct dentry *dentry);
+
+static inline int ovl_do_whiteout_v2(struct inode *dir, struct dentry *dentry)
 {
 	int err = vfs_whiteout(dir, dentry);
 	pr_debug("whiteout(%pd2) = %i\n", dentry, err);
 	return err;
 }
+static inline int ovl_do_whiteout(struct inode *dir, struct dentry *dentry,
+				  struct dentry *ovlentry)
+{
+	if (ovl_config_legacy(ovlentry))
+		return ovl_do_whiteout_v1(dir, dentry);
+
+	return ovl_do_whiteout_v2(dir, dentry);
+}
 
 enum ovl_path_type ovl_path_type(struct dentry *dentry);
 u64 ovl_dentry_version_get(struct dentry *dentry);
@@ -141,7 +158,7 @@
 void ovl_drop_write(struct dentry *dentry);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
-bool ovl_is_whiteout(struct dentry *dentry);
+bool ovl_is_whiteout(struct dentry *dentry, struct dentry *ovldentry);
 void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry);
 struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 			  unsigned int flags);
diff -uNr linux-3.18.7/fs/overlayfs/readdir.c linux-3.18.7-14.15/fs/overlayfs/readdir.c
--- linux-3.18.7/fs/overlayfs/readdir.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/overlayfs/readdir.c	2015-02-21 12:47:54.495420992 +0000
@@ -232,12 +232,14 @@
 }
 
 static int ovl_dir_mark_whiteouts(struct dentry *dir,
-				  struct ovl_readdir_data *rdd)
+				  struct ovl_readdir_data *rdd,
+				  struct dentry *ovldir)
 {
 	struct ovl_cache_entry *p;
 	struct dentry *dentry;
 	const struct cred *old_cred;
 	struct cred *override_cred;
+	int legacy = ovl_config_legacy(ovldir);
 
 	override_cred = prepare_creds();
 	if (!override_cred) {
@@ -256,14 +258,14 @@
 		if (p->is_cursor)
 			continue;
 
-		if (p->type != DT_CHR)
+		if (p->type != DT_CHR && (!legacy || p->type != DT_LNK))
 			continue;
 
 		dentry = lookup_one_len(p->name, dir, p->len);
 		if (IS_ERR(dentry))
 			continue;
 
-		p->is_whiteout = ovl_is_whiteout(dentry);
+		p->is_whiteout = ovl_is_whiteout(dentry, ovldir);
 		dput(dentry);
 	}
 	mutex_unlock(&dir->d_inode->i_mutex);
@@ -295,7 +297,7 @@
 			goto out;
 
 		if (lowerpath.dentry) {
-			err = ovl_dir_mark_whiteouts(upperpath.dentry, &rdd);
+			err = ovl_dir_mark_whiteouts(upperpath.dentry, &rdd, dentry);
 			if (err)
 				goto out;
 		}
diff -uNr linux-3.18.7/fs/overlayfs/super.c linux-3.18.7-14.15/fs/overlayfs/super.c
--- linux-3.18.7/fs/overlayfs/super.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/overlayfs/super.c	2015-02-21 12:47:54.495420992 +0000
@@ -38,6 +38,7 @@
 	struct vfsmount *lower_mnt;
 	struct dentry *workdir;
 	long lower_namelen;
+	int legacy;
 	/* pathnames of lower and upper dirs, for show_options */
 	struct ovl_config config;
 };
@@ -233,13 +234,56 @@
 	return oe->version;
 }
 
-bool ovl_is_whiteout(struct dentry *dentry)
+#ifdef CONFIG_OVERLAY_FS_V1
+int ovl_config_legacy(struct dentry *dentry)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct ovl_fs *ufs = sb->s_fs_info;
+
+	return ufs->legacy;
+}
+
+const char *ovl_whiteout_xattr = "trusted.overlay.whiteout";
+
+bool ovl_is_whiteout_v1(struct dentry *dentry)
+{
+	int res;
+	char val;
+
+	if (!dentry)
+		return false;
+	if (!dentry->d_inode)
+		return false;
+	if (!S_ISLNK(dentry->d_inode->i_mode))
+		return false;
+	if (!dentry->d_inode->i_op->getxattr)
+		return false;
+
+	res = dentry->d_inode->i_op->getxattr(dentry, ovl_whiteout_xattr, &val, 1);
+	if (res == 1 && val == 'y')
+		return true;
+
+	return false;
+}
+#else
+#define ovl_is_whiteout_v1(x) (0)
+#endif
+
+bool ovl_is_whiteout_v2(struct dentry *dentry)
 {
 	struct inode *inode = dentry->d_inode;
 
 	return inode && IS_WHITEOUT(inode);
 }
 
+bool ovl_is_whiteout(struct dentry *dentry, struct dentry *ovlentry)
+{
+	if (ovl_config_legacy(ovlentry))
+		return ovl_is_whiteout_v2(dentry) || ovl_is_whiteout_v1(dentry);
+
+	return ovl_is_whiteout_v2(dentry);
+}
+
 static bool ovl_is_opaquedir(struct dentry *dentry)
 {
 	int res;
@@ -321,7 +365,7 @@
 			goto out_put_dir;
 
 		if (lowerdir && upperdentry) {
-			if (ovl_is_whiteout(upperdentry)) {
+			if (ovl_is_whiteout(upperdentry, dentry)) {
 				dput(upperdentry);
 				upperdentry = NULL;
 				oe->opaque = true;
@@ -816,17 +860,63 @@
 	.name		= "overlay",
 	.mount		= ovl_mount,
 	.kill_sb	= kill_anon_super,
+	.fs_flags	= FS_USERNS_MOUNT,
 };
 MODULE_ALIAS_FS("overlay");
 
+#ifdef CONFIG_OVERLAY_FS_V1
+static int ovl_v1_fill_super(struct super_block *sb, void *data, int silent)
+{
+	int ret;
+	struct ovl_fs *ufs;
+
+	ret = ovl_fill_super(sb, data, silent);
+	if (ret)
+		return ret;
+
+	/* Mark this as a overlayfs format. */
+	ufs = sb->s_fs_info;
+	ufs->legacy = 1;
+
+	return ret;
+}
+
+static struct dentry *ovl_mount_v1(struct file_system_type *fs_type, int flags,
+				const char *dev_name, void *raw_data)
+{
+	return mount_nodev(fs_type, flags, raw_data, ovl_v1_fill_super);
+}
+
+static struct file_system_type ovl_v1_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "overlayfs",
+	.mount		= ovl_mount_v1,
+	.kill_sb	= kill_anon_super,
+	.fs_flags	= FS_USERNS_MOUNT,  /* XXX */
+};
+MODULE_ALIAS_FS("overlayfs");
+MODULE_ALIAS("overlayfs");
+#endif
+
 static int __init ovl_init(void)
 {
+	int ret;
+
+	if (IS_ENABLED(CONFIG_OVERLAY_FS_V1)) {
+		ret = register_filesystem(&ovl_v1_fs_type);
+		if (ret)
+			return ret;
+	}
+
 	return register_filesystem(&ovl_fs_type);
 }
 
 static void __exit ovl_exit(void)
 {
 	unregister_filesystem(&ovl_fs_type);
+
+	if (IS_ENABLED(CONFIG_OVERLAY_FS_V1))
+		unregister_filesystem(&ovl_v1_fs_type);
 }
 
 module_init(ovl_init);
diff -uNr linux-3.18.7/fs/proc/Makefile linux-3.18.7-14.15/fs/proc/Makefile
--- linux-3.18.7/fs/proc/Makefile	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/fs/proc/Makefile	2015-02-21 12:47:54.495420992 +0000
@@ -30,3 +30,4 @@
 proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
 proc-$(CONFIG_PRINTK)	+= kmsg.o
 proc-$(CONFIG_PROC_PAGE_MONITOR)	+= page.o
+proc-y	+= version_signature.o
diff -uNr linux-3.18.7/fs/proc/version_signature.c linux-3.18.7-14.15/fs/proc/version_signature.c
--- linux-3.18.7/fs/proc/version_signature.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/fs/proc/version_signature.c	2015-02-21 12:47:54.501420991 +0000
@@ -0,0 +1,31 @@
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/utsname.h>
+
+static int version_signature_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s\n", CONFIG_VERSION_SIGNATURE);
+	return 0;
+}
+
+static int version_signature_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, version_signature_proc_show, NULL);
+}
+
+static const struct file_operations version_signature_proc_fops = {
+	.open		= version_signature_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_version_signature_init(void)
+{
+	proc_create("version_signature", 0, NULL, &version_signature_proc_fops);
+	return 0;
+}
+module_init(proc_version_signature_init);
diff -uNr linux-3.18.7/include/linux/mfd/rtsx_pci.h linux-3.18.7-14.15/include/linux/mfd/rtsx_pci.h
--- linux-3.18.7/include/linux/mfd/rtsx_pci.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/include/linux/mfd/rtsx_pci.h	2015-02-21 12:47:54.540420987 +0000
@@ -707,6 +707,14 @@
 #define PM_CTRL1			0xFF44
 #define PM_CTRL2			0xFF45
 #define PM_CTRL3			0xFF46
+#define   SDIO_SEND_PME_EN		0x80
+#define   FORCE_RC_MODE_ON		0x40
+#define   FORCE_RX50_LINK_ON		0x20
+#define   D3_DELINK_MODE_EN		0x10
+#define   USE_PESRTB_CTL_DELINK		0x08
+#define   DELAY_PIN_WAKE		0x04
+#define   RESET_PIN_WAKE		0x02
+#define   PM_WAKE_EN			0x01
 #define PM_CTRL4			0xFF47
 
 /* Memory mapping */
@@ -752,6 +760,14 @@
 #define PHY_DUM_REG			0x1F
 
 #define LCTLR				0x80
+#define   LCTLR_EXT_SYNC		0x80
+#define   LCTLR_COMMON_CLOCK_CFG	0x40
+#define   LCTLR_RETRAIN_LINK		0x20
+#define   LCTLR_LINK_DISABLE		0x10
+#define   LCTLR_RCB			0x08
+#define   LCTLR_RESERVED		0x04
+#define   LCTLR_ASPM_CTL_MASK		0x03
+
 #define PCR_SETTING_REG1		0x724
 #define PCR_SETTING_REG2		0x814
 #define PCR_SETTING_REG3		0x747
@@ -967,4 +983,16 @@
 	return (u8 *)(pcr->host_cmds_ptr);
 }
 
+static inline int rtsx_pci_update_cfg_byte(struct rtsx_pcr *pcr, int addr,
+		u8 mask, u8 append)
+{
+	int err;
+	u8 val;
+
+	err = pci_read_config_byte(pcr->pci, addr, &val);
+	if (err < 0)
+		return err;
+	return pci_write_config_byte(pcr->pci, addr, (val & mask) | append);
+}
+
 #endif
diff -uNr linux-3.18.7/include/linux/vt_kern.h linux-3.18.7-14.15/include/linux/vt_kern.h
--- linux-3.18.7/include/linux/vt_kern.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/include/linux/vt_kern.h	2015-02-21 12:47:54.567420985 +0000
@@ -130,7 +130,8 @@
 void vt_event_post(unsigned int event, unsigned int old, unsigned int new);
 int vt_waitactive(int n);
 void change_console(struct vc_data *new_vc);
-void reset_vc(struct vc_data *vc);
+void reset_vc(struct vc_data *vc, int mode);
+
 extern int do_unbind_con_driver(const struct consw *csw, int first, int last,
 			     int deflt);
 int vty_init(const struct file_operations *console_fops);
diff -uNr linux-3.18.7/include/uapi/linux/kd.h linux-3.18.7-14.15/include/uapi/linux/kd.h
--- linux-3.18.7/include/uapi/linux/kd.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/include/uapi/linux/kd.h	2015-02-21 12:47:54.572420984 +0000
@@ -45,6 +45,8 @@
 #define		KD_GRAPHICS	0x01
 #define		KD_TEXT0	0x02	/* obsolete */
 #define		KD_TEXT1	0x03	/* obsolete */
+#define		KD_TRANSPARENT	0x04
+
 #define KDGETMODE	0x4B3B	/* get current mode */
 
 #define KDMAPDISP	0x4B3C	/* map display into address space */
diff -uNr linux-3.18.7/init/Kconfig linux-3.18.7-14.15/init/Kconfig
--- linux-3.18.7/init/Kconfig	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/init/Kconfig	2015-02-21 12:47:54.577420984 +0000
@@ -208,6 +208,15 @@
 	  but you may wish to use a different default here to make a minimal
 	  system more usable with less configuration.
 
+config VERSION_SIGNATURE
+	string "Arbitrary version signature"
+	help
+	  This string will be created in a file, /proc/version_signature. It
+	  is useful in determining arbitrary data about your kernel. For instance,
+	  if you have several kernels of the same version, but need to keep track
+	  of a revision of the same kernel, but not affect it's ability to load
+	  compatible modules, this is the easiest way to do that.
+
 config SWAP
 	bool "Support for paging of anonymous memory (swap)"
 	depends on MMU && BLOCK
diff -uNr linux-3.18.7/init/noinitramfs.c linux-3.18.7-14.15/init/noinitramfs.c
--- linux-3.18.7/init/noinitramfs.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/init/noinitramfs.c	2015-02-21 12:47:54.578420984 +0000
@@ -22,6 +22,8 @@
 #include <linux/kdev_t.h>
 #include <linux/syscalls.h>
 
+LIST_HEAD(populate_rootfs_domain);
+
 /*
  * Create a simple rootfs that is similar to the default initramfs
  */
diff -uNr linux-3.18.7/init/version.c linux-3.18.7-14.15/init/version.c
--- linux-3.18.7/init/version.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/init/version.c	2015-02-21 12:47:54.581420983 +0000
@@ -42,7 +42,11 @@
 /* FIXED STRINGS! Don't touch! */
 const char linux_banner[] =
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
-	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION
+#ifdef CONFIG_VERSION_SIGNATURE
+        " (" CONFIG_VERSION_SIGNATURE ")"
+#endif
+	"\n";
 
 const char linux_proc_banner[] =
 	"%s version %s"
diff -uNr linux-3.18.7/ipc/sem.c linux-3.18.7-14.15/ipc/sem.c
--- linux-3.18.7/ipc/sem.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/ipc/sem.c	2015-02-21 12:47:54.581420983 +0000
@@ -1967,6 +1967,14 @@
 	error = get_queue_result(&queue);
 
 	/*
+	 * wake_up_sem_queue_do operates on queue without locking, so we
+	 * need a barrier here to order our read of queue.status and the
+	 * subsequent reuse of queue (queue is on the stack so will be
+	 * most likely reused in the next function call).
+	 */
+	smp_mb();
+
+	/*
 	 * Array removed? If yes, leave without sem_unlock().
 	 */
 	if (IS_ERR(sma)) {
diff -uNr linux-3.18.7/kernel/irq/Kconfig linux-3.18.7-14.15/kernel/irq/Kconfig
--- linux-3.18.7/kernel/irq/Kconfig	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/kernel/irq/Kconfig	2015-02-21 12:47:54.596420982 +0000
@@ -72,6 +72,10 @@
 config IRQ_FORCED_THREADING
        bool
 
+config IRQ_FORCED_THREADING_DEFAULT
+	bool "Use IRQ threading by default"
+	depends on IRQ_FORCED_THREADING
+
 config SPARSE_IRQ
 	bool "Support sparse irq numbering" if MAY_HAVE_SPARSE_IRQ
 	---help---
diff -uNr linux-3.18.7/kernel/irq/manage.c linux-3.18.7-14.15/kernel/irq/manage.c
--- linux-3.18.7/kernel/irq/manage.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/kernel/irq/manage.c	2015-02-21 12:47:54.597420982 +0000
@@ -22,14 +22,20 @@
 #include "internals.h"
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
-__read_mostly bool force_irqthreads;
+__read_mostly bool force_irqthreads = IS_ENABLED(CONFIG_IRQ_FORCED_THREADING_DEFAULT);
 
 static int __init setup_forced_irqthreads(char *arg)
 {
 	force_irqthreads = true;
 	return 0;
 }
+static int __init setup_no_irqthreads(char *arg)
+{
+	force_irqthreads = false;
+	return 0;
+}
 early_param("threadirqs", setup_forced_irqthreads);
+early_param("nothreadirqs", setup_no_irqthreads);
 #endif
 
 static void __synchronize_hardirq(struct irq_desc *desc)
diff -uNr linux-3.18.7/kernel/kthread.c linux-3.18.7-14.15/kernel/kthread.c
--- linux-3.18.7/kernel/kthread.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/kernel/kthread.c	2015-02-21 12:47:54.598420981 +0000
@@ -292,6 +292,17 @@
 	 * new kernel thread.
 	 */
 	if (unlikely(wait_for_completion_killable(&done))) {
+		int i = 0;
+
+		/*
+		 * I got SIGKILL, but wait for 10 more seconds for completion
+		 * unless chosen by the OOM killer. This delay is there as a
+		 * workaround for boot failure caused by SIGKILL upon device
+		 * driver initialization timeout.
+		 */
+		while (i++ < 10 && !test_tsk_thread_flag(current, TIF_MEMDIE))
+			if (wait_for_completion_timeout(&done, HZ))
+				goto ready;
 		/*
 		 * If I was SIGKILLed before kthreadd (or new kernel thread)
 		 * calls complete(), leave the cleanup of this structure to
@@ -305,6 +316,7 @@
 		 */
 		wait_for_completion(&done);
 	}
+ready:
 	task = create->result;
 	if (!IS_ERR(task)) {
 		static const struct sched_param param = { .sched_priority = 0 };
diff -uNr linux-3.18.7/net/rds/ib_send.c linux-3.18.7-14.15/net/rds/ib_send.c
--- linux-3.18.7/net/rds/ib_send.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/net/rds/ib_send.c	2015-02-21 12:47:54.679420973 +0000
@@ -544,7 +544,7 @@
 	int flow_controlled = 0;
 	int nr_sig = 0;
 
-	BUG_ON(off % RDS_FRAG_SIZE);
+	BUG_ON(!conn->c_loopback && off % RDS_FRAG_SIZE);
 	BUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));
 
 	/* Do not send cong updates to IB loopback */
diff -uNr linux-3.18.7/scripts/kconfig/lkc.h linux-3.18.7-14.15/scripts/kconfig/lkc.h
--- linux-3.18.7/scripts/kconfig/lkc.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/scripts/kconfig/lkc.h	2015-02-21 12:47:54.693420972 +0000
@@ -98,7 +98,9 @@
 /* confdata.c and expr.c */
 static inline void xfwrite(const void *str, size_t len, size_t count, FILE *out)
 {
-	assert(len != 0);
+	//assert(len != 0);
+	if (len == 0)
+		return;
 
 	if (fwrite(str, len, count, out) != count)
 		fprintf(stderr, "Error in writing or end of file.\n");
diff -uNr linux-3.18.7/tools/hv/hv_kvp_daemon.8 linux-3.18.7-14.15/tools/hv/hv_kvp_daemon.8
--- linux-3.18.7/tools/hv/hv_kvp_daemon.8	1970-01-01 00:00:00.000000000 +0000
+++ linux-3.18.7-14.15/tools/hv/hv_kvp_daemon.8	2015-02-21 12:47:54.784420962 +0000
@@ -0,0 +1,26 @@
+.\"  This page Copyright (C) 2012 Andy Whitcroft <apw@canonical.com>
+.\"  Distributed under the GPL v2 or later.
+.TH HV_KVP_DAEMON 8
+.SH NAME
+hv_kvp_daemon \- Hyper-V Key Value Pair daemon
+.SH SYNOPSIS
+.ft B
+.B hv_kvp_daemon
+.br
+.SH DESCRIPTION
+\fBhv_kvp_daemon\fP
+is the userspace component of the Hyper-V key value pair functionality,
+communicating via a netlink socket with the kernel HV-KVP driver.
+This pairing allows the Hyper-V host to pass configuration information
+(such as IP addresses) to the guest and allows the host to obtain guest
+version information.
+
+.SH FILES
+.ta
+.nf
+/var/opt/hyperv/.kvp_pool_*
+.fi
+
+.SH AUTHORS
+.nf
+Written by K. Y. Srinivasan <ksrinivasan@novell.com>
diff -uNr linux-3.18.7/tools/hv/hv_vss_daemon.c linux-3.18.7-14.15/tools/hv/hv_vss_daemon.c
--- linux-3.18.7/tools/hv/hv_vss_daemon.c	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/tools/hv/hv_vss_daemon.c	2015-02-21 12:47:54.784420962 +0000
@@ -144,8 +144,10 @@
 	char *vss_recv_buffer;
 	size_t vss_recv_buffer_len;
 
+#if 0   /* It's much easier to manage from upstart if we don't fork */
 	if (daemon(1, 0))
 		return 1;
+#endif
 
 	openlog("Hyper-V VSS", 0, LOG_USER);
 	syslog(LOG_INFO, "VSS starting; pid is:%d", getpid());
diff -uNr linux-3.18.7/tools/usb/usbip/libsrc/usbip_common.h linux-3.18.7-14.15/tools/usb/usbip/libsrc/usbip_common.h
--- linux-3.18.7/tools/usb/usbip/libsrc/usbip_common.h	2014-12-07 22:21:05.000000000 +0000
+++ linux-3.18.7-14.15/tools/usb/usbip/libsrc/usbip_common.h	2015-02-21 12:47:54.787420962 +0000
@@ -15,7 +15,7 @@
 #include <syslog.h>
 #include <unistd.h>
 #include <linux/usb/ch9.h>
-#include <linux/usbip.h>
+#include "../../../../include/uapi/linux/usbip.h"
 
 #ifndef USBIDS_FILE
 #define USBIDS_FILE "/usr/share/hwdata/usb.ids"
