
Updates / cleanups from:

git://github.com/hadess/rtl8723bs.git

Topmost commit:

commit 8d329c00dba5d8805a738ecea2bddde8eb0e4945
Author: Bastien Nocera <hadess@hadess.net>
Date:   Tue May 5 18:30:38 2015 +0200

    ioctl_linux: Fix compiling with Wake-On-LAN support



Signed-off-by: Thomas backlund <tmb@mageia.org>

diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_ap.c linux/3rdparty/rtl8723bs/core/rtw_ap.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_ap.c	2015-05-10 14:36:05.663667846 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_ap.c	2015-05-07 17:46:55.000000000 +0300
@@ -21,9 +21,6 @@
 
 #include <drv_types.h>
 
-
-#ifdef CONFIG_AP_MODE
-
 extern unsigned char	RTW_WPA_OUI[];
 extern unsigned char 	WMM_OUI[];
 extern unsigned char	WPS_OUI[];
@@ -32,7 +29,6 @@ extern unsigned char	WFD_OUI[];
 
 void init_mlme_ap_info(_adapter *padapter)
 {
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;	
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
@@ -71,9 +67,9 @@ void free_mlme_ap_info(_adapter *padapte
 
 	//free bc/mc sta_info
 	psta = rtw_get_bcmc_stainfo(padapter);	
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 }
 
 static void update_BCNTIM(_adapter *padapter)
@@ -191,7 +187,7 @@ static void update_BCNTIM(_adapter *pada
 		{
 			memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
 
-			rtw_mfree(pbackup_remainder_ie, remainder_ielen);
+			kfree(pbackup_remainder_ie);
 		}	
 
 		offset =  (uint)(dst_ie - pie);
@@ -200,122 +196,6 @@ static void update_BCNTIM(_adapter *pada
 	}
 }
 
-void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len)
-{
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8	bmatch = false;
-	u8	*pie = pnetwork->IEs;
-	u8	*p=NULL, *dst_ie=NULL, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
-	u32	i, offset, ielen, ie_offset, remainder_ielen = 0;
-
-	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pnetwork->IELength;)
-	{
-		pIE = (PNDIS_802_11_VARIABLE_IEs)(pnetwork->IEs + i);
-
-		if (pIE->ElementID > index)
-		{
-			break;
-		}
-		else if(pIE->ElementID == index) // already exist the same IE
-		{
-			p = (u8 *)pIE;
-			ielen = pIE->Length;
-			bmatch = true;
-			break;
-		}
-
-		p = (u8 *)pIE;
-		ielen = pIE->Length;
-		i += (pIE->Length + 2);
-	}
-
-	if (p != NULL && ielen>0)
-	{
-		ielen += 2;
-		
-		premainder_ie = p+ielen;
-
-		ie_offset = (sint)(p -pie);
-		
-		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
-
-		if(bmatch)
-			dst_ie = p;
-		else
-			dst_ie = (p+ielen);
-	}
-
-	if(dst_ie == NULL)
-		return;
-
-	if(remainder_ielen>0)
-	{
-		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
-		if(pbackup_remainder_ie && premainder_ie)
-			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
-	}
-
-	*dst_ie++=index;
-	*dst_ie++=len;
-
-	memcpy(dst_ie, data, len);
-	dst_ie+=len;
-
-	//copy remainder IE
-	if(pbackup_remainder_ie)
-	{
-		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
-
-		rtw_mfree(pbackup_remainder_ie, remainder_ielen);
-	}
-
-	offset =  (uint)(dst_ie - pie);
-	pnetwork->IELength = offset + remainder_ielen;
-}
-
-void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index)
-{
-	u8 *p, *dst_ie=NULL, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
-	uint offset, ielen, ie_offset, remainder_ielen = 0;
-	u8	*pie = pnetwork->IEs;
-
-	p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, index, &ielen, pnetwork->IELength - _FIXED_IE_LENGTH_);
-	if (p != NULL && ielen>0)
-	{
-		ielen += 2;
-		
-		premainder_ie = p+ielen;
-
-		ie_offset = (sint)(p -pie);
-		
-		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
-
-		dst_ie = p;
-	}
-	else {
-		return;
-	}
-
-	if(remainder_ielen>0)
-	{
-		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
-		if(pbackup_remainder_ie && premainder_ie)
-			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
-	}
-
-	//copy remainder IE
-	if(pbackup_remainder_ie)
-	{
-		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
-
-		rtw_mfree(pbackup_remainder_ie, remainder_ielen);
-	}
-
-	offset =  (uint)(dst_ie - pie);
-	pnetwork->IELength = offset + remainder_ielen;
-}
-
-
 u8 chk_sta_is_alive(struct sta_info *psta);
 u8 chk_sta_is_alive(struct sta_info *psta)
 {
@@ -349,19 +229,19 @@ void	expire_timeout_chk(_adapter *padapt
 	int i;
 
 
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->auth_list_lock);
 	
 	phead = &pstapriv->auth_list;
 	plist = get_next(phead);
 	
 	//check auth_queue
 	#ifdef DBG_EXPIRATION_CHK
-	if (rtw_end_of_queue_search(phead, plist) == false) {
+	if (phead != plist) {
 		DBG_871X(FUNC_NDEV_FMT" auth_list, cnt:%u\n"
 			, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->auth_list_cnt);
 	}
 	#endif
-	while ((rtw_end_of_queue_search(phead, plist)) == false)	
+	while (phead != plist)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, auth_list);
 
@@ -372,41 +252,41 @@ void	expire_timeout_chk(_adapter *padapt
 			psta->expire_to--;
 			if (psta->expire_to == 0)
 			{
-				rtw_list_delete(&psta->auth_list);
+				list_del_init(&psta->auth_list);
 				pstapriv->auth_list_cnt--;
 				
 				DBG_871X("auth expire %02X%02X%02X%02X%02X%02X\n",
 					psta->hwaddr[0],psta->hwaddr[1],psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]);
 				
-				_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+				spin_unlock_bh(&pstapriv->auth_list_lock);
 				
-				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				spin_lock_bh(&(pstapriv->sta_hash_lock));
 				rtw_free_stainfo(padapter, psta);
-				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				spin_unlock_bh(&(pstapriv->sta_hash_lock));
 				
-				_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+				spin_lock_bh(&pstapriv->auth_list_lock);
 			}	
 		}	
 		
 	}
 
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 	psta = NULL;
 	
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
 	//check asoc_queue
 	#ifdef DBG_EXPIRATION_CHK
-	if (rtw_end_of_queue_search(phead, plist) == false) {
+	if (phead != plist) {
 		DBG_871X(FUNC_NDEV_FMT" asoc_list, cnt:%u\n"
 			, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->asoc_list_cnt);
 	}
 	#endif
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
@@ -417,14 +297,13 @@ void	expire_timeout_chk(_adapter *padapt
 		if (chk_sta_is_alive(psta) || !psta->expire_to) {
 			psta->expire_to = pstapriv->expire_to;
 			psta->keep_alive_trycnt = 0;
-			#ifdef CONFIG_TX_MCAST2UNI
 			psta->under_exist_checking = 0;
-			#endif	// CONFIG_TX_MCAST2UNI
 		} else {
-			psta->expire_to--;
+			if (psta->expire_to > 0)
+				psta->expire_to--;
 		}
 
-		if (psta->expire_to <= 0)
+		if (psta->expire_to == 0)
 		{
 			struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
@@ -460,7 +339,7 @@ void	expire_timeout_chk(_adapter *padapt
 
 				continue;
 			}
-			rtw_list_delete(&psta->asoc_list);
+			list_del_init(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			DBG_871X("asoc expire "MAC_FMT", state=0x%x\n", MAC_ARG(psta->hwaddr), psta->state);
 			updated = ap_free_sta(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);
@@ -479,7 +358,7 @@ void	expire_timeout_chk(_adapter *padapt
 		}
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 if (chk_alive_num) {
 
@@ -521,13 +400,13 @@ if (chk_alive_num) {
 
 		psta->keep_alive_trycnt = 0;
 		DBG_871X("asoc expire "MAC_FMT", state=0x%x\n", MAC_ARG(psta->hwaddr), psta->state);
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if (rtw_is_list_empty(&psta->asoc_list)==false) {
-			rtw_list_delete(&psta->asoc_list);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if (list_empty(&psta->asoc_list)==false) {
+			list_del_init(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			updated = ap_free_sta(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);
 		}
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	}
 
@@ -544,13 +423,10 @@ void add_RATid(_adapter *padapter, struc
 	u8 rf_type;
 	unsigned char sta_band = 0, shortGIrate = false;
 	unsigned int tx_ra_bitmap=0;
-	struct ht_priv	*psta_ht = NULL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
 
-	if(psta)
-		psta_ht = &psta->htpriv;
-	else
+	if(!psta)
 		return;
 
 	if(!(psta->state & _FW_LINKED))
@@ -672,9 +548,9 @@ void update_bmc_sta(_adapter *padapter)
 
 		rtw_sta_media_status_rpt(padapter, psta, 1);
 
-		_enter_critical_bh(&psta->lock, &irqL);
+		spin_lock_bh(&psta->lock);
 		psta->state = _FW_LINKED;
-		_exit_critical_bh(&psta->lock, &irqL);
+		spin_unlock_bh(&psta->lock);
 
 	}
 	else
@@ -815,9 +691,9 @@ void update_sta_info_apmode(_adapter *pa
 	//add_RATid(padapter, psta);//move to ap_sta_info_defer_update()
 
 
-	_enter_critical_bh(&psta->lock, &irqL);
+	spin_lock_bh(&psta->lock);
 	psta->state |= _FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL);
+	spin_unlock_bh(&psta->lock);
 	
 
 }
@@ -826,7 +702,6 @@ static void update_ap_info(_adapter *pad
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
-	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
 
@@ -875,7 +750,6 @@ static void update_hw_ht_param(_adapter
 {
 	unsigned char		max_AMPDU_len;
 	unsigned char		min_MPDU_spacing;
-	struct registry_priv	 *pregpriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	
@@ -933,8 +807,7 @@ void start_bss_network(_adapter *padapte
 	WLAN_BSSID_EX *pnetwork_mlmeext = &(pmlmeinfo->network);
 	struct HT_info_element *pht_info=NULL;
 	u8	cbw40_enable=0;
-	u8	change_band = false;
-	
+
 	//DBG_871X("%s\n", __FUNCTION__);
 
 	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;	
@@ -1114,15 +987,12 @@ int rtw_check_beacon_data(_adapter *pada
 	u8	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
 	int supportRateNum = 0;
 	u8 OUI1[] = {0x00, 0x50, 0xf2,0x01};
-	u8 wps_oui[4]={0x0,0x50,0xf2,0x04};
 	u8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};	
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
-	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *ie = pbss_network->IEs;
-	u8 vht_cap=false;
 
 	/* SSID */
 	/* Supported rates */
@@ -1483,12 +1353,12 @@ int rtw_acl_add_sta(_adapter *padapter,
 		return (-1);	
 
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 		
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
@@ -1504,14 +1374,14 @@ int rtw_acl_add_sta(_adapter *padapter,
 		}		
 	}
 	
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 
 	if(added == true)
 		return ret;
 	
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	for(i=0; i< NUM_ACL; i++)
 	{
@@ -1519,13 +1389,13 @@ int rtw_acl_add_sta(_adapter *padapter,
 
 		if(paclnode->valid == false)
 		{
-			_rtw_init_listhead(&paclnode->list);
+			INIT_LIST_HEAD(&paclnode->list);
 	
 			memcpy(paclnode->addr, addr, ETH_ALEN);
 		
 			paclnode->valid = true;
 
-			rtw_list_insert_tail(&paclnode->list, get_list_head(pacl_node_q));
+			list_add_tail(&paclnode->list, get_list_head(pacl_node_q));
 	
 			pacl_list->num++;
 
@@ -1535,7 +1405,7 @@ int rtw_acl_add_sta(_adapter *padapter,
 
 	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
 	
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 	return ret;
 }
@@ -1553,12 +1423,12 @@ int rtw_acl_remove_sta(_adapter *padapte
 
 	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));	
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 		
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
@@ -1569,14 +1439,14 @@ int rtw_acl_remove_sta(_adapter *padapte
 			{
 				paclnode->valid = false;
 
-				rtw_list_delete(&paclnode->list);
+				list_del_init(&paclnode->list);
 				
 				pacl_list->num--;
 			}
 		}		
 	}
 	
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
 	
@@ -1599,7 +1469,7 @@ u8 rtw_ap_set_pairwise_key(_adapter *pad
 
 	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
 	if(psetstakey_para==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		kfree((u8 *) ph2c);
 		res=_FAIL;
 		goto exit;
 	}
@@ -1639,7 +1509,7 @@ static int rtw_ap_set_key(_adapter *pada
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
 	if(psetkeyparm==NULL){
-		rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
+		kfree((unsigned char *)pcmd);
 		res= _FAIL;
 		goto exit;
 	}
@@ -1678,7 +1548,7 @@ static int rtw_ap_set_key(_adapter *pada
 	pcmd->rspsz = 0;
 
 
-	_rtw_init_listhead(&pcmd->list);
+	INIT_LIST_HEAD(&pcmd->list);
 
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 
@@ -1715,8 +1585,6 @@ int rtw_ap_set_wep_key(_adapter *padapte
 	return rtw_ap_set_key(padapter, key, alg, keyid, set_tx);
 }
 
-#ifdef CONFIG_NATIVEAP_MLME
-
 static void update_bcn_fixed_ie(_adapter *padapter)
 {
 	DBG_871X("%s\n", __FUNCTION__);
@@ -1838,7 +1706,7 @@ static void update_bcn_wps_ie(_adapter *
 	}
 
 	if(pbackup_remainder_ie)
-		rtw_mfree(pbackup_remainder_ie, remainder_ielen);
+		kfree(pbackup_remainder_ie);
 	
 	// deal with the case without set_tx_beacon_cmd() in update_beacon() 
 #if defined( CONFIG_INTERRUPT_BASED_TXBCN )
@@ -1907,7 +1775,7 @@ void update_beacon(_adapter *padapter, u
 	if(false == pmlmeext->bstart_bss)
 		return;
 
-	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
 
 	switch(ie_id)
 	{
@@ -1959,7 +1827,7 @@ void update_beacon(_adapter *padapter, u
 
 	pmlmepriv->update_bcn = true;
 	
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);		
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
 	
 #ifndef CONFIG_INTERRUPT_BASED_TXBCN 
 	if(tx)
@@ -2064,13 +1932,13 @@ void associated_clients_update(_adapter
 		struct sta_info *psta=NULL;	
 		struct sta_priv *pstapriv = &padapter->stapriv;
 			
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
 		
 		phead = &pstapriv->asoc_list;
 		plist = get_next(phead);
 		
 		//check asoc_queue
-		while ((rtw_end_of_queue_search(phead, plist)) == false)	
+		while (phead != plist)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		
@@ -2079,7 +1947,7 @@ void associated_clients_update(_adapter
 			VCS_update(padapter, psta);		
 		}
 
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	}		
 
@@ -2332,8 +2200,6 @@ u8 ap_free_sta(_adapter *padapter, struc
 {
 	_irqL irqL;
 	u8 beacon_updated = false;
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	if(!psta)
@@ -2360,9 +2226,9 @@ u8 ap_free_sta(_adapter *padapter, struc
 	rtw_clearstakey_cmd(padapter, psta, true);
 
 
-	_enter_critical_bh(&psta->lock, &irqL);
+	spin_lock_bh(&psta->lock);
 	psta->state &= ~_FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL);
+	spin_unlock_bh(&psta->lock);
 
 	rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);
 
@@ -2370,52 +2236,15 @@ u8 ap_free_sta(_adapter *padapter, struc
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
 
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);					
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 	
 
 	return beacon_updated;
 
 }
 
-int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset)
-{
-	_irqL irqL;
-	_list	*phead, *plist;
-	int ret=0;	
-	struct sta_info *psta = NULL;	
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
-
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
-		return ret;
-
-	DBG_871X(FUNC_NDEV_FMT" with ch:%u, offset:%u\n",
-		FUNC_NDEV_ARG(padapter->pnetdev), new_ch, ch_offset);
-
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-	phead = &pstapriv->asoc_list;
-	plist = get_next(phead);
-	
-	/* for each sta in asoc_queue */
-	while ((rtw_end_of_queue_search(phead, plist)) == false)	
-	{		
-		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
-		plist = get_next(plist);
-
-		issue_action_spct_ch_switch(padapter, psta->hwaddr, new_ch, ch_offset);
-		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 : (pstapriv->expire_to * 2);
-	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
-	issue_action_spct_ch_switch(padapter, bc_addr, new_ch, ch_offset);
-
-	return ret;
-}
-
 int rtw_sta_flush(_adapter *padapter)
 {
 	_irqL irqL;
@@ -2433,25 +2262,25 @@ int rtw_sta_flush(_adapter *padapter)
 		return ret;
 
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
 	//free sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		
 		plist = get_next(plist);
 
-		rtw_list_delete(&psta->asoc_list);
+		list_del_init(&psta->asoc_list);
 		pstapriv->asoc_list_cnt--;
 
-		//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		//spin_unlock_bh(&pstapriv->asoc_list_lock);
 		ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-		//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		//spin_lock_bh(&pstapriv->asoc_list_lock);
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 
 	issue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);
@@ -2516,7 +2345,6 @@ void rtw_ap_restore_network(_adapter *pa
 {
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct sta_priv * pstapriv = &padapter->stapriv;
 	struct sta_info *psta;
 	struct security_priv* psecuritypriv=&(padapter->securitypriv);
@@ -2539,12 +2367,12 @@ void rtw_ap_restore_network(_adapter *pa
 		rtw_set_key(padapter, psecuritypriv, psecuritypriv->dot118021XGrpKeyid, 0,false);
 	}
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+	while (phead != plist) {
 		int stainfo_offset;
 
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
@@ -2556,7 +2384,7 @@ void rtw_ap_restore_network(_adapter *pa
 		}
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	for (i = 0; i < chk_alive_num; i++) {
 		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
@@ -2619,12 +2447,12 @@ void start_ap_mode(_adapter *padapter)
 
 	
 	//for ACL 
-	_rtw_init_listhead(&(pacl_list->acl_node_q.queue));
+	INIT_LIST_HEAD(&(pacl_list->acl_node_q.queue));
 	pacl_list->num = 0;
 	pacl_list->mode = 0;
 	for(i = 0; i < NUM_ACL; i++)
 	{		
-		_rtw_init_listhead(&pacl_list->aclnode[i].list);
+		INIT_LIST_HEAD(&pacl_list->aclnode[i].list);
 		pacl_list->aclnode[i].valid = false;
 	}
 
@@ -2651,10 +2479,10 @@ void stop_ap_mode(_adapter *padapter)
 	padapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
 
 	//for ACL
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);		
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
@@ -2663,12 +2491,12 @@ void stop_ap_mode(_adapter *padapter)
 		{
 			paclnode->valid = false;
 
-			rtw_list_delete(&paclnode->list);
+			list_del_init(&paclnode->list);
 				
 			pacl_list->num--;		
 		}		
 	}	
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 	
 	DBG_871X("%s, free acl_node_queue, num=%d\n", __func__, pacl_list->num);
 	
@@ -2678,9 +2506,9 @@ void stop_ap_mode(_adapter *padapter)
 	rtw_free_all_stainfo(padapter);
 	
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 	
 	rtw_init_bcmc_stainfo(padapter);	
 
@@ -2688,8 +2516,3 @@ void stop_ap_mode(_adapter *padapter)
 
 	rtw_btcoex_MediaStatusNotify(padapter, 0); //disconnect 
 }
-
-#endif //CONFIG_NATIVEAP_MLME
-
-#endif //CONFIG_AP_MODE
-
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_btcoex.c linux/3rdparty/rtl8723bs/core/rtw_btcoex.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_btcoex.c	2015-05-10 14:36:05.663667846 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_btcoex.c	2015-05-07 17:46:55.000000000 +0300
@@ -108,16 +108,6 @@ void rtw_btcoex_HaltNotify(PADAPTER pada
 	hal_btcoex_HaltNotify(padapter);
 }
 
-void rtw_btcoex_SwitchBtTRxMask(PADAPTER padapter)
-{
-	hal_btcoex_SwitchBtTRxMask(padapter);	
-}
-
-void rtw_btcoex_Switch(PADAPTER padapter, u8 enable)
-{
-	hal_btcoex_SetBTCoexist(padapter, enable);
-}
-
 u8 rtw_btcoex_IsBtDisabled(PADAPTER padapter)
 {
 	return hal_btcoex_IsBtDisabled(padapter);
@@ -137,15 +127,6 @@ s32 rtw_btcoex_IsBTCoexCtrlAMPDUSize(PAD
 	return coexctrl;
 }
 
-u32 rtw_btcoex_GetAMPDUSize(PADAPTER padapter)
-{
-	u32 size;
-
-	size = hal_btcoex_GetAMPDUSize(padapter);
-
-	return size;
-}
-
 void rtw_btcoex_SetManualControl(PADAPTER padapter, u8 manual)
 {
 	if (true == manual)
@@ -158,11 +139,6 @@ void rtw_btcoex_SetManualControl(PADAPTE
 	}
 }
 
-u8 rtw_btcoex_1Ant(PADAPTER padapter)
-{
-	return hal_btcoex_1Ant(padapter);
-}
-
 u8 rtw_btcoex_IsBtControlLps(PADAPTER padapter)
 {
 	return hal_btcoex_IsBtControlLps(padapter);
@@ -198,11 +174,6 @@ void rtw_btcoex_SetPGAntNum(PADAPTER pad
 	hal_btcoex_SetPgAntNum(padapter, antNum);
 }
 
-u8 rtw_btcoex_GetPGAntNum(PADAPTER padapter)
-{
-	return hal_btcoex_GetPgAntNum(padapter);
-}
-
 void rtw_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath)
 {
 	hal_btcoex_SetSingleAntPath(padapter, singleAntPath);
@@ -233,16 +204,6 @@ u32 rtw_btcoex_GetDBG(PADAPTER padapter,
 	return hal_btcoex_GetDBG(padapter, pStrBuf, bufSize);
 }
 
-u8 rtw_btcoex_IncreaseScanDeviceNum(PADAPTER padapter)
-{
-	return hal_btcoex_IncreaseScanDeviceNum(padapter);
-}
-
-u8 rtw_btcoex_IsBtLinkExist(PADAPTER padapter)
-{
-	return hal_btcoex_IsBtLinkExist(padapter);
-}
-
 // ==================================================
 // Below Functions are called by BT-Coex
 // ==================================================
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_cmd.c linux/3rdparty/rtl8723bs/core/rtw_cmd.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_cmd.c	2015-05-10 14:36:05.665667868 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_cmd.c	2015-05-07 17:46:55.000000000 +0300
@@ -255,10 +255,10 @@ _func_enter_;
 		void *c2h;
 		if ((c2h = rtw_cbuf_pop(pevtpriv->c2h_queue)) != NULL
 			&& c2h != (void *)pevtpriv) {
-			rtw_mfree(c2h, 16);
+			kfree(c2h);
 		}
 	}
-	rtw_cbuf_free(pevtpriv->c2h_queue);
+	kfree(pevtpriv->c2h_queue);
 
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-_rtw_free_evt_priv \n"));
 
@@ -272,10 +272,10 @@ _func_enter_;
 
 	if(pcmdpriv){
 		if (pcmdpriv->cmd_allocated_buf)
-			rtw_mfree(pcmdpriv->cmd_allocated_buf, MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+			kfree(pcmdpriv->cmd_allocated_buf);
 		
 		if (pcmdpriv->rsp_allocated_buf)
-			rtw_mfree(pcmdpriv->rsp_allocated_buf, MAX_RSPSZ + 4);
+			kfree(pcmdpriv->rsp_allocated_buf);
 
 		mutex_destroy(&pcmdpriv->sctx_mutex);
 	}
@@ -301,13 +301,13 @@ _func_enter_;
 	if (obj == NULL)
 		goto exit;
 
-	//_enter_critical_bh(&queue->lock, &irqL);
-	_enter_critical(&queue->lock, &irqL);	
+	//spin_lock_bh(&queue->lock);
+	spin_lock_irqsave(&queue->lock, irqL);
 
-	rtw_list_insert_tail(&obj->list, &queue->queue);
+	list_add_tail(&obj->list, &queue->queue);
 
-	//_exit_critical_bh(&queue->lock, &irqL);	
-	_exit_critical(&queue->lock, &irqL);
+	//spin_unlock_bh(&queue->lock);
+	spin_unlock_irqrestore(&queue->lock, irqL);
 
 exit:	
 
@@ -323,18 +323,18 @@ struct	cmd_obj	*_rtw_dequeue_cmd(_queue
 
 _func_enter_;
 
-	//_enter_critical_bh(&(queue->lock), &irqL);
-	_enter_critical(&queue->lock, &irqL);
-	if (rtw_is_list_empty(&(queue->queue)))
+	//spin_lock_bh(&(queue->lock));
+	spin_lock_irqsave(&queue->lock, irqL);
+	if (list_empty(&(queue->queue)))
 		obj = NULL;
 	else
 	{
 		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
-		rtw_list_delete(&obj->list);
+		list_del_init(&obj->list);
 	}
 
-	//_exit_critical_bh(&(queue->lock), &irqL);
-	_exit_critical(&queue->lock, &irqL);
+	//spin_unlock_bh(&(queue->lock));
+	spin_unlock_irqrestore(&queue->lock, irqL);
 
 _func_exit_;	
 
@@ -442,14 +442,6 @@ _func_exit_;
 	return cmd_obj;
 }
 
-void rtw_cmd_clr_isr(struct	cmd_priv *pcmdpriv)
-{
-_func_enter_;
-	pcmdpriv->cmd_done_cnt++;
-	//up(&(pcmdpriv->cmd_done_sema));
-_func_exit_;		
-}
-
 void rtw_free_cmd_obj(struct cmd_obj *pcmd)
 {
 _func_enter_;
@@ -457,7 +449,7 @@ _func_enter_;
 	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
 	{
 		//free parmbuf in cmd_obj
-		rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
+		kfree((unsigned char*)pcmd->parmbuf);
 	}	
 	
 	if(pcmd->rsp!=NULL)
@@ -465,12 +457,12 @@ _func_enter_;
 		if(pcmd->rspsz!= 0)
 		{
 			//free rsp in cmd_obj
-			rtw_mfree((unsigned char*)pcmd->rsp, pcmd->rspsz);
+			kfree((unsigned char*)pcmd->rsp);
 		}	
 	}	
 
 	//free cmd_obj
-	rtw_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
+	kfree((unsigned char*)pcmd);
 	
 _func_exit_;		
 }
@@ -533,7 +525,7 @@ _func_enter_;
 			break;
 		}
 		
-		if(rtw_is_list_empty(&(pcmdpriv->cmd_queue.queue)))
+		if(list_empty(&(pcmdpriv->cmd_queue.queue)))
 		{
 			//DBG_871X("%s: cmd queue is empty!\n", __func__);
 			continue;
@@ -573,7 +565,7 @@ _next:
 
 		memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
 
-		if(pcmd->cmdcode < (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
+		if(pcmd->cmdcode < ARRAY_SIZE(wlancmds))
 		{
 			cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
 
@@ -594,18 +586,18 @@ _next:
 
 post_process:
 
-		_enter_critical_mutex(&(pcmd->padapter->cmdpriv.sctx_mutex), NULL);
-		if (pcmd->sctx) {
-			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pcmd->sctx\n",
-				FUNC_ADPT_ARG(pcmd->padapter));
-
-			if (pcmd->res == H2C_SUCCESS)
-				rtw_sctx_done(&pcmd->sctx);
-			else
-				rtw_sctx_done_err(&pcmd->sctx, RTW_SCTX_DONE_CMD_ERROR);
+		if (mutex_lock_interruptible(&(pcmd->padapter->cmdpriv.sctx_mutex)) == 0) {
+			if (pcmd->sctx) {
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pcmd->sctx\n",
+					       FUNC_ADPT_ARG(pcmd->padapter));
+
+				if (pcmd->res == H2C_SUCCESS)
+					rtw_sctx_done(&pcmd->sctx);
+				else
+					rtw_sctx_done_err(&pcmd->sctx, RTW_SCTX_DONE_CMD_ERROR);
+			}
+			mutex_unlock(&(pcmd->padapter->cmdpriv.sctx_mutex));
 		}
-		_exit_critical_mutex(&(pcmd->padapter->cmdpriv.sctx_mutex), NULL);
-
 
 		if((cmd_process_time = jiffies_to_msecs(jiffies - cmd_start_time)) > 1000)
 		{
@@ -627,7 +619,7 @@ post_process:
 		}
 
 		//call callback function for post-processed
-		if(pcmd->cmdcode < (sizeof(rtw_cmd_callback) /sizeof(struct _cmd_callback)))
+		if(pcmd->cmdcode < ARRAY_SIZE(rtw_cmd_callback))
 		{
 			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
 			if(pcmd_callback == NULL)
@@ -666,7 +658,7 @@ post_process:
 		if (pcmd->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {
 			extra_parm = (struct drvextra_cmd_parm *)pcmd->parmbuf;
 			if(extra_parm->pbuf && extra_parm->size > 0) {
-				rtw_mfree(extra_parm->pbuf, extra_parm->size);
+				kfree(extra_parm->pbuf);
 			}
 		}
 
@@ -682,42 +674,6 @@ _func_exit_;
 
 }
 
-u8 rtw_setstandby_cmd(_adapter *padapter, uint action)
-{
-	struct cmd_obj*			ph2c;
-	struct usb_suspend_parm*	psetusbsuspend;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-
-	u8 ret = _SUCCESS;
-	
-_func_enter_;	
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if (ph2c == NULL) {
-		ret = _FAIL;
-		goto exit;
-	}
-	
-	psetusbsuspend = (struct usb_suspend_parm*)rtw_zmalloc(sizeof(struct usb_suspend_parm)); 
-	if (psetusbsuspend == NULL) {
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		ret = _FAIL;
-		goto exit;
-	}
-
-	psetusbsuspend->action = action;
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SetUsbSuspend));
-
-	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-	
-exit:	
-	
-_func_exit_;		
-
-	return ret;
-}
-
 /*
 rtw_sitesurvey_cmd(~)
 	### NOTE:#### (!!!!)
@@ -744,7 +700,7 @@ _func_enter_;
 
 	psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm)); 
 	if (psurveyPara == NULL) {
-		rtw_mfree((unsigned char*) ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char*) ph2c);
 		return _FAIL;
 	}
 
@@ -793,8 +749,6 @@ _func_enter_;
 
 		pmlmepriv->scan_start_time = jiffies;
 		_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
-
-		rtw_led_control(padapter, LED_CTL_SITE_SURVEY);
 	} else {
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
@@ -821,7 +775,7 @@ _func_enter_;
 
 	pbsetdataratepara = (struct setdatarate_parm*)rtw_zmalloc(sizeof(struct setdatarate_parm)); 
 	if (pbsetdataratepara == NULL) {
-		rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		kfree((u8 *) ph2c);
 		res = _FAIL;
 		goto exit;
 	}
@@ -838,243 +792,17 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_setbasicrate_cmd(_adapter *padapter, u8 *rateset)
-{
-	struct cmd_obj*			ph2c;
-	struct setbasicrate_parm*	pssetbasicratepara;
-	struct cmd_priv*		pcmdpriv=&padapter->cmdpriv;
-	u8	res = _SUCCESS;
-
-_func_enter_;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if (ph2c == NULL) {
-		res= _FAIL;
-		goto exit;
-	}
-	pssetbasicratepara = (struct setbasicrate_parm*)rtw_zmalloc(sizeof(struct setbasicrate_parm)); 
-
-	if (pssetbasicratepara == NULL) {
-		rtw_mfree((u8*) ph2c, sizeof(struct cmd_obj));
-		res = _FAIL;
-		goto exit;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SetBasicRate_CMD_);
-
-	memcpy(pssetbasicratepara->basicrates, rateset, NumRates);	   
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:	
-
-_func_exit_;		
-
-	return res;
-}
-
-
-/*
-unsigned char rtw_setphy_cmd(unsigned char  *adapter) 
-
-1.  be called only after rtw_update_registrypriv_dev_network( ~) or mp testing program
-2.  for AdHoc/Ap mode or mp mode?
-
-*/
-u8 rtw_setphy_cmd(_adapter *padapter, u8 modem, u8 ch)
-{
-	struct cmd_obj*			ph2c;
-	struct setphy_parm*		psetphypara;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-//	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
-//	struct registry_priv*		pregistry_priv = &padapter->registrypriv;
-	u8	res=_SUCCESS;
-
-_func_enter_;	
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-		}
-	psetphypara = (struct setphy_parm*)rtw_zmalloc(sizeof(struct setphy_parm)); 
-
-	if(psetphypara==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SetPhy_CMD_);
-
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("CH=%d, modem=%d", ch, modem));
-
-	psetphypara->modem = modem;
-	psetphypara->rfchannel = ch;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:	
-_func_exit_;		
-	return res;
-}
-
-u8 rtw_setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
-{	
-	struct cmd_obj*			ph2c;
-	struct writeBB_parm*		pwritebbparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
-	u8	res=_SUCCESS;
-_func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-		}
-	pwritebbparm = (struct writeBB_parm*)rtw_zmalloc(sizeof(struct writeBB_parm)); 
-
-	if(pwritebbparm==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SetBBReg));	
-
-	pwritebbparm->offset = offset;
-	pwritebbparm->value = val;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:	
-_func_exit_;	
-	return res;
-}
-
-u8 rtw_getbbreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
-{	
-	struct cmd_obj*			ph2c;
-	struct readBB_parm*		prdbbparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
-	
-_func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res=_FAIL;
-		goto exit;
-		}
-	prdbbparm = (struct readBB_parm*)rtw_zmalloc(sizeof(struct readBB_parm)); 
-
-	if(prdbbparm ==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
-		return _FAIL;
-	}
-
-	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetBBReg);
-	ph2c->parmbuf = (unsigned char *)prdbbparm;
-	ph2c->cmdsz =  sizeof(struct readBB_parm);
-	ph2c->rsp = pval;
-	ph2c->rspsz = sizeof(struct readBB_rsp);
-	
-	prdbbparm ->offset = offset;
-	
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:
-_func_exit_;	
-	return res;
-}
-
-u8 rtw_setrfreg_cmd(_adapter  *padapter, u8 offset, u32 val)
-{	
-	struct cmd_obj*			ph2c;
-	struct writeRF_parm*		pwriterfparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
-	u8	res=_SUCCESS;
-_func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;	
-		goto exit;
-	}
-	pwriterfparm = (struct writeRF_parm*)rtw_zmalloc(sizeof(struct writeRF_parm)); 
-
-	if(pwriterfparm==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));	
-
-	pwriterfparm->offset = offset;
-	pwriterfparm->value = val;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:
-_func_exit_;	
-	return res;
-}
-
-u8 rtw_getrfreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
-{	
-	struct cmd_obj*			ph2c;
-	struct readRF_parm*		prdrfparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
-	u8	res=_SUCCESS;
-
-_func_enter_;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-	}
-
-	prdrfparm = (struct readRF_parm*)rtw_zmalloc(sizeof(struct readRF_parm)); 
-	if(prdrfparm ==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetRFReg);
-	ph2c->parmbuf = (unsigned char *)prdrfparm;
-	ph2c->cmdsz =  sizeof(struct readRF_parm);
-	ph2c->rsp = pval;
-	ph2c->rspsz = sizeof(struct readRF_rsp);
-	
-	prdrfparm ->offset = offset;
-	
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-
-exit:
-
-_func_exit_;	
-
-	return res;
-}
-
 void rtw_getbbrfreg_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {       
  _func_enter_;  
 		
 	//rtw_free_cmd_obj(pcmd);
-	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
-	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+	kfree((unsigned char*) pcmd->parmbuf);
+	kfree((unsigned char*) pcmd);
 	
 _func_exit_;		
 }
 
-void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
-{
- _func_enter_;  
-
-	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
-	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
-	
-_func_exit_;
-}
-
 u8 rtw_createbss_cmd(_adapter  *padapter)
 {
 	struct cmd_obj*			pcmd;
@@ -1085,8 +813,6 @@ u8 rtw_createbss_cmd(_adapter  *padapter
 
 _func_enter_;
 
-	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
-
 	if (pmlmepriv->assoc_ssid.SsidLength == 0){
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));		
 	} else {
@@ -1099,7 +825,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	_rtw_init_listhead(&pcmd->list);
+	INIT_LIST_HEAD(&pcmd->list);
 	pcmd->cmdcode = _CreateBss_CMD_;
 	pcmd->parmbuf = (unsigned char *)pdev_network;
 	pcmd->cmdsz = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX*)pdev_network);
@@ -1117,36 +843,6 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz)
-{
-	struct cmd_obj*	pcmd;
-	struct cmd_priv 	*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
-	
-_func_enter_;
-			
-	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(pcmd==NULL){
-		res= _FAIL;
-		goto exit;
-	}
-
-	_rtw_init_listhead(&pcmd->list);
-	pcmd->cmdcode = GEN_CMD_CODE(_CreateBss);
-	pcmd->parmbuf = pbss;
-	pcmd->cmdsz =  sz;
-	pcmd->rsp = NULL;
-	pcmd->rspsz = 0;
-
-	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
-
-exit:
-	
-_func_exit_;	
-
-	return res;	
-}
-
 u8 rtw_startbss_cmd(_adapter  *padapter, int flags)
 {
 	struct cmd_obj* pcmd;
@@ -1167,7 +863,7 @@ _func_enter_;
 			goto exit;
 		}
 
-		_rtw_init_listhead(&pcmd->list);
+		INIT_LIST_HEAD(&pcmd->list);
 		pcmd->cmdcode = GEN_CMD_CODE(_CreateBss);
 		pcmd->parmbuf = NULL;
 		pcmd->cmdsz =  0;
@@ -1183,10 +879,11 @@ _func_enter_;
 
 		if (res == _SUCCESS && (flags & RTW_CMDF_WAIT_ACK)) {
 			rtw_sctx_wait(&sctx, __func__);
-			_enter_critical_mutex(&pcmdpriv->sctx_mutex, NULL);
-			if (sctx.status == RTW_SCTX_SUBMITTED)
-				pcmd->sctx = NULL;
-			_exit_critical_mutex(&pcmdpriv->sctx_mutex, NULL);
+			if (mutex_lock_interruptible(&pcmdpriv->sctx_mutex) == 0) {
+				if (sctx.status == RTW_SCTX_SUBMITTED)
+					pcmd->sctx = NULL;
+				mutex_unlock(&pcmdpriv->sctx_mutex);
+			}
 		}
 	}
 
@@ -1216,8 +913,6 @@ u8 rtw_joinbss_cmd(_adapter  *padapter,
 	u8 *ptmp=NULL;
 _func_enter_;
 
-	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
-
 	if (pmlmepriv->assoc_ssid.SsidLength == 0){
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
 	} else {
@@ -1267,7 +962,7 @@ _func_enter_;
 	if(psecnetwork==NULL)
 	{
 		if(pcmd !=NULL)
-			rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+			kfree((unsigned char *)pcmd);
 		
 		res=_FAIL;
 		
@@ -1348,7 +1043,7 @@ _func_enter_;
 
 	pcmd->cmdsz = get_WLAN_BSSID_EX_sz(psecnetwork);//get cmdsz before endian conversion
 
-	_rtw_init_listhead(&pcmd->list);
+	INIT_LIST_HEAD(&pcmd->list);
 	pcmd->cmdcode = _JoinBss_CMD_;//GEN_CMD_CODE(_JoinBss)
 	pcmd->parmbuf = (unsigned char *)psecnetwork;
 	pcmd->rsp = NULL;
@@ -1387,7 +1082,7 @@ _func_enter_;
 		cmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(*cmdobj));
 		if (cmdobj == NULL) {
 			res = _FAIL;
-			rtw_mfree((u8 *)param, sizeof(*param));
+			kfree((u8 *)param);
 			goto exit;
 		}
 		init_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DisConnect_CMD_);
@@ -1396,7 +1091,7 @@ _func_enter_;
 		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
 		if (H2C_SUCCESS != disconnect_hdl(padapter, (u8 *)param))
 			res = _FAIL;
-		rtw_mfree((u8 *)param, sizeof(*param));
+		kfree((u8 *)param);
 	}
 
 exit:
@@ -1426,7 +1121,7 @@ _func_enter_;
 	if(enqueue){
 		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));			
 		if(ph2c==NULL){		
-			rtw_mfree((u8 *)psetop, sizeof(*psetop));
+			kfree((u8 *)psetop);
 			res= _FAIL;
 			goto exit;
 		}	
@@ -1436,7 +1131,7 @@ _func_enter_;
 	}
 	else{
 		setopmode_hdl(padapter, (u8 *)psetop);
-		rtw_mfree((u8 *)psetop, sizeof(*psetop));
+		kfree((u8 *)psetop);
 	}
 exit:
 
@@ -1486,15 +1181,15 @@ _func_enter_;
 	{
 		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 		if ( ph2c == NULL){
-			rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+			kfree((u8 *) psetstakey_para);
 			res= _FAIL;
 			goto exit;
 		}	
 
 		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp)); 
 		if(psetstakey_rsp == NULL){
-			rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
-			rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+			kfree((u8 *) ph2c);
+			kfree((u8 *) psetstakey_para);
 			res=_FAIL;
 			goto exit;
 		}
@@ -1506,7 +1201,7 @@ _func_enter_;
 	}
 	else{
 		set_stakey_hdl(padapter, (u8 *)psetstakey_para);
-		rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+		kfree((u8 *) psetstakey_para);
 	}
 exit:
 
@@ -1546,15 +1241,15 @@ _func_enter_;
 
 		psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
 		if(psetstakey_para==NULL){
-			rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+			kfree((u8 *) ph2c);
 			res=_FAIL;
 			goto exit;
 		}
 
 		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp)); 
 		if(psetstakey_rsp == NULL){
-			rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-			rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
+			kfree((u8 *) ph2c);
+			kfree((u8 *) psetstakey_para);
 			res=_FAIL;
 			goto exit;
 		}
@@ -1578,123 +1273,6 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table)
-{
-	struct cmd_obj*			ph2c;
-	struct setratable_parm *	psetrttblparm;	
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
-_func_enter_;	
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-		}
-	psetrttblparm = (struct setratable_parm*)rtw_zmalloc(sizeof(struct setratable_parm)); 
-
-	if(psetrttblparm==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
-
-	memcpy(psetrttblparm,prate_table,sizeof(struct setratable_parm));
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:
-_func_exit_;	
-	return res;
-
-}
-
-u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval)
-{
-	struct cmd_obj*			ph2c;
-	struct getratable_parm *	pgetrttblparm;	
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
-_func_enter_;	
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-	}
-	pgetrttblparm = (struct getratable_parm*)rtw_zmalloc(sizeof(struct getratable_parm)); 
-
-	if(pgetrttblparm==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-//	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
-
-	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetRaTable);
-	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
-	ph2c->cmdsz =  sizeof(struct getratable_parm);
-	ph2c->rsp = (u8*)pval;
-	ph2c->rspsz = sizeof(struct getratable_rsp);
-	
-	pgetrttblparm ->rsvd = 0x0;
-	
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-exit:
-_func_exit_;	
-	return res;
-
-}
-
-u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr)
-{
-	struct cmd_priv 		*pcmdpriv = &padapter->cmdpriv;
-	struct cmd_obj*			ph2c;
-	struct set_assocsta_parm	*psetassocsta_para;	
-	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
-
-	u8	res=_SUCCESS;
-
-_func_enter_;	
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
-		goto exit;
-	}
-
-	psetassocsta_para = (struct set_assocsta_parm*)rtw_zmalloc(sizeof(struct set_assocsta_parm));
-	if(psetassocsta_para==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res=_FAIL;
-		goto exit;
-	}
-
-	psetassocsta_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_assocsta_rsp)); 
-	if(psetassocsta_rsp==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		rtw_mfree((u8 *) psetassocsta_para, sizeof(struct set_assocsta_parm));
-		return _FAIL;
-	}
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
-	ph2c->rsp = (u8 *) psetassocsta_rsp;
-	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
-
-	memcpy(psetassocsta_para->addr, mac_addr,ETH_ALEN);
-	
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
-
-exit:
-
-_func_exit_;	
-
-	return res;
- }
-
 u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr)
 {
 	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
@@ -1713,7 +1291,7 @@ _func_enter_;
 	
 	paddbareq_parm = (struct addBaReq_parm*)rtw_zmalloc(sizeof(struct addBaReq_parm)); 
 	if(paddbareq_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -1752,7 +1330,7 @@ _func_enter_;
 	
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -1793,7 +1371,7 @@ _func_enter_;
 	
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -1835,7 +1413,7 @@ _func_enter_;
 	
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -1858,61 +1436,6 @@ _func_exit_;
 
 }
 
-u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
-{
-	struct cmd_obj *pcmdobj;
-	struct set_ch_parm *set_ch_parm;
-	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-
-	u8 res=_SUCCESS;
-
-_func_enter_;
-
-	DBG_871X(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
-		FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
-
-	/* check input parameter */
-
-	/* prepare cmd parameter */
-	set_ch_parm = (struct set_ch_parm *)rtw_zmalloc(sizeof(*set_ch_parm));
-	if (set_ch_parm == NULL) {
-		res= _FAIL;
-		goto exit;
-	}
-	set_ch_parm->ch = ch;
-	set_ch_parm->bw = bw;
-	set_ch_parm->ch_offset = ch_offset;
-
-	if (enqueue) {
-		/* need enqueue, prepare cmd_obj and enqueue */
-		pcmdobj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-		if(pcmdobj == NULL){
-			rtw_mfree((u8 *)set_ch_parm, sizeof(*set_ch_parm));
-			res=_FAIL;
-			goto exit;
-		}
-
-		init_h2fwcmd_w_parm_no_rsp(pcmdobj, set_ch_parm, GEN_CMD_CODE(_SetChannel));
-		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-	} else {
-		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
-		if( H2C_SUCCESS !=set_ch_hdl(padapter, (u8 *)set_ch_parm) )
-			res = _FAIL;
-		
-		rtw_mfree((u8 *)set_ch_parm, sizeof(*set_ch_parm));
-	}
-
-	/* do something based on res... */
-
-exit:
-
-	DBG_871X(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(padapter->pnetdev), res);
-
-_func_exit_;	
-
-	return res;
-}
-
 u8 rtw_set_chplan_cmd(_adapter*padapter, u8 chplan, u8 enqueue, u8 swconfig)
 {
 	struct	cmd_obj*	pcmdobj;
@@ -1951,7 +1474,7 @@ _func_enter_;
 		//need enqueue, prepare cmd_obj and enqueue
 		pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 		if(pcmdobj == NULL){
-			rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
+			kfree((u8 *)setChannelPlan_param);
 			res=_FAIL;
 			goto exit;
 		}
@@ -1965,7 +1488,7 @@ _func_enter_;
 		if( H2C_SUCCESS !=set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param) )
 			res = _FAIL;
 		
-		rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
+		kfree((u8 *)setChannelPlan_param);
 	}
 
 	//do something based on res...
@@ -1979,92 +1502,6 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_led_blink_cmd(_adapter*padapter, void * pLed)
-{
-	struct	cmd_obj*	pcmdobj;
-	struct	LedBlink_param *ledBlink_param;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
-
-	u8	res=_SUCCESS;
-
-_func_enter_;
-
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
-	
-	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmdobj == NULL){
-		res=_FAIL;
-		goto exit;
-	}
-
-	ledBlink_param = (struct	LedBlink_param *)rtw_zmalloc(sizeof(struct	LedBlink_param));
-	if(ledBlink_param == NULL) {
-		rtw_mfree((u8 *)pcmdobj, sizeof(struct cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	ledBlink_param->pLed=pLed;
-	
-	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledBlink_param, GEN_CMD_CODE(_LedBlink));
-	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-	
-exit:
-
-_func_exit_;	
-
-	return res;
-}
-
-u8 rtw_set_csa_cmd(_adapter*padapter, u8 new_ch_no)
-{
-	struct	cmd_obj*	pcmdobj;
-	struct	SetChannelSwitch_param*setChannelSwitch_param;
-	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
-
-	u8	res=_SUCCESS;
-
-_func_enter_;
-
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
-	
-	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmdobj == NULL){
-		res=_FAIL;
-		goto exit;
-	}
-
-	setChannelSwitch_param = (struct SetChannelSwitch_param *)rtw_zmalloc(sizeof(struct	SetChannelSwitch_param));
-	if(setChannelSwitch_param == NULL) {
-		rtw_mfree((u8 *)pcmdobj, sizeof(struct cmd_obj));
-		res= _FAIL;
-		goto exit;
-	}
-
-	setChannelSwitch_param->new_ch_no=new_ch_no;
-	
-	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelSwitch_param, GEN_CMD_CODE(_SetChannelSwitch));
-	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-	
-exit:
-
-_func_exit_;	
-
-	return res;
-}
-
-u8 rtw_tdls_cmd(_adapter *padapter, u8 *addr, u8 option)
-{
-	u8	res=_SUCCESS;
-
-_func_enter_;
-
-_func_exit_;	
-
-	return res;
-}
-
 static void collect_traffic_statistics(_adapter *padapter)
 {
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
@@ -2150,8 +1587,6 @@ u8 traffic_status_watchdog(_adapter *pad
 			TRAFFIC_PROTECT_PERIOD_MS,
 			link_detect->NumTxOkInPeriod,
 			link_detect->NumRxUnicastOkInPeriod);
-
-		rtw_lock_traffic_suspend_timeout(TRAFFIC_PROTECT_PERIOD_MS);
 	}
 #endif
 		
@@ -2250,12 +1685,10 @@ static void dynamic_chk_wk_hdl(_adapter
 	struct mlme_priv *pmlmepriv;
 	pmlmepriv = &(padapter->mlmepriv);
 
-#ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{			
 		expire_timeout_chk(padapter);
 	}
-#endif
 
 	//for debug purpose
 	_linked_info_dump(padapter);
@@ -2370,7 +1803,7 @@ _func_enter_;
 		
 		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 		if(pdrvextra_cmd_parm==NULL){
-			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+			kfree((unsigned char *)ph2c);
 			res= _FAIL;
 			goto exit;
 		}
@@ -2418,7 +1851,7 @@ u8 rtw_dm_in_lps_wk_cmd(_adapter*padapte
 		
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -2470,43 +1903,6 @@ static void rtw_lps_change_dtim_hdl(_ada
 	up(&pwrpriv->lock);
 }
 
-u8 rtw_lps_change_dtim_cmd(_adapter*padapter, u8 dtim)
-{
-	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
-	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	res = _SUCCESS;
-
-	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
-		if(ph2c==NULL){
-			res= _FAIL;
-			goto exit;
-		}
-		
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
-		if(pdrvextra_cmd_parm==NULL){
-			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-			res= _FAIL;
-			goto exit;
-		}
-
-		pdrvextra_cmd_parm->ec_id = LPS_CHANGE_DTIM_CID;
-		pdrvextra_cmd_parm->type = dtim;
-		pdrvextra_cmd_parm->size = 0;
-		pdrvextra_cmd_parm->pbuf = NULL;
-
-		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
-
-		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-	}
-	
-exit:
-	
-	return res;
-
-}
-
 static void rtw_dm_ra_mask_hdl(_adapter *padapter, struct sta_info *psta)
 {
 	if (psta) {
@@ -2530,7 +1926,7 @@ u8 rtw_dm_ra_mask_wk_cmd(_adapter*padapt
 		
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -2583,7 +1979,7 @@ _func_enter_;
 		
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ppscmd, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ppscmd);
 		res= _FAIL;
 		goto exit;
 	}
@@ -2604,8 +2000,6 @@ _func_exit_;
 
 }
 
-#ifdef CONFIG_AP_MODE
-
 extern u32 g_wait_hiq_empty;
 
 static void rtw_chk_hi_queue_hdl(_adapter *padapter)
@@ -2666,7 +2060,7 @@ u8 rtw_chk_hi_queue_cmd(_adapter*padapte
 			
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -2685,7 +2079,6 @@ exit:
 	return res;
 
 }
-#endif
 
 struct btinfo {
 	u8 cid;
@@ -2751,50 +2144,6 @@ static void rtw_btinfo_hdl(_adapter *ada
 	rtw_btcoex_BtInfoNotify(adapter ,len+1, &buf[1]);
 }
 
-u8 rtw_btinfo_cmd(_adapter *adapter, u8 *buf, u16 len)
-{
-	struct cmd_obj *ph2c;
-	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
-	u8 *btinfo;
-	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
-	u8	res = _SUCCESS;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if (ph2c == NULL) {
-		res = _FAIL;
-		goto exit;
-	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-	if (pdrvextra_cmd_parm == NULL) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
-		res = _FAIL;
-		goto exit;
-	}
-
-	btinfo = rtw_zmalloc(len);
-	if (btinfo == NULL) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
-		rtw_mfree((u8*)pdrvextra_cmd_parm, sizeof(struct drvextra_cmd_parm));
-		res = _FAIL;
-		goto exit;
-	}
-
-	pdrvextra_cmd_parm->ec_id = BTINFO_WK_CID;
-	pdrvextra_cmd_parm->type = 0;
-	pdrvextra_cmd_parm->size = len;
-	pdrvextra_cmd_parm->pbuf = btinfo;
-
-	memcpy(btinfo, buf, len);
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
-exit:
-	return res;
-}
-
 u8 rtw_c2h_packet_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length)
 {
 	struct cmd_obj *ph2c;
@@ -2810,7 +2159,7 @@ u8 rtw_c2h_packet_wk_cmd(PADAPTER padapt
 
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
 	if (pdrvextra_cmd_parm == NULL) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		kfree((u8*)ph2c);
 		res = _FAIL;
 		goto exit;
 	}
@@ -2845,7 +2194,7 @@ u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8
 
 	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
 	if (pdrvextra_cmd_parm == NULL) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		kfree((u8*)ph2c);
 		res = _FAIL;
 		goto exit;
 	}
@@ -2864,42 +2213,6 @@ exit:
 	return res;
 }
 
-u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void*), void* context)
-{
-	struct cmd_priv *pcmdpriv;
-	struct cmd_obj *ph2c;
-	struct RunInThread_param *parm;
-	s32 res = _SUCCESS;
-
-_func_enter_;
-
-	pcmdpriv = &padapter->cmdpriv;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
-	if (NULL == ph2c) {
-		res = _FAIL;
-		goto exit;
-	}
-
-	parm = (struct RunInThread_param*)rtw_zmalloc(sizeof(struct RunInThread_param));
-	if (NULL == parm) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
-		res = _FAIL;
-		goto exit;
-	}
-
-	parm->func = func;
-	parm->context = context;
-	init_h2fwcmd_w_parm_no_rsp(ph2c, parm, GEN_CMD_CODE(_RunInThreadCMD));
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-exit:
-
-_func_exit_;
-
-	return res;
-}
-
 static void c2h_wk_callback(_workitem *work)
 {
 	struct evt_priv *evtpriv = container_of(work, struct evt_priv, c2h_wk);
@@ -2916,7 +2229,7 @@ static void c2h_wk_callback(_workitem *w
 		} else if ((c2h_evt = (u8 *)rtw_malloc(16)) != NULL) {
 			/* This C2H event is not read, read & clear now */
 			if (rtw_hal_c2h_evt_read(adapter, c2h_evt) != _SUCCESS) {
-				rtw_mfree(c2h_evt, 16);
+				kfree(c2h_evt);
 				continue;
 			}
 		}
@@ -2926,14 +2239,14 @@ static void c2h_wk_callback(_workitem *w
 			continue;
 
 		if (!rtw_hal_c2h_valid(adapter, c2h_evt)) {
-			rtw_mfree(c2h_evt, 16);
+			kfree(c2h_evt);
 			continue;
 		}
 		
 		if (ccx_id_filter(c2h_evt) == true) {
 			/* Handle CCX report here */
 			rtw_hal_c2h_handler(adapter, c2h_evt);
-			rtw_mfree(c2h_evt, 16);
+			kfree(c2h_evt);
 		} else {
 			/* Enqueue into cmd_thread for others */
 			rtw_c2h_wk_cmd(adapter, c2h_evt);
@@ -2969,11 +2282,9 @@ u8 rtw_drvextra_cmd_hdl(_adapter *padapt
 		case LPS_CHANGE_DTIM_CID:
 			rtw_lps_change_dtim_hdl(padapter, (u8)pdrvextra_cmd->type);
 			break;
-#ifdef CONFIG_AP_MODE
 		case CHECK_HIQ_WK_CID:
 			rtw_chk_hi_queue_hdl(padapter);
 			break;
-#endif //CONFIG_AP_MODE
 #ifdef CONFIG_INTEL_WIDI
 		case INTEl_WIDI_WK_CID:
 			intel_widi_wk_hdl(padapter, pdrvextra_cmd->type, pdrvextra_cmd->pbuf);
@@ -3001,7 +2312,7 @@ u8 rtw_drvextra_cmd_hdl(_adapter *padapt
 
 	if (pdrvextra_cmd->pbuf && pdrvextra_cmd->size>0)
 	{
-		rtw_mfree(pdrvextra_cmd->pbuf, pdrvextra_cmd->size);
+		kfree(pdrvextra_cmd->pbuf);
 	}
 
 	return H2C_SUCCESS;
@@ -3038,9 +2349,9 @@ _func_enter_;
 
 	if (pcmd->res != H2C_SUCCESS)
 	{
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_lock_bh(&pmlmepriv->lock);
 		set_fwstate(pmlmepriv, _FW_LINKED);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&pmlmepriv->lock);
 				
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 
@@ -3100,7 +2411,7 @@ _func_enter_;
 	
 	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	
 	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) )
@@ -3123,28 +2434,28 @@ _func_enter_;
 		_irqL	irqL;
 
 		pwlan = _rtw_alloc_network(pmlmepriv);
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		if ( pwlan == NULL)
 		{
 			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
 			if( pwlan == NULL)
 			{
 				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n Error:  can't get pwlan in rtw_joinbss_event_callback \n"));
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto createbss_cmd_fail;
 			}
 			pwlan->last_scanned = jiffies;
 		}	
 		else
 		{
-			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+			list_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 		}
 				
 		pnetwork->Length = get_WLAN_BSSID_EX_sz(pnetwork);
 		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
 		//pwlan->fixed = true;
 
-		//rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+		//list_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 
 		// copy pdev_network information to 	pmlmepriv->cur_network
 		memcpy(&tgt_network->network, pnetwork, (get_WLAN_BSSID_EX_sz(pnetwork)));
@@ -3154,14 +2465,14 @@ _func_enter_;
 
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
 			
 	}
 
 createbss_cmd_fail:
 	
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 exit:
 	rtw_free_cmd_obj(pcmd);
 	
@@ -3214,28 +2525,16 @@ _func_enter_;
 	
 	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))           	
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 	set_fwstate(pmlmepriv, _FW_LINKED);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	rtw_free_cmd_obj(pcmd);
 
 _func_exit_;
 }
-
-void rtw_getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
-void rtw_getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
-{
-_func_enter_;
-
-	rtw_free_cmd_obj(pcmd);
-
-_func_exit_;
-
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_debug.c linux/3rdparty/rtl8723bs/core/rtw_debug.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_debug.c	2015-05-10 14:36:05.666667879 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_debug.c	2015-05-07 17:46:55.000000000 +0300
@@ -62,7 +62,7 @@ u32 GlobalDebugLevel = _drv_err_;
 
 void dump_drv_version(void *sel)
 {
-	DBG_871X_SEL_NL(sel, "%s %s\n", DRV_NAME, DRIVERVERSION);
+	DBG_871X_SEL_NL(sel, "%s %s\n", "rtl8723bs", DRIVERVERSION);
 }
 
 void dump_log_level(void *sel)
@@ -309,7 +309,6 @@ int proc_get_mlmext_state(struct seq_fil
 	return 0;
 }
 
-#ifdef CONFIG_LAYER2_ROAMING
 int proc_get_roam_flags(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -411,7 +410,6 @@ ssize_t proc_set_roam_tgt_addr(struct fi
 
 	return count;
 }
-#endif /* CONFIG_LAYER2_ROAMING */
 
 int proc_get_qos_option(struct seq_file *m, void *v)
 {
@@ -463,18 +461,19 @@ int proc_get_survey_info(struct seq_file
 	s16 notify_noise = 0;
 	u16  index = 0;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
+	plist = phead ? get_next(phead) : NULL;
 	plist = get_next(phead);
 	if ((!phead) || (!plist)) {
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		return 0;
 	}
 
 	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %-4s  %5s  %s\n","index", "bssid", "ch", "RSSI", "SdBm", "Noise", "age", "ssid");
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -504,7 +503,7 @@ int proc_get_survey_info(struct seq_file
 			pnetwork->network.Ssid.Ssid);
 		plist = get_next(plist);
 	}
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	return 0;
 }
@@ -1325,9 +1324,6 @@ ssize_t proc_set_rssi_disp(struct file *
 	
 }	
 
-		
-#ifdef CONFIG_AP_MODE
-
 int proc_get_all_sta_info(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -1341,14 +1337,14 @@ int proc_get_all_sta_info(struct seq_fil
 
 	DBG_871X_SEL_NL(m, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	for(i=0; i< NUM_STA; i++)
 	{
 		phead = &(pstapriv->sta_hash[i]);
 		plist = get_next(phead);
 		
-		while ((rtw_end_of_queue_search(phead, plist)) == false)
+		while (phead != plist)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -1394,12 +1390,10 @@ int proc_get_all_sta_info(struct seq_fil
 
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 	return 0;
 }
-	
-#endif
 
 int proc_get_btcoex_dbg(struct seq_file *m, void *v)
 {
@@ -1497,7 +1491,7 @@ int proc_get_btcoex_info(struct seq_file
 
 	DBG_871X_SEL(m, "%s\n", pbuf);
 	
-	rtw_mfree(pbuf, bufsize);
+	kfree(pbuf);
 
 	return 0;
 }
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_eeprom.c linux/3rdparty/rtl8723bs/core/rtw_eeprom.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_eeprom.c	2015-05-10 14:36:05.666667879 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_eeprom.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,381 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#define _RTW_EEPROM_C_
-
-#include <drv_conf.h>
-#include <osdep_service.h>
-#include <drv_types.h>
-
-void up_clk(_adapter*	padapter,	 u16 *x)
-{
-_func_enter_;
-	*x = *x | _EESK;
-	rtw_write8(padapter, EE_9346CR, (u8)*x);
-	udelay(CLOCK_RATE);
-
-_func_exit_;
-	
-}
-
-void down_clk(_adapter *	padapter, u16 *x	)
-{
-_func_enter_;
-	*x = *x & ~_EESK;
-	rtw_write8(padapter, EE_9346CR, (u8)*x);
-	udelay(CLOCK_RATE);
-_func_exit_;	
-}
-
-void shift_out_bits(_adapter * padapter, u16 data, u16 count)
-{
-	u16 x,mask;
-_func_enter_;
-
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	mask = 0x01 << (count - 1);
-	x = rtw_read8(padapter, EE_9346CR);
-
-	x &= ~(_EEDO | _EEDI);
-
-	do
-	{
-		x &= ~_EEDI;
-		if(data & mask)
-			x |= _EEDI;
-		if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-		}
-		rtw_write8(padapter, EE_9346CR, (u8)x);
-		udelay(CLOCK_RATE);
-		up_clk(padapter, &x);
-		down_clk(padapter, &x);
-		mask = mask >> 1;
-	} while(mask);
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	x &= ~_EEDI;
-	rtw_write8(padapter, EE_9346CR, (u8)x);
-out:	
-_func_exit_;		
-}
-
-u16 shift_in_bits (_adapter * padapter)
-{
-	u16 x,d=0,i;
-_func_enter_;	
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	x = rtw_read8(padapter, EE_9346CR);
-
-	x &= ~( _EEDO | _EEDI);
-	d = 0;
-
-	for(i=0; i<16; i++)
-	{
-		d = d << 1;
-		up_clk(padapter, &x);
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-		x = rtw_read8(padapter, EE_9346CR);
-
-		x &= ~(_EEDI);
-		if(x & _EEDO)
-		d |= 1;
-
-		down_clk(padapter, &x);
-	}
-out:	
-_func_exit_;		
-
-	return d;
-}
-
-void standby(_adapter *	padapter	)
-{
-	u8   x;
-_func_enter_;	
-	x = rtw_read8(padapter, EE_9346CR);
-
-	x &= ~(_EECS | _EESK);
-	rtw_write8(padapter, EE_9346CR,x);
-
-	udelay(CLOCK_RATE);
-	x |= _EECS;
-	rtw_write8(padapter, EE_9346CR, x);
-	udelay(CLOCK_RATE);
-_func_exit_;		
-}
-
-u16 wait_eeprom_cmd_done(_adapter* padapter)
-{
-	u8 	x;
-	u16	i,res=false;
-_func_enter_;	
-	standby(padapter );
-	for (i=0; i<200; i++) 
-	{
-		x = rtw_read8(padapter, EE_9346CR);
-		if (x & _EEDO){
-			res=true;
-			goto exit;
-			}
-		udelay(CLOCK_RATE);
-	}
-exit:	
-_func_exit_;			
-	return res;
-}
-
-void eeprom_clean(_adapter * padapter)
-{
-	u16 x;
-_func_enter_;		
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	x = rtw_read8(padapter, EE_9346CR);
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	x &= ~(_EECS | _EEDI);
-	rtw_write8(padapter, EE_9346CR, (u8)x);
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	up_clk(padapter, &x);
-		if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	down_clk(padapter, &x);
-out:	
-_func_exit_;			
-}
-
-void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
-{
-	u8 x;
-
-_func_enter_;		
-	
-	x = rtw_read8(padapter, EE_9346CR);
-
-	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
-	x |= _EEM1 | _EECS;
-	rtw_write8(padapter, EE_9346CR, x);
-
-	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
-	
-	if(padapter->EepromAddressSize==8)	//CF+ and SDIO
-		shift_out_bits(padapter, 0, 6);
-	else									//USB
-		shift_out_bits(padapter, 0, 4);
-	
-	standby( padapter);
-
-// Commented out by rcnjko, 2004.0
-//	// Erase this particular word.  Write the erase opcode and register
-//	// number in that order. The opcode is 3bits in length; reg is 6 bits long.
-//	shift_out_bits(Adapter, EEPROM_ERASE_OPCODE, 3);
-//	shift_out_bits(Adapter, reg, Adapter->EepromAddressSize);
-//
-//	if (wait_eeprom_cmd_done(Adapter ) == false) 
-//	{
-//		return;
-//	}
-
-
-	standby(padapter );
-
-	// write the new word to the EEPROM
-
-	// send the write opcode the EEPORM
-	shift_out_bits(padapter, EEPROM_WRITE_OPCODE, 3);
-
-	// select which word in the EEPROM that we are writing to.
-	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
-
-	// write the data to the selected EEPROM word.
-	shift_out_bits(padapter, data, 16);
-
-	if (wait_eeprom_cmd_done(padapter ) == false) 
-	{
-
-		goto exit;
-	}
-
-	standby(padapter );
-
-	shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
-	shift_out_bits(padapter, reg, 4);
-
-	eeprom_clean(padapter );
-exit:	
-_func_exit_;	
-	return;
-}
-
-u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
-{
-
-	u16 x;
-	u16 data=0;
-
-_func_enter_;		
-
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	// select EEPROM, reset bits, set _EECS
-	x = rtw_read8(padapter, EE_9346CR);
-
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-
-	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
-	x |= _EEM1 | _EECS;
-	rtw_write8(padapter, EE_9346CR, (unsigned char)x);
-
-	// write the read opcode and register number in that order
-	// The opcode is 3bits in length, reg is 6 bits long
-	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
-	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
-
-	// Now read the data (16 bits) in from the selected EEPROM word
-	data = shift_in_bits(padapter);
-
-	eeprom_clean(padapter);
-out:	
-_func_exit_;		
-	return data;
-
-
-}
-
-
-
-
-//From even offset
-void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz) 
-{
-
-	u16 x, data16;
-	u32 i;
-_func_enter_;		
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-	// select EEPROM, reset bits, set _EECS
-	x = rtw_read8(padapter, EE_9346CR);
-
-	if(padapter->bSurpriseRemoved==true){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
-		goto out;
-	}
-
-	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
-	x |= _EEM1 | _EECS;
-	rtw_write8(padapter, EE_9346CR, (unsigned char)x);
-
-	// write the read opcode and register number in that order
-	// The opcode is 3bits in length, reg is 6 bits long
-	shift_out_bits(padapter, EEPROM_READ_OPCODE, 3);
-	shift_out_bits(padapter, reg, padapter->EepromAddressSize);
-
-
-	for(i=0; i<sz; i+=2)
-	{
-		data16 = shift_in_bits(padapter);
-		data[i] = data16 & 0xff;
-		data[i+1] = data16 >>8;		
-	}
-
-	eeprom_clean(padapter);
-out:	
-_func_exit_;		
-
-
-
-}
-
-
-//addr_off : address offset of the entry in eeprom (not the tuple number of eeprom (reg); that is addr_off !=reg)
-u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
-{
-	u8 quotient, remainder, addr_2align_odd;
-	u16 reg, stmp , i=0, idx = 0;
-_func_enter_;		
-	reg = (u16)(addr_off >> 1);
-	addr_2align_odd = (u8)(addr_off & 0x1);
-
-	if(addr_2align_odd) //read that start at high part: e.g  1,3,5,7,9,...
-	{
-		stmp = eeprom_read16(padapter, reg);
-		rbuf[idx++] = (u8) ((stmp>>8)&0xff); //return hogh-part of the short
-		reg++; sz--;
-	}
-	
-	quotient = sz >> 1;
-	remainder = sz & 0x1;
-
-	for( i=0 ; i < quotient; i++)
-	{
-		stmp = eeprom_read16(padapter, reg+i);
-		rbuf[idx++] = (u8) (stmp&0xff);
-		rbuf[idx++] = (u8) ((stmp>>8)&0xff);
-	}
-	
-	reg = reg+i;
-	if(remainder){ //end of read at lower part of short : 0,2,4,6,...
-		stmp = eeprom_read16(padapter, reg);
-		rbuf[idx] = (u8)(stmp & 0xff); 
-	}
-_func_exit_;		
-	return true;
-}
-
-
-
-void read_eeprom_content(_adapter *	padapter)
-{
-
-_func_enter_;		
-
-
-_func_exit_;		
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_efuse.c linux/3rdparty/rtl8723bs/core/rtw_efuse.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_efuse.c	2015-05-10 14:36:05.666667879 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_efuse.c	2015-05-07 17:46:55.000000000 +0300
@@ -121,18 +121,8 @@ Efuse_PowerSwitch(
 	pAdapter->HalFunc.EfusePowerSwitch(pAdapter, bWrite, PwrState);
 }
 
-void
-BTEfuse_PowerSwitch(
-	IN	PADAPTER	pAdapter,
-	IN	u8		bWrite,
-	IN	u8		PwrState)
-{
-	if(pAdapter->HalFunc.BTEfusePowerSwitch)
-		pAdapter->HalFunc.BTEfusePowerSwitch(pAdapter, bWrite, PwrState);
-}
-
 /*-----------------------------------------------------------------------------
- * Function:	efuse_GetCurrentSize
+ * Function:	Efuse_GetCurrentSize
  *
  * Overview:	Get current efuse size!!!
  *
@@ -174,68 +164,6 @@ Efuse_CalculateWordCnts(IN u8	word_en)
 
 //
 //	Description:
-//		Execute E-Fuse read byte operation.
-//		Refered from SD1 Richard.
-//
-//	Assumption:
-//		1. Boot from E-Fuse and successfully auto-load.
-//		2. PASSIVE_LEVEL (USB interface)
-//
-//	Created by Roger, 2008.10.21.
-//
-void
-ReadEFuseByte(
-		PADAPTER	Adapter,
-		u16 			_offset, 
-		u8 			*pbuf, 
-		IN bool	bPseudoTest) 
-{
-	u32	value32;
-	u8	readbyte;
-	u16	retry;
-
-	if(bPseudoTest)
-	{
-		Efuse_Read1ByteFromFakeContent(Adapter, _offset, pbuf);
-		return;
-	}
-	// <20130121, Kordan> For SMIC S55 EFUSE specificatoin.
-	//0x34[11]: SW force PGMEN input of efuse to high. (for the bank selected by 0x34[9:8])
-	PHY_SetMacReg(Adapter, EFUSE_TEST, BIT11, 0);
-
-	//Write Address
-	rtw_write8(Adapter, EFUSE_CTRL+1, (_offset & 0xff));  		
-	readbyte = rtw_read8(Adapter, EFUSE_CTRL+2);
-	rtw_write8(Adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));  		
-
-	//Write bit 32 0
-	readbyte = rtw_read8(Adapter, EFUSE_CTRL+3);		
-	rtw_write8(Adapter, EFUSE_CTRL+3, (readbyte & 0x7f));  	
-	
-	//Check bit 32 read-ready
-	retry = 0;
-	value32 = rtw_read32(Adapter, EFUSE_CTRL);
-	//while(!(((value32 >> 24) & 0xff) & 0x80)  && (retry<10))
-	while(!(((value32 >> 24) & 0xff) & 0x80)  && (retry<10000))
-	{
-		value32 = rtw_read32(Adapter, EFUSE_CTRL);
-		retry++;
-	}
-
-	// 20100205 Joseph: Add delay suggested by SD1 Victor.
-	// This fix the problem that Efuse read error in high temperature condition.
-	// Designer says that there shall be some delay after ready bit is set, or the
-	// result will always stay on last data we read.
-	udelay(50);
-	value32 = rtw_read32(Adapter, EFUSE_CTRL);
-	
-	*pbuf = (u8)(value32 & 0xff);
-	//DBG_871X("ReadEFuseByte _offset:%08u, in %d ms\n",_offset ,jiffies_to_msecs(jiffies - start));
-	
-}
-
-//
-//	Description:
 //		1. Execute E-Fuse read byte operation according as map offset and 
 //		    save to E-Fuse table.
 //		2. Refered from SD1 Richard.
@@ -350,76 +278,6 @@ EFUSE_Read1Byte(
 	
 }/* EFUSE_Read1Byte */
 
-/*-----------------------------------------------------------------------------
- * Function:	EFUSE_Write1Byte
- *
- * Overview:	Copy from WMAC fot EFUSE write 1 byte.
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- * When			Who		Remark
- * 09/23/2008 	MHC		Copy from WMAC.
- *
- *---------------------------------------------------------------------------*/
-
-void	
-EFUSE_Write1Byte(	
-	IN	PADAPTER	Adapter, 
-	IN	u16		Address,
-	IN	u8		Value);
-void	
-EFUSE_Write1Byte(	
-	IN	PADAPTER	Adapter, 
-	IN	u16		Address,
-	IN	u8		Value)
-{
-	u8	Bytetemp = {0x00};
-	u8	temp = {0x00};
-	u32	k=0;
-	u16	contentLen=0;
-
-	//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("Addr=%x Data =%x\n", Address, Value));
-	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&contentLen, false);
-
-	if( Address < contentLen)	//E-fuse 512Byte
-	{
-		rtw_write8(Adapter, EFUSE_CTRL, Value);
-
-		//Write E-fuse Register address bit0~7
-		temp = Address & 0xFF;	
-		rtw_write8(Adapter, EFUSE_CTRL+1, temp);	
-		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);	
-		
-		//Write E-fuse Register address bit8~9
-		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);	
-		rtw_write8(Adapter, EFUSE_CTRL+2, temp);	
-
-		//Write 0x30[31]=1
-		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
-		temp = Bytetemp | 0x80;
-		rtw_write8(Adapter, EFUSE_CTRL+3, temp);
-
-		//Wait Write-ready (0x30[31]=0)
-		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
-		while(Bytetemp & 0x80)
-		{
-			Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);			
-			k++;
-			if(k==100)
-			{
-				k=0;
-				break;
-			}
-		}
-	}
-}/* EFUSE_Write1Byte */
-
-
 /*  11/16/2008 MH Read one byte from real Efuse. */
 u8
 efuse_OneByteRead(
@@ -642,289 +500,6 @@ Efuse_WordEnableDataWrite(	IN	PADAPTER	p
 	return ret;
 }
 
-static u8 efuse_read8(PADAPTER padapter, u16 address, u8 *value)
-{
-	return efuse_OneByteRead(padapter,address, value, false);
-}
-
-static u8 efuse_write8(PADAPTER padapter, u16 address, u8 *value)
-{
-	return efuse_OneByteWrite(padapter,address, *value, false);
-}
-
-/*
- * read/wirte raw efuse data
- */
-u8 rtw_efuse_access(PADAPTER padapter, u8 bWrite, u16 start_addr, u16 cnts, u8 *data)
-{
-	int i = 0;
-	u16	real_content_len = 0, max_available_size = 0;
-	u8 res = _FAIL ;
-	u8 (*rw8)(PADAPTER, u16, u8*);
-
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&real_content_len, false);
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
-
-	if (start_addr > real_content_len)
-		return _FAIL;
-
-	if (true == bWrite) {
-		if ((start_addr + cnts) > max_available_size)
-			return _FAIL;
-		rw8 = &efuse_write8;
-	} else
-		rw8 = &efuse_read8;
-
-	Efuse_PowerSwitch(padapter, bWrite, true);
-
-	// e-fuse one byte read / write
-	for (i = 0; i < cnts; i++) {
-		if (start_addr >= real_content_len) {
-			res = _FAIL;
-			break;
-		}
-
-		res = rw8(padapter, start_addr++, data++);
-		if (_FAIL == res) break;
-	}
-
-	Efuse_PowerSwitch(padapter, bWrite, false);
-
-	return res;
-}
-//------------------------------------------------------------------------------
-u16 efuse_GetMaxSize(PADAPTER padapter)
-{
-	u16	max_size;
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI , TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_size, false);
-	return max_size;
-}
-//------------------------------------------------------------------------------
-u8 efuse_GetCurrentSize(PADAPTER padapter, u16 *size)
-{
-	Efuse_PowerSwitch(padapter, false, true);
-	*size = Efuse_GetCurrentSize(padapter, EFUSE_WIFI, false);
-	Efuse_PowerSwitch(padapter, false, false);
-
-	return _SUCCESS;
-}
-//------------------------------------------------------------------------------
-u8 rtw_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
-{
-	u16	mapLen=0;
-
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, false);
-
-	if ((addr + cnts) > mapLen)
-		return _FAIL;
-
-	Efuse_PowerSwitch(padapter, false, true);
-
-	efuse_ReadEFuse(padapter, EFUSE_WIFI, addr, cnts, data, false);
-
-	Efuse_PowerSwitch(padapter, false, false);
-
-	return _SUCCESS;
-}
-
-u8 rtw_BT_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
-{
-	u16	mapLen=0;
-
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, false);
-
-	if ((addr + cnts) > mapLen)
-		return _FAIL;
-
-	Efuse_PowerSwitch(padapter, false, true);
-
-	efuse_ReadEFuse(padapter, EFUSE_BT, addr, cnts, data, false);
-
-	Efuse_PowerSwitch(padapter, false, false);
-
-	return _SUCCESS;
-}
-//------------------------------------------------------------------------------
-u8 rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
-{
-#define RT_ASSERT_RET(expr)												\
-	if(!(expr)) {															\
-		printk( "Assertion failed! %s at ......\n", #expr);							\
-		printk( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);	\
-		return _FAIL;	\
-	}
-
-	u8	offset, word_en;
-	u8	*map;
-	u8	newdata[PGPKT_DATA_SIZE];
-	s32	i, j, idx;
-	u8	ret = _SUCCESS;
-	u16	mapLen=0;
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, false);
-
-	if ((addr + cnts) > mapLen)
-		return _FAIL;
-
-	RT_ASSERT_RET(PGPKT_DATA_SIZE == 8); // have to be 8 byte alignment
-	RT_ASSERT_RET((mapLen & 0x7) == 0); // have to be PGPKT_DATA_SIZE alignment for memcpy
-
-	map = rtw_zmalloc(mapLen);
-	if(map == NULL){
-		return _FAIL;
-	}
-	
-	memset(map, 0xFF, mapLen);
-	
-	ret = rtw_efuse_map_read(padapter, 0, mapLen, map);
-	if (ret == _FAIL) goto exit;
-
-	Efuse_PowerSwitch(padapter, true, true);
-
-	idx = 0;
-	offset = (addr >> 3);
-	while (idx < cnts)
-	{
-		word_en = 0xF;
-		j = (addr + idx) & 0x7;
-		memcpy(newdata, &map[offset << 3], PGPKT_DATA_SIZE);
-		for (i = j; i<PGPKT_DATA_SIZE && idx < cnts; i++, idx++)
-		{
-			if (data[idx] != map[addr + idx])
-			{
-				word_en &= ~BIT(i >> 1);
-				newdata[i] = data[idx];
-
-				 if( addr + idx == 0x8)
-				 {	
-					if (IS_C_CUT(pHalData->VersionID) || IS_B_CUT(pHalData->VersionID))
-					{
-						if(pEEPROM->adjuseVoltageVal == 6)
-						{
-								newdata[i] = map[addr + idx];
-							 	DBG_8192C(" %s ,\n adjuseVoltageVal = %d ,newdata[%d] = %x \n",__func__,pEEPROM->adjuseVoltageVal,i,newdata[i]);	 
-						}
-					}
-				  }
-			}
-		}
-
-		if (word_en != 0xF) {
-			ret = Efuse_PgPacketWrite(padapter, offset, word_en, newdata, false);
-			DBG_871X("offset=%x \n",offset);
-			DBG_871X("word_en=%x \n",word_en);
-
-			for(i=0;i<PGPKT_DATA_SIZE;i++)
-			{
-				DBG_871X("data=%x \t",newdata[i]);
-			}
-			if (ret == _FAIL) break;
-		}
-
-		offset++;
-	}
-
-	Efuse_PowerSwitch(padapter, true, false);
-
-exit:
-
-	rtw_mfree(map, mapLen);
-
-	return ret;
-}
-
-
-//------------------------------------------------------------------------------
-u8 rtw_BT_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
-{
-#define RT_ASSERT_RET(expr)												\
-	if(!(expr)) {															\
-		printk( "Assertion failed! %s at ......\n", #expr);							\
-		printk( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);	\
-		return _FAIL;	\
-	}
-
-	u8	offset, word_en;
-	u8	*map;
-	u8	newdata[PGPKT_DATA_SIZE];
-	s32	i=0, j=0, idx;
-	u8	ret = _SUCCESS;
-	u16	mapLen=0;
-
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_BT, TYPE_EFUSE_MAP_LEN, (void *)&mapLen, false);
-
-	if ((addr + cnts) > mapLen)
-		return _FAIL;
-
-	RT_ASSERT_RET(PGPKT_DATA_SIZE == 8); // have to be 8 byte alignment
-	RT_ASSERT_RET((mapLen & 0x7) == 0); // have to be PGPKT_DATA_SIZE alignment for memcpy
-
-	map = rtw_zmalloc(mapLen);
-	if(map == NULL){
-		return _FAIL;
-	}
-
-	ret = rtw_BT_efuse_map_read(padapter, 0, mapLen, map);
-	if (ret == _FAIL) goto exit;
-	DBG_871X("OFFSET\tVALUE(hex)\n");
-	for (i=0; i<1024; i+=16) // set 512 because the iwpriv's extra size have limit 0x7FF
-	{
-			DBG_871X("0x%03x\t", i);
-			for (j=0; j<8; j++) {
-				DBG_871X("%02X ", map[i+j]);
-			}
-			DBG_871X("\t");
-			for (; j<16; j++) {
-				DBG_871X("%02X ", map[i+j]);
-			}
-			DBG_871X("\n");
-	}
-	DBG_871X("\n");
-	Efuse_PowerSwitch(padapter, true, true);
-
-	idx = 0;
-	offset = (addr >> 3);
-	while (idx < cnts)
-	{
-		word_en = 0xF;
-		j = (addr + idx) & 0x7;
-		memcpy(newdata, &map[offset << 3], PGPKT_DATA_SIZE);
-		for (i = j; i<PGPKT_DATA_SIZE && idx < cnts; i++, idx++)
-		{
-			if (data[idx] != map[addr + idx])
-			{
-				word_en &= ~BIT(i >> 1);
-				newdata[i] = data[idx];
-			}
-		}
-
-		if (word_en != 0xF) {
-			DBG_871X("offset=%x \n",offset);
-			DBG_871X("word_en=%x \n",word_en);
-			DBG_871X("%s: data=", __FUNCTION__);
-			for(i=0;i<PGPKT_DATA_SIZE;i++)
-			{
-				DBG_871X("0x%02X ", newdata[i]);
-			}
-			DBG_871X("\n");
-			ret = Efuse_PgPacketWrite_BT(padapter, offset, word_en, newdata, false);
-			if (ret == _FAIL) break;
-		}
-
-		offset++;
-	}
-
-	Efuse_PowerSwitch(padapter, true, false);
-
-exit:
-
-	rtw_mfree(map, mapLen);
-
-	return ret;
-}
-
 /*-----------------------------------------------------------------------------
  * Function:	Efuse_ReadAllMap
  *
@@ -1096,65 +671,3 @@ EFUSE_ShadowRead(
 		efuse_ShadowRead4Byte(pAdapter, Offset, (u32 *)Value);
 	
 }	// EFUSE_ShadowRead
-
-/*-----------------------------------------------------------------------------
- * Function:	EFUSE_ShadowWrite
- *
- * Overview:	Write efuse modify map for later update operation to use!!!!!
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- * When			Who		Remark
- * 11/12/2008 	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-void
-EFUSE_ShadowWrite(
-	IN	PADAPTER	pAdapter,
-	IN	u8		Type,
-	IN	u16		Offset,
-	IN OUT	u32		Value);
-void
-EFUSE_ShadowWrite(
-	IN	PADAPTER	pAdapter,
-	IN	u8		Type,
-	IN	u16		Offset,
-	IN OUT	u32		Value)
-{
-	return;
-}	// EFUSE_ShadowWrite
-
-void
-Efuse_InitSomeVar(
-	IN		PADAPTER	pAdapter
-	);
-void
-Efuse_InitSomeVar(
-	IN		PADAPTER	pAdapter
-	)
-{
-	u8 i;
-	
-	memset((void *)&fakeEfuseContent[0], 0xff, EFUSE_MAX_HW_SIZE);
-	memset((void *)&fakeEfuseInitMap[0], 0xff, EFUSE_MAX_MAP_LEN);
-	memset((void *)&fakeEfuseModifiedMap[0], 0xff, EFUSE_MAX_MAP_LEN);
-
-	for(i=0; i<EFUSE_MAX_BT_BANK; i++)
-	{
-		memset((void *)&BTEfuseContent[i][0], EFUSE_MAX_HW_SIZE, 0xff);
-	}
-	memset((void *)&BTEfuseInitMap[0], 0xff, EFUSE_BT_MAX_MAP_LEN);
-	memset((void *)&BTEfuseModifiedMap[0], 0xff, EFUSE_BT_MAX_MAP_LEN);
-
-	for(i=0; i<EFUSE_MAX_BT_BANK; i++)
-	{
-		memset((void *)&fakeBTEfuseContent[i][0], 0xff, EFUSE_MAX_HW_SIZE);
-	}
-	memset((void *)&fakeBTEfuseInitMap[0], 0xff, EFUSE_BT_MAX_MAP_LEN);
-	memset((void *)&fakeBTEfuseModifiedMap[0], 0xff, EFUSE_BT_MAX_MAP_LEN);
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_ieee80211.c linux/3rdparty/rtl8723bs/core/rtw_ieee80211.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_ieee80211.c	2015-05-10 14:36:05.667667890 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_ieee80211.c	2015-05-07 17:46:55.000000000 +0300
@@ -159,62 +159,10 @@ _func_enter_;
 		memcpy((void *)(pbuf + 2), (void *)source, len);
 	
 	*frlen = *frlen + (len + 2);
-	
-	return (pbuf + len + 2);
-_func_exit_;	
-}
-
-inline u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode,
-	u8 new_ch, u8 ch_switch_cnt)
-{
-	u8 ie_data[3];
-
-	ie_data[0] = ch_switch_mode;
-	ie_data[1] = new_ch;
-	ie_data[2] = ch_switch_cnt;
-	return rtw_set_ie(buf, WLAN_EID_CHANNEL_SWITCH,  3, ie_data, buf_len);
-}
-
-inline u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset)
-{
-	if (ch_offset == SCN)
-		return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-	else if(ch_offset == SCA)
-		return HAL_PRIME_CHNL_OFFSET_UPPER;
-	else if(ch_offset == SCB)
-		return HAL_PRIME_CHNL_OFFSET_LOWER;
 
-	return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-}
-
-inline u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset)
-{
-	if (ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
-		return SCN;
-	else if(ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
-		return SCB;
-	else if(ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
-		return SCA;
-
-	return SCN;
-}
-
-inline u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset)
-{
-	return rtw_set_ie(buf, WLAN_EID_SECONDARY_CHANNEL_OFFSET,  1, &secondary_ch_offset, buf_len);
-}
-
-inline u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl,
-	u8 flags, u16 reason, u16 precedence)
-{
-	u8 ie_data[6];
+	_func_exit_;
 
-	ie_data[0] = ttl;
-	ie_data[1] = flags;
-	RTW_PUT_LE16((u8*)&ie_data[2], reason);
-	RTW_PUT_LE16((u8*)&ie_data[4], precedence);
-
-	return rtw_set_ie(buf, 0x118,  6, ie_data, buf_len);
+	return (pbuf + len + 2);
 }
 
 /*----------------------------------------------------------------------------
@@ -896,28 +844,6 @@ u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_i
 	return match;
 }
 
-u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type)
-{
-	u8*	wps = NULL;
-
-	DBG_871X( "[%s] frame_type = %d\n", __FUNCTION__, frame_type );
-	switch( frame_type )
-	{
-		case 1:
-		case 3:
-		{	//	Beacon or Probe Response
-			wps = rtw_get_wps_ie(in_ie + _PROBERSP_IE_OFFSET_, in_len - _PROBERSP_IE_OFFSET_, wps_ie, wps_ielen);
-			break;
-		}
-		case 2:
-		{	//	Probe Request
-			wps = rtw_get_wps_ie(in_ie + _PROBEREQ_IE_OFFSET_ , in_len - _PROBEREQ_IE_OFFSET_ , wps_ie, wps_ielen);
-			break;
-		}
-	}
-	return wps;
-}
-
 /**
  * rtw_get_wps_ie - Search WPS IE from a series of IEs
  * @in_ie: Address of IEs to search
@@ -1318,33 +1244,12 @@ static u8 key_char2num(u8 ch)
 	 return 0xff;
 }
 
-u8 str_2char2num(u8 hch, u8 lch);
-u8 str_2char2num(u8 hch, u8 lch)
-{
-    return ((key_char2num(hch) * 10 ) + key_char2num(lch));
-}
-
 u8 key_2char2num(u8 hch, u8 lch);
 u8 key_2char2num(u8 hch, u8 lch)
 {
     return ((key_char2num(hch) << 4) | key_char2num(lch));
 }
 
-void macstr2num(u8 *dst, u8 *src);
-void macstr2num(u8 *dst, u8 *src)
-{
-	int	jj, kk;
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
-		dst[jj] = key_2char2num(src[kk], src[kk + 1]);
-	}
-}
-
-u8 convert_ip_addr(u8 hch, u8 mch, u8 lch)
-{
-    return ((key_char2num(hch) * 100) + (key_char2num(mch) * 10 ) + key_char2num(lch));
-}
-
 extern char* rtw_initmac;
 void rtw_macaddr_cfg(u8 *mac_addr)
 {
@@ -1385,90 +1290,6 @@ void rtw_macaddr_cfg(u8 *mac_addr)
 	DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
 }
 
-void dump_ies(u8 *buf, u32 buf_len)
-{
-	u8* pos = (u8*)buf;
-	u8 id, len;
-
-	while(pos-buf<=buf_len){
-		id = *pos;
-		len = *(pos+1);
-
-		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
-		dump_wps_ie(pos, len);
-
-		pos+=(2+len);
-	}
-}
-
-void dump_wps_ie(u8 *ie, u32 ie_len)
-{
-	u8* pos = (u8*)ie;
-	u16 id;
-	u16 len;
-
-	u8 *wps_ie;
-	uint wps_ielen;
-
-	wps_ie = rtw_get_wps_ie(ie, ie_len, NULL, &wps_ielen);
-	if(wps_ie != ie || wps_ielen == 0)
-		return;
-
-	pos+=6;
-	while(pos-ie < ie_len){
-		id = RTW_GET_BE16(pos);
-		len = RTW_GET_BE16(pos + 2);
-
-		DBG_871X("%s ID:0x%04x, LEN:%u\n", __FUNCTION__, id, len);
-
-		pos+=(4+len);
-	}
-}
-
-//Baron adds to avoid FreeBSD warning
-int ieee80211_is_empty_essid(const char *essid, int essid_len)
-{
-	/* Single white space is for Linksys APs */
-	if (essid_len == 1 && essid[0] == ' ')
-		return 1;
-
-	/* Otherwise, if the entire essid is 0, we assume it is hidden */
-	while (essid_len) {
-		essid_len--;
-		if (essid[essid_len] != '\0')
-			return 0;
-	}
-
-	return 1;
-}
-
-int ieee80211_get_hdrlen(u16 fc)
-{
-	int hdrlen = 24;
-
-	switch (WLAN_FC_GET_TYPE(fc)) {
-	case RTW_IEEE80211_FTYPE_DATA:
-		if (fc & RTW_IEEE80211_STYPE_QOS_DATA)
-			hdrlen += 2;
-		if ((fc & RTW_IEEE80211_FCTL_FROMDS) && (fc & RTW_IEEE80211_FCTL_TODS))
-			hdrlen += 6; /* Addr4 */
-		break;
-	case RTW_IEEE80211_FTYPE_CTL:
-		switch (WLAN_FC_GET_STYPE(fc)) {
-		case RTW_IEEE80211_STYPE_CTS:
-		case RTW_IEEE80211_STYPE_ACK:
-			hdrlen = 10;
-			break;
-		default:
-			hdrlen = 16;
-			break;
-		}
-		break;
-	}
-
-	return hdrlen;
-}
-
 int rtw_get_cipher_info(struct wlan_network *pnetwork)
 {
 	u32 wpa_ielen;
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_io.c linux/3rdparty/rtl8723bs/core/rtw_io.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_io.c	2015-05-10 14:36:05.667667890 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_io.c	2015-05-07 17:46:55.000000000 +0300
@@ -34,8 +34,6 @@ Compiler Flag Option:
     a. USE_SYNC_IRP:  Only sync operations are provided.
     b. USE_ASYNC_IRP:Both sync/async operations are provided.
 
-Only sync read/rtw_write_mem operations are provided.
-
 jackson@realtek.com.tw
 
 */
@@ -143,22 +141,6 @@ int _rtw_write32(_adapter *adapter, u32
 	return RTW_STATUS_CODE(ret);
 }
 
-int _rtw_writeN(_adapter *adapter, u32 addr ,u32 length , u8 *pdata)
-{
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-        struct	intf_hdl	*pintfhdl = (struct intf_hdl*)(&(pio_priv->intf));
-	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr,u32 length, u8 *pdata);
-	int ret;
-	_func_enter_;
-	_writeN = pintfhdl->io_ops._writeN;
-
-	ret = _writeN(pintfhdl, addr,length,pdata);
-	_func_exit_;
-
-	return RTW_STATUS_CODE(ret);
-}
-
 u8 _rtw_sd_f0_read8(_adapter *adapter, u32 addr)
 {
 	u8 r_val = 0x00;
@@ -178,129 +160,6 @@ u8 _rtw_sd_f0_read8(_adapter *adapter, u
 	return r_val;
 }
 
-int _rtw_write8_async(_adapter *adapter, u32 addr, u8 val)
-{
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
-	int ret;
-	_func_enter_;
-	_write8_async = pintfhdl->io_ops._write8_async;
-
-	ret = _write8_async(pintfhdl, addr, val);
-	_func_exit_;
-
-	return RTW_STATUS_CODE(ret);
-}
-int _rtw_write16_async(_adapter *adapter, u32 addr, u16 val)
-{
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
-	int ret;
-	_func_enter_;
-	_write16_async = pintfhdl->io_ops._write16_async;
-	val = rtw_cpu_to_le16(val);
-	ret = _write16_async(pintfhdl, addr, val);
-	_func_exit_;
-
-	return RTW_STATUS_CODE(ret);
-}
-int _rtw_write32_async(_adapter *adapter, u32 addr, u32 val)
-{
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
-	int ret;
-	_func_enter_;
-	_write32_async = pintfhdl->io_ops._write32_async;
-	val = rtw_cpu_to_le32(val);
-	ret = _write32_async(pintfhdl, addr, val);
-	_func_exit_;
-
-	return RTW_STATUS_CODE(ret);
-}
-
-void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
-{
-	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-
-	_func_enter_;
-
-	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
-	{
-	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
-	     return;
-	}
-
-	_read_mem = pintfhdl->io_ops._read_mem;
-
-	_read_mem(pintfhdl, addr, cnt, pmem);
-
-	_func_exit_;
-
-}
-
-void _rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
-{
-	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-
-	_func_enter_;
-
-	_write_mem = pintfhdl->io_ops._write_mem;
-
-	_write_mem(pintfhdl, addr, cnt, pmem);
-
-	_func_exit_;
-
-}
-
-void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
-{
-	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue  	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-
-	_func_enter_;
-
-	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
-	{
-	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
-	     return;
-	}
-
-	_read_port = pintfhdl->io_ops._read_port;
-
-	_read_port(pintfhdl, addr, cnt, pmem);
-
-	_func_exit_;
-
-}
-
-void _rtw_read_port_cancel(_adapter *adapter)
-{
-	void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct intf_hdl *pintfhdl = &(pio_priv->intf);
-
-	_read_port_cancel = pintfhdl->io_ops._read_port_cancel;
-
-	RTW_DISABLE_FUNC(adapter, DF_RX_BIT);
-
-	if(_read_port_cancel)
-		_read_port_cancel(pintfhdl);
-}
-
 u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 {
 	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
@@ -320,36 +179,6 @@ u32 _rtw_write_port(_adapter *adapter, u
 	return ret;
 }
 
-u32 _rtw_write_port_and_wait(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms)
-{
-	int ret = _SUCCESS;
-	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pmem;
-	struct submit_ctx sctx;
-
-	rtw_sctx_init(&sctx, timeout_ms);
-	pxmitbuf->sctx = &sctx;
-
-	ret = _rtw_write_port(adapter, addr, cnt, pmem);
-
-	if (ret == _SUCCESS)
-		ret = rtw_sctx_wait(&sctx, __func__);
-
-	 return ret;
-}
-
-void _rtw_write_port_cancel(_adapter *adapter)
-{
-	void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
-	struct io_priv *pio_priv = &adapter->iopriv;
-	struct intf_hdl *pintfhdl = &(pio_priv->intf);
-
-	_write_port_cancel = pintfhdl->io_ops._write_port_cancel;
-
-	RTW_DISABLE_FUNC(adapter, DF_TX_BIT);
-
-	if(_write_port_cancel)
-		_write_port_cancel(pintfhdl);
-}
 int rtw_init_io_priv(_adapter *padapter, void (*set_intf_ops)(_adapter *padapter,struct _io_ops *pops))
 {
 	struct io_priv	*piopriv = &padapter->iopriv;
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_ioctl_set.c linux/3rdparty/rtl8723bs/core/rtw_ioctl_set.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_ioctl_set.c	2015-05-10 14:36:05.668667902 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_ioctl_set.c	2015-05-07 17:46:55.000000000 +0300
@@ -89,7 +89,7 @@ u8 rtw_do_join(_adapter * padapter)
 
 _func_enter_;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
@@ -103,9 +103,9 @@ _func_enter_;
 
 	pmlmepriv->to_join = true;
 
-	if(_rtw_queue_empty(queue)== true)
+	if(list_empty(&queue->queue))
 	{	
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
             		
 		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
@@ -133,7 +133,7 @@ _func_enter_;
 	else 	
 	{
 		int select_ret;
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		if((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
 		{
 			pmlmepriv->to_join = false;
@@ -224,7 +224,7 @@ _func_enter_;
 		goto exit;
 	}
 		
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 
 	DBG_871X("Set BSSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
@@ -279,7 +279,7 @@ handle_tkip_countermeasure:
 	}
 
 release_mlme_lock:
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 		
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
@@ -311,7 +311,7 @@ _func_enter_;
 		goto exit;
 	}
 		
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	DBG_871X("Set SSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {	
@@ -400,7 +400,7 @@ handle_tkip_countermeasure:
 	}
 
 release_mlme_lock:
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
@@ -443,7 +443,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT"  fw_state=0x%08x\n",
 		FUNC_ADPT_ARG(padapter), get_fwstate(pmlmepriv));
@@ -480,7 +480,7 @@ handle_tkip_countermeasure:
 	}
 
 release_mlme_lock:
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	
@@ -512,13 +512,11 @@ _func_enter_;
 		{		
 			//change to other mode from Ndis802_11APMode			
 			cur_network->join_res = -1;
-			
-#ifdef CONFIG_NATIVEAP_MLME
+
 			stop_ap_mode(padapter);
-#endif
 		}
 
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_lock_bh(&pmlmepriv->lock);
 		
 		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||(*pold_state==Ndis802_11IBSS))
 			rtw_disassoc_cmd(padapter, 0, true);
@@ -551,11 +549,9 @@ _func_enter_;
 				
 			case Ndis802_11APMode:
 				set_fwstate(pmlmepriv, WIFI_AP_STATE);
-#ifdef CONFIG_NATIVEAP_MLME
 				start_ap_mode(padapter);
 				//rtw_indicate_connect(padapter);
-#endif				
-				
+
 				break;
 
 			case Ndis802_11AutoUnknown:
@@ -568,7 +564,7 @@ _func_enter_;
 		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
 		//									get_fwstate(pmlmepriv) ));
 
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&pmlmepriv->lock);
 	}
 
 _func_exit_;
@@ -584,7 +580,7 @@ u8 rtw_set_802_11_disassociate(_adapter
 
 _func_enter_;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
@@ -598,7 +594,7 @@ _func_enter_;
 			DBG_871X("%s(): rtw_pwr_wakeup fail !!!\n",__FUNCTION__);
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 	
 _func_exit_;
 
@@ -644,11 +640,11 @@ _func_enter_;
 			return _SUCCESS;
 		}
 		
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);		
+		spin_lock_bh(&pmlmepriv->lock);
 		
 		res = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);
 		
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&pmlmepriv->lock);
 	}
 exit:
 	
@@ -674,11 +670,6 @@ _func_enter_;
 	if(psecuritypriv->ndisauthtype>3)
 		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_8021X;
 	
-#ifdef CONFIG_WAPI_SUPPORT
-	if(psecuritypriv->ndisauthtype == 6)
-		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_WAPI;
-#endif
-
 	res=rtw_set_auth(padapter,psecuritypriv);
 	
 	if(res==_SUCCESS)
@@ -755,467 +746,6 @@ _func_exit_;
 	
 }
 
-u8 rtw_set_802_11_remove_wep(_adapter* padapter, u32 keyindex){
-	
-	u8 ret=_SUCCESS;
-	
-_func_enter_;
-
-	if (keyindex >= 0x80000000 || padapter == NULL){
-		
-		ret=false;
-		goto exit;
-
-	}
-	else 
-	{
-		int res;
-		struct security_priv* psecuritypriv=&(padapter->securitypriv);
-		if( keyindex < 4 ){
-			
-			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
-			
-			res=rtw_set_key(padapter,psecuritypriv,keyindex, 0, true);
-			
-			psecuritypriv->dot11DefKeylen[keyindex]=0;
-			
-			if(res==_FAIL)
-				ret=_FAIL;
-			
-		}
-		else
-		{			
-			ret=_FAIL;
-		}
-		
-	}
-	
-exit:	
-	
-_func_exit_;
-
-	return ret;
-	
-}
-
-u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
-
-	uint	encryptionalgo;
-	u8 * pbssid;
-	struct sta_info *stainfo;
-	u8	bgroup = false;
-	u8	bgrouptkey = false;//can be remove later
-	u8	ret=_SUCCESS;
-	
-_func_enter_;
-
-	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
-
-		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, 
-		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000) > 0)[=%d]" , (int)(key->KeyIndex & 0x40000000) > 0));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: key->KeyIndex=%d \n" ,(int)key->KeyIndex));
-		ret= _FAIL;
-		goto exit;
-	}
-
-	if(key->KeyIndex & 0x40000000)
-	{ 
-		// Pairwise key
-
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
-	
-		pbssid=get_bssid(&padapter->mlmepriv);
-		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
-
-		if((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:( stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
-			encryptionalgo=stainfo->dot118021XPrivacy;
-		}
-		else{
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: stainfo==NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!=dot11AuthAlgrthm_8021X)\n"));
-			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
-		}
-
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (encryptionalgo ==%d)!\n",encryptionalgo ));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
-
-		if((stainfo!=NULL)){
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
-		}
-		
-		if(key->KeyIndex & 0x000000FF){
-			// The key index is specified in the lower 8 bits by values of zero to 255.
-			// The key index should be set to zero for a Pairwise key, and the driver should fail with
-			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" key->KeyIndex & 0x000000FF.\n"));
-			ret= _FAIL;
-			goto exit;
-		}
-
-		// check BSSID
-		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true){
-
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
-			ret= false;
-			goto exit;
-		}
-
-		// Check key length for TKIP.
-		//if(encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
-		if((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
-			ret=_FAIL;
-			goto exit;
-
-		}
-
-		// Check key length for AES.
-		if((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
-			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
-			if(key->KeyLength == 32) {
-				key->KeyLength = 16; 
-			} else {
-				ret= _FAIL;
-				goto exit;
-			}
-		}
-
-		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
-		if(	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
-			ret=_FAIL;
-			goto exit;
-		}
-
-		bgroup = false;
-
-		// Check the pairwise key. Added by Annie, 2005-07-06.
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Pairwise Key set]\n"));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-	
-	}
-	else 
-	{	
-		// Group key - KeyIndex(BIT30==0)
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
-
-
-		// when add wep key through add key and didn't assigned encryption type before
-		if((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
-		{
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
-
-			switch(key->KeyLength)
-			{
-				case 5:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
-					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
-					break;
-				case 13:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
-					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u\n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
-					break;
-				default:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
-					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u \n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
-					break;
-			}
-			
-			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
-			
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" Adapter->securitypriv.dot11PrivacyAlgrthm=%x\n", padapter->securitypriv.dot11PrivacyAlgrthm));
-			
-		}
-		else 
-		{
-			encryptionalgo=padapter->securitypriv.dot118021XGrpPrivacy;
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
-
-		}
-		
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
-			ret= _FAIL;
-			goto exit;
-		}
-
-		// Check key length for TKIP
-		if((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
-
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
-			ret= _FAIL;
-			goto exit;
-
-		} else if(encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
-			
-			// Check key length for AES
-			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
-			ret= _FAIL;
-			goto exit;
-		}
-
-		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
-		if((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
-			key->KeyLength = 16; 
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
-		}
-
-		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
-			bgrouptkey = true;
-		}
-
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==true))
-		{
-			bgrouptkey = true;
-		}
-
-		bgroup = true;
-
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n") );
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n") );
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n")) ;
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength)) ;
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-		
-	}	
-
-	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
-	if((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
-	{
-		u8 ret;		
-		u32 keyindex;		
-		u32 len = FIELD_OFFSET(NDIS_802_11_KEY, KeyMaterial) + key->KeyLength;
-		NDIS_802_11_WEP *wep = &padapter->securitypriv.ndiswep;
-				
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));
-
-		wep->Length = len;
-		keyindex = key->KeyIndex&0x7fffffff;
-		wep->KeyIndex = keyindex ;
-		wep->KeyLength = key->KeyLength;
-		
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:Before memcpy \n"));
-
-		memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);	
-		memcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
-
-		padapter->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;		
-		padapter->securitypriv.dot11PrivacyKeyIndex=keyindex;
-		
-		ret = rtw_set_802_11_add_wep(padapter, wep);
-	
-		goto exit;
-		
-	}
-
-	if(key->KeyIndex & 0x20000000){
-		// SetRSC
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
-		if(bgroup == true)
-		{
-			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
-			memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);			
-		} 
-		else 
-		{		
-			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;	
-			memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);			
-		}
-			
-	}
-
-	// Indicate this key idx is used for TX
-	// Save the key in KeyMaterial
-	if(bgroup == true) // Group transmit key
-	{
-		int res;
-		
-		if(bgrouptkey == true)
-		{		
-			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
-		}
-		
-		if((key->KeyIndex&0x3) == 0){
-			ret = _FAIL;
-			goto exit;
-		}		
-		
-		memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
-		memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
-		memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
-		
-		if((key->KeyIndex & 0x10000000))
-		{
-			memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
-			memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
-			
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
-
-		}
-		else
-		{
-			memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
-			memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
-			
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
-				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
-		
-		}
-
-		//set group key by index
-		memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);
-		
-		key->KeyIndex=key->KeyIndex & 0x03;
-		
-		padapter->securitypriv.binstallGrpkey=true;
-		
-		padapter->securitypriv.bcheck_grpkey=false;
-		
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("reset group key"));
-		
-		res=rtw_set_key(padapter,&padapter->securitypriv, key->KeyIndex, 1, true);
-
-		if(res==_FAIL)
-			ret= _FAIL;
-
-		goto exit;
-			
-	}
-	else // Pairwise Key
-	{
-		u8 res;
-		
-		pbssid=get_bssid(&padapter->mlmepriv);
-		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
-		
-		if(stainfo!=NULL)
-		{			
-			memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
-			
-			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
-			
-			if(encryptionalgo== _TKIP_)
-			{
-				padapter->securitypriv.busetkipkey=false;
-				
-				//_set_timer(&padapter->securitypriv.tkip_timer, 50);
-				
-				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
-				
-				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
-				if((key->KeyIndex & 0x10000000)){
-					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
-					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
-
-				} else {
-					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);
-					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
-
-				}
-		
-			}
-			else if(encryptionalgo == _AES_)
-			{		
-	
-			}
-
-		
-			//Set key to CAM through H2C command
-			if(bgrouptkey)//never go to here
-			{
-				res=rtw_setstakey_cmd(padapter, stainfo, false, true);
-				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
-			}
-			else{
-				res=rtw_setstakey_cmd(padapter, stainfo, true, true);
-				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
-			}
-			
-			if(res ==false)
-				ret= _FAIL;
-			
-		}
-
-	}
-
-exit:
-	
-_func_exit_;
-
-	return ret;	
-}
-
-u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
-	
-	uint				encryptionalgo;
-	u8 * pbssid;
-	struct sta_info *stainfo;
-	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false: true;
-	u8	keyIndex = (u8)key->KeyIndex & 0x03;
-	u8	ret=_SUCCESS;
-	
-_func_enter_;
-
-	if ((key->KeyIndex & 0xbffffffc) > 0) {
-		ret=_FAIL;
-		goto exit;
-	}
-
-	if (bgroup == true) {
-		encryptionalgo= padapter->securitypriv.dot118021XGrpPrivacy;
-		// clear group key by index
-		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
-		//Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
-		
-		memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
-		
-		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
-	
-	} else {
-	
-		pbssid=get_bssid(&padapter->mlmepriv);
-		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
-		if(stainfo !=NULL){
-			encryptionalgo=stainfo->dot118021XPrivacy;
-
-		// clear key by BSSID
-		memset(&stainfo->dot118021x_UncstKey, 0, 16);
-		
-		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
-
-		}
-		else{
-			ret= _FAIL;
-			goto exit;
-		}
-	}
-
-exit:
-	
-_func_exit_;
-
-	return true;
-	
-}
-
 /*
 * rtw_get_cur_max_rate - 
 * @adapter: pointer to _adapter structure
@@ -1267,87 +797,3 @@ u16 rtw_get_cur_max_rate(_adapter *adapt
 
 	return max_rate;
 }
-
-/*
-* rtw_set_scan_mode - 
-* @adapter: pointer to _adapter structure
-* @scan_mode: 
-* 
-* Return _SUCCESS or _FAIL
-*/
-int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode)
-{
-	if(scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
-		return _FAIL;
-	
-	adapter->mlmepriv.scan_mode = scan_mode;
-
-	return _SUCCESS;
-}
-
-/*
-* rtw_set_channel_plan - 
-* @adapter: pointer to _adapter structure
-* @channel_plan: 
-* 
-* Return _SUCCESS or _FAIL
-*/
-int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan)
-{
-	struct registry_priv *pregistrypriv = &adapter->registrypriv;
-	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-
-	//handle by cmd_thread to sync with scan operation
-	return rtw_set_chplan_cmd(adapter, channel_plan, 1, 1);
-}
-
-/*
-* rtw_set_country - 
-* @adapter: pointer to _adapter structure
-* @country_code: string of country code
-* 
-* Return _SUCCESS or _FAIL
-*/
-int rtw_set_country(_adapter *adapter, const char *country_code)
-{
-	int channel_plan = RT_CHANNEL_DOMAIN_WORLD_WIDE_5G;
-
-	DBG_871X("%s country_code:%s\n", __func__, country_code);
-
-	//TODO: should have a table to match country code and RT_CHANNEL_DOMAIN
-	//TODO: should consider 2-character and 3-character country code
-	if(0 == strcmp(country_code, "US"))
-		channel_plan = RT_CHANNEL_DOMAIN_FCC;
-	else if(0 == strcmp(country_code, "EU"))
-		channel_plan = RT_CHANNEL_DOMAIN_ETSI;
-	else if(0 == strcmp(country_code, "JP"))
-		channel_plan = RT_CHANNEL_DOMAIN_MKK;
-	else if(0 == strcmp(country_code, "CN"))
-		channel_plan = RT_CHANNEL_DOMAIN_CHINA;
-	else if(0 == strcmp(country_code, "IN"))
-		channel_plan = RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN;
-	else
-		DBG_871X("%s unknown country_code:%s\n", __FUNCTION__, country_code);
-	
-	return rtw_set_channel_plan(adapter, channel_plan);
-}
-
-/*
-* rtw_set_band - 
-* @adapter: pointer to _adapter structure
-* @band: band to set
-* 
-* Return _SUCCESS or _FAIL
-*/
-int rtw_set_band(_adapter *adapter, enum _BAND band)
-{
-	if (rtw_band_valid(band)) {
-		DBG_871X(FUNC_ADPT_FMT" band:%d\n", FUNC_ADPT_ARG(adapter), band);
-		adapter->setband = band;
-		return _SUCCESS;
-	}
-
-	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" band:%d fail\n", FUNC_ADPT_ARG(adapter), band);
-	return _FAIL;
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_mlme.c linux/3rdparty/rtl8723bs/core/rtw_mlme.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_mlme.c	2015-05-10 14:36:05.670667924 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_mlme.c	2015-05-07 17:46:55.000000000 +0300
@@ -37,7 +37,7 @@ sint	_rtw_init_mlme_priv (_adapter* pada
 
 _func_enter_;
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc().
 	//memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
 
 	pmlmepriv->nic_hdl = (u8 *)padapter;
@@ -56,7 +56,7 @@ _func_enter_;
 	
 	memset(&pmlmepriv->assoc_ssid,0,sizeof(NDIS_802_11_SSID));
 
-	pbuf = rtw_zvmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+	pbuf = vzalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
 	
 	if (pbuf == NULL){
 		res=_FAIL;
@@ -68,9 +68,9 @@ _func_enter_;
 	
 	for(i = 0; i < MAX_BSS_CNT; i++)
 	{		
-		_rtw_init_listhead(&(pnetwork->list));
+		INIT_LIST_HEAD(&(pnetwork->list));
 
-		rtw_list_insert_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));
+		list_add_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));
 
 		pnetwork++;
 	}
@@ -79,17 +79,14 @@ _func_enter_;
 
 	rtw_clear_scan_deny(padapter);
 
-#ifdef CONFIG_LAYER2_ROAMING
 	#define RTW_ROAM_SCAN_RESULT_EXP_MS 5*1000
 	#define RTW_ROAM_RSSI_DIFF_TH 10
 	#define RTW_ROAM_SCAN_INTERVAL_MS 10*1000
 
 	pmlmepriv->roam_flags = 0
 		| RTW_ROAM_ON_EXPIRED
-		#ifdef CONFIG_LAYER2_ROAMING_RESUME
 		| RTW_ROAM_ON_RESUME
-		#endif
-		#ifdef CONFIG_LAYER2_ROAMING_ACTIVE
+		#ifdef CONFIG_LAYER2_ROAMING_ACTIVE //FIXME
 		| RTW_ROAM_ACTIVE
 		#endif
 		;
@@ -97,7 +94,6 @@ _func_enter_;
 	pmlmepriv->roam_scanr_exp_ms = RTW_ROAM_SCAN_RESULT_EXP_MS;
 	pmlmepriv->roam_rssi_diff_th = RTW_ROAM_RSSI_DIFF_TH;
 	pmlmepriv->roam_scan_int_ms = RTW_ROAM_SCAN_INTERVAL_MS;
-#endif /* CONFIG_LAYER2_ROAMING */
 
 	rtw_init_mlme_timer(padapter);
 
@@ -112,7 +108,7 @@ static void rtw_free_mlme_ie_data(u8 **p
 {
 	if(*ppie)
 	{		
-		rtw_mfree(*ppie, *plen);
+		kfree(*ppie);
 		*plen = 0;
 		*ppie=NULL;
 	}	
@@ -120,20 +116,18 @@ static void rtw_free_mlme_ie_data(u8 **p
 
 void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
 {
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	rtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);
 	rtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_beacon_ie, &pmlmepriv->wps_beacon_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie, &pmlmepriv->wps_probe_req_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie, &pmlmepriv->wps_probe_resp_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie, &pmlmepriv->wps_assoc_resp_ie_len);
-	
+
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie, &pmlmepriv->p2p_beacon_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie, &pmlmepriv->p2p_probe_req_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie, &pmlmepriv->p2p_probe_resp_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_go_probe_resp_ie, &pmlmepriv->p2p_go_probe_resp_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie, &pmlmepriv->p2p_assoc_req_ie_len);
-#endif
 }
 
 void _rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
@@ -144,34 +138,12 @@ _func_enter_;
 
 	if(pmlmepriv){
 		if (pmlmepriv->free_bss_buf) {
-			rtw_vmfree(pmlmepriv->free_bss_buf, MAX_BSS_CNT * sizeof(struct wlan_network));
+			vfree(pmlmepriv->free_bss_buf);
 		}
 	}
 _func_exit_;	
 }
 
-sint	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
-{
-	_irqL irqL;
-
-_func_enter_;	
-
-	if (pnetwork == NULL)
-		goto exit;
-	
-	_enter_critical_bh(&queue->lock, &irqL);
-
-	rtw_list_insert_tail(&pnetwork->list, &queue->queue);
-
-	_exit_critical_bh(&queue->lock, &irqL);
-
-exit:	
-
-_func_exit_;		
-
-	return _SUCCESS;
-}
-
 /*
 struct	wlan_network *_rtw_dequeue_network(_queue *queue)
 {
@@ -181,9 +153,9 @@ struct	wlan_network *_rtw_dequeue_networ
 
 _func_enter_;	
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	if (_rtw_queue_empty(queue) == true)
+	if (list_empty(&queue->queue))
 
 		pnetwork = NULL;
 	
@@ -191,10 +163,10 @@ _func_enter_;
 	{
 		pnetwork = LIST_CONTAINOR(get_next(&queue->queue), struct wlan_network, list);
 		
-		rtw_list_delete(&(pnetwork->list));
+		list_del_init(&(pnetwork->list));
 	}
 	
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 _func_exit_;		
 
@@ -211,9 +183,9 @@ struct	wlan_network *_rtw_alloc_network(
 	
 _func_enter_;	
 
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&free_queue->lock);
 	
-	if (_rtw_queue_empty(free_queue) == true) {
+	if (list_empty(&free_queue->queue)) {
 		pnetwork=NULL;
 		goto exit;
 	}
@@ -221,7 +193,7 @@ _func_enter_;
 	
 	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
 	
-	rtw_list_delete(&pnetwork->list);
+	list_del_init(&pnetwork->list);
 	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_rtw_alloc_network: ptr=%p\n", plist));
 	pnetwork->network_type = 0;
@@ -233,7 +205,7 @@ _func_enter_;
 	pmlmepriv->num_of_scanned ++;
 	
 exit:
-	_exit_critical_bh(&free_queue->lock, &irqL);
+	spin_unlock_bh(&free_queue->lock);
 
 _func_exit_;		
 
@@ -266,18 +238,18 @@ _func_enter_;
 			goto exit;
 	}
 
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&free_queue->lock);
 	
-	rtw_list_delete(&(pnetwork->list));
+	list_del_init(&(pnetwork->list));
 
-	rtw_list_insert_tail(&(pnetwork->list),&(free_queue->queue));
+	list_add_tail(&(pnetwork->list),&(free_queue->queue));
 		
 	pmlmepriv->num_of_scanned --;
 	
 
 	//DBG_871X("_rtw_free_network:SSID=%s\n", pnetwork->network.Ssid.Ssid);
 	
-	_exit_critical_bh(&free_queue->lock, &irqL);
+	spin_unlock_bh(&free_queue->lock);
 	
 exit:		
 	
@@ -298,15 +270,15 @@ _func_enter_;
 	if (pnetwork->fixed == true)
 		goto exit;
 
-	//_enter_critical(&free_queue->lock, &irqL);
+	//spin_lock_irqsave(&free_queue->lock, irqL);
 	
-	rtw_list_delete(&(pnetwork->list));
+	list_del_init(&(pnetwork->list));
 
-	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
+	list_add_tail(&(pnetwork->list), get_list_head(free_queue));
 		
 	pmlmepriv->num_of_scanned --;
 	
-	//_exit_critical(&free_queue->lock, &irqL);
+	//spin_unlock_irqrestore(&free_queue->lock, irqL);
 	
 exit:		
 
@@ -335,7 +307,7 @@ _func_enter_;
 		goto exit;
 	}
 	
-	//_enter_critical_bh(&scanned_queue->lock, &irqL);
+	//spin_lock_bh(&scanned_queue->lock);
 	
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
@@ -353,7 +325,7 @@ _func_enter_;
 	if(plist == phead)
 		pnetwork = NULL;
 
-	//_exit_critical_bh(&scanned_queue->lock, &irqL);
+	//spin_unlock_bh(&scanned_queue->lock);
 	
 exit:		
 	
@@ -375,12 +347,12 @@ void _rtw_free_network_queue(_adapter *p
 _func_enter_;	
 	
 
-	_enter_critical_bh(&scanned_queue->lock, &irqL);
+	spin_lock_bh(&scanned_queue->lock);
 
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == false)
+	while (phead != plist)
 	{
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -391,7 +363,7 @@ _func_enter_;
 		
 	}
 
-	_exit_critical_bh(&scanned_queue->lock, &irqL);
+	spin_unlock_bh(&scanned_queue->lock);
 	
 _func_exit_;		
 
@@ -450,11 +422,6 @@ _func_exit_;
 	return le16_to_cpu(val);
 }
 
-u8 *rtw_get_timestampe_from_ie(u8 *ie)
-{
-	return (ie + 0);	
-}
-
 u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
 {
 	return (ie + 8);	
@@ -478,16 +445,6 @@ _func_enter_;
 _func_exit_;	
 }
 
-int	rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
-int	rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
-{
-	int	res;
-_func_enter_;		
-	res = _rtw_enqueue_network(queue, pnetwork);
-_func_exit_;		
-	return res;
-}
-
 /*
 static struct	wlan_network *rtw_dequeue_network(_queue *queue)
 {
@@ -509,15 +466,6 @@ _func_exit_;
 	return pnetwork;
 }
 
-void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork, u8 is_freeall);
-void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork, u8 is_freeall)//(struct	wlan_network *pnetwork, _queue	*free_queue)
-{
-_func_enter_;		
-	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
-	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
-_func_exit_;
-}
-
 void rtw_free_network_nolock(_adapter * padapter, struct wlan_network *pnetwork );
 void rtw_free_network_nolock(_adapter * padapter, struct wlan_network *pnetwork )
 {
@@ -632,22 +580,6 @@ struct wlan_network *_rtw_find_same_netw
 	return found;
 }
 
-struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network)
-{
-	_irqL irqL;
-	struct wlan_network *found = NULL;
-
-	if (scanned_queue == NULL || network == NULL)
-		goto exit;	
-
-	_enter_critical_bh(&scanned_queue->lock, &irqL);
-	found = _rtw_find_same_network(scanned_queue, network);
-	_exit_critical_bh(&scanned_queue->lock, &irqL);
-
-exit:
-	return found;
-}
-
 struct	wlan_network	* rtw_get_oldest_wlan_network(_queue *scanned_queue)
 {
 	_list	*plist, *phead;
@@ -663,7 +595,7 @@ _func_enter_;
 	while(1)
 	{
 		
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 		
 		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -799,13 +731,13 @@ void rtw_update_scanned_network(_adapter
 
 _func_enter_;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -832,9 +764,9 @@ _func_enter_;
 	
 	/* If we didn't find a match, then get a new network slot to initialize
 	 * with this beacon's information */
-	//if (rtw_end_of_queue_search(phead,plist)== true) {
+	//if (phead == plist) {
 	if (!target_find) {		
-		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == true) {
+		if (list_empty(&pmlmepriv->free_bss_pool.queue)) {
 			/* If there are no more slots, expire the oldest */
 			//list_del_init(&oldest->list);
 			pnetwork = oldest;
@@ -875,7 +807,7 @@ _func_enter_;
 			if (pnetwork->network.PhyInfo.SignalQuality == 101)
 				pnetwork->network.PhyInfo.SignalQuality = 0;
 
-			rtw_list_insert_tail(&(pnetwork->list),&(queue->queue)); 
+			list_add_tail(&(pnetwork->list),&(queue->queue)); 
 
 		}
 	}
@@ -906,7 +838,7 @@ _func_enter_;
 	}
 
 exit:
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 _func_exit_;
 }
@@ -918,13 +850,13 @@ void rtw_add_network(_adapter *adapter,
 
 _func_enter_;		
 
-	//_enter_critical_bh(&queue->lock, &irqL);
+	//spin_lock_bh(&queue->lock);
 
 	update_current_network(adapter, pnetwork);
 	
 	rtw_update_scanned_network(adapter, pnetwork);
 
-	//_exit_critical_bh(&queue->lock, &irqL);
+	//spin_unlock_bh(&queue->lock);
 	
 _func_exit_;		
 }
@@ -1028,7 +960,7 @@ _func_enter_;
 	}
 
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	// update IBSS_network 's timestamp
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true)
@@ -1040,15 +972,15 @@ _func_enter_;
 			_irqL	irqL;
 			
 			memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
 			if(ibss_wlan)
 			{
 				memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);			
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);		
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto exit;
 			}
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		}
 	}
 
@@ -1064,7 +996,7 @@ _func_enter_;
 
 exit:	
 		
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 _func_exit_;		
 
@@ -1081,12 +1013,12 @@ void rtw_surveydone_event_callback(_adap
 
 _func_enter_;			
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	if(pmlmepriv->wps_probe_req_ie)
 	{
 		u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 		pmlmepriv->wps_probe_req_ie_len = 0;
-		rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
+		kfree(pmlmepriv->wps_probe_req_ie);
 		pmlmepriv->wps_probe_req_ie = NULL;			
 	}
 	
@@ -1105,13 +1037,13 @@ _func_enter_;
 	
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("nic status =%x, survey done event comes too late!\n", get_fwstate(pmlmepriv)));	
 	}
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	if(timer_cancelled)
 		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
 
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	rtw_set_signal_stat_timer(&adapter->recvpriv);
 
@@ -1213,7 +1145,7 @@ _func_enter_;
 	
 	//DBG_871X("scan complete in %dms\n",jiffies_to_msecs(jiffies - pmlmepriv->scan_start_time));
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_os_xmit_schedule(adapter);
 
@@ -1245,8 +1177,8 @@ static void free_scanqueue(struct	mlme_p
 _func_enter_;		
 	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
-	_enter_critical_bh(&scan_queue->lock, &irqL0);
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&scan_queue->lock);
+	spin_lock_bh(&free_queue->lock);
 
 	phead = get_list_head(scan_queue);
 	plist = get_next(phead);
@@ -1254,14 +1186,14 @@ _func_enter_;
 	while (plist != phead)
        {
 		ptemp = get_next(plist);
-		rtw_list_delete(plist);
-		rtw_list_insert_tail(plist, &free_queue->queue);
+		list_del_init(plist);
+		list_add_tail(plist, &free_queue->queue);
 		plist =ptemp;
 		pmlmepriv->num_of_scanned --;
         }
 	
-	_exit_critical_bh(&free_queue->lock, &irqL);
-	_exit_critical_bh(&scan_queue->lock, &irqL0);
+	spin_unlock_bh(&free_queue->lock);
+	spin_unlock_bh(&scan_queue->lock);
 	
 _func_exit_;
 }
@@ -1299,10 +1231,10 @@ _func_enter_;
 		struct sta_info* psta;
 		
 		psta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(adapter,  psta);
 
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 		
 	}
 
@@ -1313,15 +1245,15 @@ _func_enter_;
 		rtw_free_all_stainfo(adapter);
 
 		psta = rtw_get_bcmc_stainfo(adapter);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(adapter, psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		rtw_init_bcmc_stainfo(adapter);	
 	}
 
 	if(lock_scanned_queue)
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	
 	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 	if(pwlan)		
@@ -1341,7 +1273,7 @@ _func_enter_;
 	}
 
 	if(lock_scanned_queue)
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 	
 	adapter->securitypriv.key_mask = 0;
 
@@ -1369,8 +1301,6 @@ _func_enter_;
 
 		set_fwstate(pmlmepriv, _FW_LINKED);
 
-		rtw_led_control(padapter, LED_CTL_LINK);
-
 		rtw_os_indicate_connect(padapter);
 	}
 
@@ -1411,19 +1341,6 @@ _func_enter_;
 	if(rtw_to_roam(padapter) > 0)
 		_clr_fwstate_(pmlmepriv, _FW_LINKED);
 
-#ifdef CONFIG_WAPI_SUPPORT
-	psta = rtw_get_stainfo(pstapriv,cur_network->MacAddress);
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
-	{
-		rtw_wapi_return_one_sta_info(padapter, psta->hwaddr);
-	}
-	else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||
-		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE))
-	{
-		rtw_wapi_return_all_sta_info(padapter);
-	}
-#endif
-
 	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED) 
 		|| (rtw_to_roam(padapter) <= 0)
 	)
@@ -1435,8 +1352,6 @@ _func_enter_;
 
 	      _clr_fwstate_(pmlmepriv, _FW_LINKED);
 
-		rtw_led_control(padapter, LED_CTL_NO_LINK);
-
 		rtw_clear_scan_deny(padapter);
 	}
 
@@ -1539,9 +1454,7 @@ static struct sta_info *rtw_joinbss_upda
 						
 			memset((u8 *)&psta->dot11txpn, 0, sizeof (union pn48));
 			psta->dot11txpn.val = psta->dot11txpn.val + 1;
-#ifdef CONFIG_IEEE80211W
 			memset((u8 *)&psta->dot11wtxpn, 0, sizeof (union pn48));
-#endif //CONFIG_IEEE80211W
 			memset((u8 *)&psta->dot11rxpn, 0, sizeof (union pn48));	
 		}
 
@@ -1708,16 +1621,16 @@ _func_enter_;
 		goto ignore_joinbss_callback;
 	}
 		
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	
 	pmlmepriv->LinkDetectInfo.TrafficTransitionCount = 0;
 	pmlmepriv->LinkDetectInfo.LowPowerTransitionCount = 0;
 	
-	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! _enter_critical \n"));
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! spin_lock_irqsave \n"));
 
 	if(pnetwork->join_res > 0)
 	{
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		retry = 0;
 		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING) )
 		{
@@ -1735,9 +1648,9 @@ _func_enter_;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 					if(pcur_sta){
-						_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						spin_lock_bh(&(pstapriv->sta_hash_lock));
 						rtw_free_stainfo(adapter,  pcur_sta);
-						_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						spin_unlock_bh(&(pstapriv->sta_hash_lock));
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
@@ -1763,7 +1676,7 @@ _func_enter_;
 			else
 			{			
 				DBG_871X_LEVEL(_drv_always_, "Can't find ptarget_wlan when joinbss_event callback\n");
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto ignore_joinbss_callback;
 			}
 					
@@ -1775,7 +1688,7 @@ _func_enter_;
 				if(ptarget_sta==NULL)
 				{
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't update stainfo when joinbss_event callback\n"));
-					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+					spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 					goto ignore_joinbss_callback;
 				}
 			}
@@ -1802,11 +1715,11 @@ _func_enter_;
 		else
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_joinbss_event_callback err: fw_state:%x", get_fwstate(pmlmepriv)));	
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			goto ignore_joinbss_callback;
 		}
 		
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				
 	}
 	else if(pnetwork->join_res == -4) 
@@ -1861,7 +1774,7 @@ _func_enter_;
 
 ignore_joinbss_callback:
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 	_func_exit_;	
 }
 
@@ -1903,7 +1816,6 @@ _func_enter_;
 	if(rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
 		return;
 
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
 	{
 		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);	
@@ -1920,7 +1832,7 @@ _func_enter_;
 
 			//report to upper layer 
 			DBG_871X("indicate_sta_assoc_event to upper layer - hostapd\n");
-			_enter_critical_bh(&psta->lock, &irqL);
+			spin_lock_bh(&psta->lock);
 			if(psta->passoc_req && psta->assoc_req_len>0)
 			{				
 				passoc_req = rtw_zmalloc(psta->assoc_req_len);
@@ -1929,24 +1841,23 @@ _func_enter_;
 					assoc_req_len = psta->assoc_req_len;
 					memcpy(passoc_req, psta->passoc_req, assoc_req_len);
 					
-					rtw_mfree(psta->passoc_req , psta->assoc_req_len);
+					kfree(psta->passoc_req);
 					psta->passoc_req = NULL;
 					psta->assoc_req_len = 0;
 				}
 			}			
-			_exit_critical_bh(&psta->lock, &irqL);
+			spin_unlock_bh(&psta->lock);
 
 			if(passoc_req && assoc_req_len>0)
 			{
 				rtw_cfg80211_indicate_sta_assoc(adapter, passoc_req, assoc_req_len);
 
-				rtw_mfree(passoc_req, assoc_req_len);
+				kfree(passoc_req);
 			}			
 #endif //!CONFIG_AUTO_AP_MODE
 		}		
 		goto exit;
 	}	
-#endif //defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 	//for AD-HOC mode
 	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);	
@@ -1981,24 +1892,24 @@ _func_enter_;
 
 	psta->ieee8021x_blocked = false;		
 	
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) || 
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 	{
 		if(adapter->stapriv.asoc_sta_count== 2)
 		{
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
 			pmlmepriv->cur_network_scanned = ptarget_wlan;
 			if(ptarget_wlan)	ptarget_wlan->fixed = true;
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			// a sta + bc/mc_stainfo (not Ibss_stainfo)
 			rtw_indicate_connect(adapter);
 		}
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 	mlmeext_sta_add_event_callback(adapter, psta);
@@ -2050,7 +1961,7 @@ _func_enter_;
 
 	mlmeext_sta_del_event_callback(adapter);
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL2);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 	{
@@ -2058,7 +1969,6 @@ _func_enter_;
 		bool roam = false;
 		struct wlan_network *roam_target = NULL;
 
-		#ifdef CONFIG_LAYER2_ROAMING
 		if(adapter->registrypriv.wifi_spec==1) {
 			roam = false;
 		} else if (reason == WLAN_REASON_EXPIRATION_CHK && rtw_chk_roam_flags(adapter, RTW_ROAM_ON_EXPIRED)) {
@@ -2081,21 +1991,20 @@ _func_enter_;
 		} else {
 			rtw_set_to_roam(adapter, 0);
 		}
-		#endif /* CONFIG_LAYER2_ROAMING */
 
 		rtw_free_uc_swdec_pending_queue(adapter);
 
 		rtw_free_assoc_resources(adapter, 1);
 		rtw_indicate_disconnect(adapter);
 
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		// remove the network entry in scanned_queue
 		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);	
 		if (pwlan) {			
 			pwlan->fixed = false;
 			rtw_free_network_nolock(adapter, pwlan);
 		}
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 #ifdef CONFIG_INTEL_WIDI
 		if (!rtw_to_roam(adapter))
@@ -2109,14 +2018,14 @@ _func_enter_;
 	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 	{
 		
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(adapter,  psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 		
 		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
 		{ 
 			//rtw_indicate_disconnect(adapter);//removed@20091105
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			//free old ibss network
 			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
@@ -2125,7 +2034,7 @@ _func_enter_;
 				pwlan->fixed = false;
 				rtw_free_network_nolock(adapter, pwlan); 
 			}
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			//re-create ibss
 			pdev_network = &(adapter->registrypriv.dev_network);			
 			pibss = adapter->registrypriv.dev_network.MacAddress;
@@ -2157,7 +2066,7 @@ _func_enter_;
 		
 	}
 	
-	_exit_critical_bh(&pmlmepriv->lock, &irqL2);
+	spin_unlock_bh(&pmlmepriv->lock);
 	
 _func_exit_;	
 
@@ -2208,9 +2117,8 @@ _func_enter_;
 		return;
 
 	
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
-	#ifdef CONFIG_LAYER2_ROAMING
 	if (rtw_to_roam(adapter) > 0) { /* join timeout caused by roaming */
 		while(1) {
 			rtw_dec_to_roam(adapter);
@@ -2238,7 +2146,6 @@ _func_enter_;
 		}
 		
 	} else 
-	#endif
 	{
 		rtw_indicate_disconnect(adapter);
 		free_scanqueue(pmlmepriv);//???
@@ -2248,7 +2155,7 @@ _func_enter_;
 
  	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 	
 _func_exit_;
 
@@ -2265,11 +2172,11 @@ void rtw_scan_timeout_handler (_adapter
 	
 	DBG_871X(FUNC_ADPT_FMT" fw_state=%x\n", FUNC_ADPT_ARG(adapter), get_fwstate(pmlmepriv));
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_indicate_scan_done(adapter, true);
 }
@@ -2286,11 +2193,9 @@ void rtw_mlme_reset_auto_scan_int(_adapt
 	}
 	else if(adapter->registrypriv.wifi_spec && is_client_associated_to_ap(adapter) == true) {
 		mlme->auto_scan_int_ms = 60*1000;
-#ifdef CONFIG_LAYER2_ROAMING
 	} else if(rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {
 		if (check_fwstate(mlme, WIFI_STATION_STATE) && check_fwstate(mlme, _FW_LINKED))
 			mlme->auto_scan_int_ms = mlme->roam_scan_int_ms;
-#endif
 	} else {
 		mlme->auto_scan_int_ms = 0; /* disabled */
 	}
@@ -2410,7 +2315,6 @@ void rtw_set_scan_deny(_adapter *adapter
 	_set_timer(&mlmepriv->set_scan_deny_timer, ms);	
 }
 
-#ifdef CONFIG_LAYER2_ROAMING
 /*
 * Select a new roaming candidate from the original @param candidate and @param competitor
 * @return true: candidate is updated
@@ -2478,13 +2382,13 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&(mlme->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(mlme->scanned_queue.lock));
 	phead = get_list_head(queue);		
 	adapter = (_adapter *)mlme->nic_hdl;
 
 	mlme->pscanned = get_next(phead);
 
-	while (!rtw_end_of_queue_search(phead, mlme->pscanned)) {
+	while (phead != mlme->pscanned) {
 
 		pnetwork = LIST_CONTAINOR(mlme->pscanned, struct wlan_network, list);
 		if(pnetwork==NULL){
@@ -2522,11 +2426,10 @@ _func_enter_;
 
 	ret = _SUCCESS;
 exit:
-	_exit_critical_bh(&(mlme->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(mlme->scanned_queue.lock));
 
 	return ret;
 }
-#endif /* CONFIG_LAYER2_ROAMING */
 
 /*
 * Select a new join candidate from the original @param candidate and @param competitor
@@ -2557,15 +2460,13 @@ static int rtw_check_join_candidate(stru
 	if(rtw_is_desired_network(adapter, competitor)  == false)
 		goto exit;
 
-#ifdef  CONFIG_LAYER2_ROAMING
 	if(rtw_to_roam(adapter) > 0) {
 		if(jiffies_to_msecs(jiffies - competitor->last_scanned) >= mlme->roam_scanr_exp_ms
 			|| is_same_ess(&competitor->network, &mlme->cur_network.network) == false
 		)
 			goto exit;
 	}
-#endif
-	
+
 	if(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
 	{
 		*candidate = competitor;
@@ -2574,15 +2475,11 @@ static int rtw_check_join_candidate(stru
 
 	if(updated){
 		DBG_871X("[by_bssid:%u][assoc_ssid:%s]"
-			#ifdef  CONFIG_LAYER2_ROAMING
 			"[to_roam:%u] "
-			#endif
 			"new candidate: %s("MAC_FMT", ch%u) rssi:%d\n",
 			mlme->assoc_by_bssid,
 			mlme->assoc_ssid.Ssid,
-			#ifdef  CONFIG_LAYER2_ROAMING
 			rtw_to_roam(adapter),
-			#endif
 			(*candidate)->network.Ssid.Ssid,
 			MAC_ARG((*candidate)->network.MacAddress),
 			(*candidate)->network.Configuration.DSConfig,
@@ -2619,20 +2516,18 @@ _func_enter_;
 
 	adapter = (_adapter *)pmlmepriv->nic_hdl;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
-	#ifdef CONFIG_LAYER2_ROAMING
 	if (pmlmepriv->roam_network) {
 		candidate = pmlmepriv->roam_network;
 		pmlmepriv->roam_network = NULL;
 		goto candidate_exist;
 	}
-	#endif
 
 	phead = get_list_head(queue);
 	pmlmepriv->pscanned = get_next(phead);
 
-	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
+	while (phead != pmlmepriv->pscanned) {
 
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 		if(pnetwork==NULL){
@@ -2683,7 +2578,7 @@ candidate_exist:
 	ret = rtw_joinbss_cmd(adapter, candidate);
 	
 exit:
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 _func_exit_;
 
@@ -2707,7 +2602,7 @@ _func_enter_;
 	
 	psetauthparm=(struct setauth_parm*)rtw_zmalloc(sizeof(struct setauth_parm));
 	if(psetauthparm==NULL){
-		rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+		kfree((unsigned char *)pcmd);
 		res= _FAIL;
 		goto exit;
 	}
@@ -2722,7 +2617,7 @@ _func_enter_;
 	pcmd->rspsz = 0;
 
 
-	_rtw_init_listhead(&pcmd->list);
+	INIT_LIST_HEAD(&pcmd->list);
 
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("after enqueue set_auth_cmd, auth_mode=%x\n", psecuritypriv->dot11AuthAlgrthm));
 
@@ -2794,7 +2689,7 @@ _func_enter_;
 		default:
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",psecuritypriv->dot11PrivacyAlgrthm));
 			res= _FAIL;
-			rtw_mfree((unsigned char *)psetkeyparm, sizeof(struct setkey_parm));
+			kfree((unsigned char *)psetkeyparm);
 			goto exit;
 	}
 		
@@ -2802,7 +2697,7 @@ _func_enter_;
 	if(enqueue){
 		pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 		if(pcmd==NULL){
-			rtw_mfree((unsigned char *)psetkeyparm, sizeof(struct setkey_parm));
+			kfree((unsigned char *)psetkeyparm);
 			res= _FAIL;  //try again
 			goto exit;
 		}
@@ -2813,7 +2708,7 @@ _func_enter_;
 		pcmd->rsp = NULL;
 		pcmd->rspsz = 0;
 
-		_rtw_init_listhead(&pcmd->list);
+		INIT_LIST_HEAD(&pcmd->list);
 
 		//sema_init(&(pcmd->cmd_sem), 0);
 
@@ -2821,7 +2716,7 @@ _func_enter_;
 	}
 	else{
 		setkey_hdl(adapter, (u8 *)psetkeyparm);
-		rtw_mfree((u8 *) psetkeyparm, sizeof(struct setkey_parm));
+		kfree((u8 *) psetkeyparm);
 	}
 exit:
 _func_exit_;
@@ -3301,9 +3196,7 @@ unsigned int rtw_restructure_ht_ie(_adap
 	ht_capie.cap_info |= IEEE80211_HT_CAP_SM_PS;
 
 	if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_RX)) {
-		if((pregistrypriv->rx_stbc == 0x3) ||							/* enable for 2.4/5 GHz */
-			((channel <= 14) && (pregistrypriv->rx_stbc == 0x1)) ||	/* enable for 2.4GHz */
-			((channel > 14) && (pregistrypriv->rx_stbc == 0x2)) ||		/* enable for 5GHz */
+		if((channel <= 14 && pregistrypriv->rx_stbc == 0x1) ||	/* enable for 2.4GHz */
 			(pregistrypriv->wifi_spec == 1)) {
 			stbc_rx_enable = 1;
 			DBG_871X("declare supporting RX STBC\n");
@@ -3612,7 +3505,6 @@ void rtw_append_exented_cap(_adapter *pa
 	pframe = rtw_set_ie(out_ie+*pout_len, EID_EXTCapability, 8, cap_content , pout_len);
 }
 
-#ifdef CONFIG_LAYER2_ROAMING
 inline void rtw_set_to_roam(_adapter *adapter, u8 to_roam)
 {
 	if (to_roam == 0)
@@ -3636,9 +3528,9 @@ void rtw_roaming(_adapter *padapter, str
 	_irqL irqL;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	_rtw_roaming(padapter, tgt_network);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 {
@@ -3654,10 +3546,6 @@ void _rtw_roaming(_adapter *padapter, st
 
 		pmlmepriv->assoc_by_bssid = false;
 
-#ifdef CONFIG_WAPI_SUPPORT
-		rtw_wapi_return_all_sta_info(padapter);
-#endif
-
 		while(1) {
 			if( _SUCCESS==(do_join_r=rtw_do_join(padapter)) ) {
 				break;
@@ -3677,7 +3565,6 @@ void _rtw_roaming(_adapter *padapter, st
 	}
 	
 }
-#endif /* CONFIG_LAYER2_ROAMING */
 
 sint rtw_linked_check(_adapter *padapter)
 {
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_mlme_ext.c linux/3rdparty/rtl8723bs/core/rtw_mlme_ext.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_mlme_ext.c	2015-05-10 14:36:05.673667957 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_mlme_ext.c	2015-05-07 17:46:55.000000000 +0300
@@ -45,7 +45,6 @@ static struct mlme_handler mlme_sta_tbl[
 	{WIFI_ACTION_NOACK,"OnActionNoAck",	&OnAction},
 };
 
-#ifdef _CONFIG_NATIVEAP_MLME_
 struct mlme_handler mlme_ap_tbl[]={
 	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
 	{WIFI_ASSOCRSP,		"OnAssocRsp",	&OnAssocRsp},
@@ -67,7 +66,6 @@ struct mlme_handler mlme_ap_tbl[]={
 	{WIFI_ACTION,		"OnAction",		&OnAction},
 	{WIFI_ACTION_NOACK,"OnActionNoAck",	&OnAction},
 };
-#endif
 
 static struct action_handler OnAction_tbl[]={
 	{RTW_WLAN_CATEGORY_SPECTRUM_MGMT,	 "ACTION_SPECTRUM_MGMT", on_action_spct},
@@ -78,12 +76,7 @@ static struct action_handler OnAction_tb
 	{RTW_WLAN_CATEGORY_RADIO_MEASUREMENT, "ACTION_RADIO_MEASUREMENT", &DoReserved},
 	{RTW_WLAN_CATEGORY_FT, "ACTION_FT",	&DoReserved},
 	{RTW_WLAN_CATEGORY_HT,	"ACTION_HT",	&OnAction_ht},
-#ifdef CONFIG_IEEE80211W
 	{RTW_WLAN_CATEGORY_SA_QUERY, "ACTION_SA_QUERY", &OnAction_sa_query},
-#else
-	{RTW_WLAN_CATEGORY_SA_QUERY, "ACTION_SA_QUERY", &DoReserved},
-#endif //CONFIG_IEEE80211W
-	//add for CONFIG_IEEE80211W
 	{RTW_WLAN_CATEGORY_UNPROTECTED_WNM, "ACTION_UNPROTECTED_WNM", &DoReserved},
 	{RTW_WLAN_CATEGORY_SELF_PROTECTED, "ACTION_SELF_PROTECTED", &DoReserved},
 	{RTW_WLAN_CATEGORY_WMM, "ACTION_WMM", &DoReserved},
@@ -354,11 +347,9 @@ static void init_mlme_ext_priv_value(_ad
 
 	atomic_set(&pmlmeext->event_seq, 0);
 	pmlmeext->mgnt_seq = 0;//reset to zero when disconnect at client mode
-#ifdef CONFIG_IEEE80211W
 	pmlmeext->sa_query_seq = 0;
 	pmlmeext->mgnt_80211w_IPN=0;
 	pmlmeext->mgnt_80211w_IPN_rx=0;
-#endif //CONFIG_IEEE80211W
 	pmlmeext->cur_channel = padapter->registrypriv.channel;
 	pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
 	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -491,15 +482,6 @@ static u8 init_channel_set(_adapter* pad
 			Index2G = RTW_ChannelPlanMap[ChannelPlan].Index2G;
 	}
 
-	if(IsSupported5G(padapter->registrypriv.wireless_mode))
-	{
-		b5GBand = true;
-		if(RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
-			Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
-		else
-			Index5G = RTW_ChannelPlanMap[ChannelPlan].Index5G;
-	}
-
 	if(b2_4GBand)
 	{
 		for(index=0;index<RTW_ChannelPlan2G[Index2G].Len;index++)
@@ -561,7 +543,7 @@ int	init_mlme_ext_priv(_adapter* padapte
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc().
 	//memset((u8 *)pmlmeext, 0, sizeof(struct mlme_ext_priv));
 
 	pmlmeext->padapter = padapter;
@@ -573,9 +555,7 @@ int	init_mlme_ext_priv(_adapter* padapte
 	
 	init_mlme_ext_timer(padapter);
 
-#ifdef CONFIG_AP_MODE
 	init_mlme_ap_info(padapter);	
-#endif
 
 	pmlmeext->max_chan_nums = init_channel_set(padapter, pmlmepriv->ChannelPlan,pmlmeext->channel_set);
 	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);
@@ -630,9 +610,7 @@ void mgt_dispatcher(_adapter *padapter,
 {
 	int index;
 	struct mlme_handler *ptable;
-#ifdef CONFIG_AP_MODE
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //CONFIG_AP_MODE
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(pframe));
@@ -682,7 +660,6 @@ void mgt_dispatcher(_adapter *padapter,
 		psta->RxMgmtFrameSeqNum = precv_frame->u.hdr.attrib.seq_num;
 	}
 
-#ifdef CONFIG_AP_MODE
 	switch (GetFrameSubType(pframe)) 
 	{
 		case WIFI_AUTH:
@@ -707,16 +684,8 @@ void mgt_dispatcher(_adapter *padapter,
 			break;
 		default:
 			_mgt_dispatcher(padapter, ptable, precv_frame);	
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
-				rtw_hostapd_mlme_rx(padapter, precv_frame);			
 			break;
 	}
-#else
-
-	_mgt_dispatcher(padapter, ptable, precv_frame);	
-	
-#endif
-
 }
 
 /****************************************************************************
@@ -795,14 +764,14 @@ unsigned int OnProbeReq(_adapter *padapt
 				return _SUCCESS;
 			}
 
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-			if (rtw_is_list_empty(&psta->asoc_list))
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if (list_empty(&psta->asoc_list))
 			{
 				psta->expire_to = pstapriv->expire_to;
-				rtw_list_insert_tail(&psta->asoc_list, &pstapriv->asoc_list);
+				list_add_tail(&psta->asoc_list, &pstapriv->asoc_list);
 				pstapriv->asoc_list_cnt++;
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 			//generate pairing ID
 			mac_addr = myid(&(padapter->eeprompriv));
@@ -847,9 +816,9 @@ unsigned int OnProbeReq(_adapter *padapt
 
 			memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
 
-			_enter_critical_bh(&psta->lock, &irqL);
+			spin_lock_bh(&psta->lock);
 			psta->state |= _FW_LINKED;
-			_exit_critical_bh(&psta->lock, &irqL);
+			spin_unlock_bh(&psta->lock);
 
 			report_add_sta_event(padapter, psta->hwaddr, psta->aid);
 
@@ -961,7 +930,7 @@ unsigned int OnBeacon(_adapter *padapter
 					update_network(&(pmlmepriv->cur_network.network), pbss, padapter, true);
 					rtw_get_bcn_info(&(pmlmepriv->cur_network));
 				}
-				rtw_mfree((u8*)pbss, sizeof(WLAN_BSSID_EX));
+				kfree((u8*)pbss);
 			}
 
 			//check the vendor of the assoc AP
@@ -1049,7 +1018,6 @@ _END_ONBEACON_:
 
 unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 {
-#ifdef CONFIG_AP_MODE
 	_irqL irqL;
 	unsigned int	auth_mode, seq, ie_len;
 	unsigned char	*sa, *p;	
@@ -1143,31 +1111,31 @@ unsigned int OnAuth(_adapter *padapter,
 	else
 	{		
 
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if(rtw_is_list_empty(&pstat->asoc_list)==false)
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if(list_empty(&pstat->asoc_list)==false)
 		{			
-			rtw_list_delete(&pstat->asoc_list);
+			list_del_init(&pstat->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			if (pstat->expire_to > 0)
 			{
 				//TODO: STA re_auth within expire_to
 			}
 		}
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 		
 		if (seq==1) {
 			//TODO: STA re_auth and auth timeout 
 		}
 	}
 
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
-	if (rtw_is_list_empty(&pstat->auth_list))
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (list_empty(&pstat->auth_list))
 	{		
 
-		rtw_list_insert_tail(&pstat->auth_list, &pstapriv->auth_list);
+		list_add_tail(&pstat->auth_list, &pstapriv->auth_list);
 		pstapriv->auth_list_cnt++;
 	}	
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
 	if (pstat->auth_seq == 0)
 		pstat->expire_to = pstapriv->auth_to;
@@ -1253,10 +1221,8 @@ unsigned int OnAuth(_adapter *padapter,
 
 	// Now, we are going to issue_auth...
 	pstat->auth_seq = seq + 1;	
-	
-#ifdef CONFIG_NATIVEAP_MLME
+
 	issue_auth(padapter, pstat, (unsigned short)(_STATS_SUCCESSFUL_));
-#endif
 
 	if (pstat->state & WIFI_FW_AUTH_SUCCESS)
 		pstat->auth_seq = 0;
@@ -1273,12 +1239,9 @@ auth_fail:
 	memset((char *)pstat, '\0', sizeof(stat));
 	pstat->auth_seq = 2;
 	memcpy(pstat->hwaddr, sa, 6);	
-	
-#ifdef CONFIG_NATIVEAP_MLME
+
 	issue_auth(padapter, pstat, (unsigned short)status);	
-#endif
 
-#endif
 	return _FAIL;
 
 }
@@ -1386,7 +1349,6 @@ authclnt_fail:
 
 unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 {
-#ifdef CONFIG_AP_MODE
 	_irqL irqL;
 	u16 capab_info, listen_interval;
 	struct rtw_ieee802_11_elems elems;	
@@ -1838,27 +1800,26 @@ unsigned int OnAssocReq(_adapter *padapt
 	pstat->state &= (~WIFI_FW_ASSOC_STATE);	
 	pstat->state |= WIFI_FW_ASSOC_SUCCESS;
 	
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
-	if (!rtw_is_list_empty(&pstat->auth_list))
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!list_empty(&pstat->auth_list))
 	{
-		rtw_list_delete(&pstat->auth_list);
+		list_del_init(&pstat->auth_list);
 		pstapriv->auth_list_cnt--;
 	}
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);	
-	if (rtw_is_list_empty(&pstat->asoc_list))
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	if (list_empty(&pstat->asoc_list))
 	{
 		pstat->expire_to = pstapriv->expire_to;
-		rtw_list_insert_tail(&pstat->asoc_list, &pstapriv->asoc_list);
+		list_add_tail(&pstat->asoc_list, &pstapriv->asoc_list);
 		pstapriv->asoc_list_cnt++;
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	// now the station is qualified to join our BSS...	
 	if(pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
 	{
-#ifdef CONFIG_NATIVEAP_MLME
 		//.1 bss_cap_update & sta_info_update
 		bss_cap_update_on_sta_join(padapter, pstat);
 		sta_info_update(padapter, pstat);
@@ -1869,10 +1830,10 @@ unsigned int OnAssocReq(_adapter *padapt
 		else
 			issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
 
-		_enter_critical_bh(&pstat->lock, &irqL);
+		spin_lock_bh(&pstat->lock);
 		if(pstat->passoc_req)
 		{
-			rtw_mfree(pstat->passoc_req, pstat->assoc_req_len);
+			kfree(pstat->passoc_req);
 			pstat->passoc_req = NULL;
 			pstat->assoc_req_len = 0;
 		}
@@ -1883,40 +1844,29 @@ unsigned int OnAssocReq(_adapter *padapt
 			memcpy(pstat->passoc_req, pframe, pkt_len);
 			pstat->assoc_req_len = pkt_len;
 		}
-		_exit_critical_bh(&pstat->lock, &irqL);
+		spin_unlock_bh(&pstat->lock);
 
 		//.3-(1) report sta add event
 		report_add_sta_event(padapter, pstat->hwaddr, pstat->aid);
-	
-#endif //CONFIG_NATIVEAP_MLME
 	}
 
 	return _SUCCESS;
 
 asoc_class2_error:
 
-#ifdef CONFIG_NATIVEAP_MLME
 	issue_deauth(padapter, (void *)GetAddr2Ptr(pframe), status);
-#endif
 
 	return _FAIL;		
 
 OnAssocReqFail:
 
-
-#ifdef CONFIG_NATIVEAP_MLME
 	pstat->aid = 0;
 	if (frame_type == WIFI_ASSOCREQ)
 		issue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);
 	else
 		issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
-#endif
-
-
-#endif /* CONFIG_AP_MODE */
-
-	return _FAIL;		
 
+	return _FAIL;
 }
 
 unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame)
@@ -1981,12 +1931,6 @@ unsigned int OnAssocRsp(_adapter *padapt
 				}
 				break;
 
-#ifdef CONFIG_WAPI_SUPPORT
-			case _WAPI_IE_:
-				pWapiIE = pIE;
-				break;
-#endif
-
 			case _HT_CAPABILITY_IE_:	//HT caps
 				HT_caps_handler(padapter, pIE);
 				break;
@@ -2005,10 +1949,6 @@ unsigned int OnAssocRsp(_adapter *padapt
 		i += (pIE->Length + 2);
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_wapi_on_assoc_ok(padapter, pIE);
-#endif
-
 	pmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);
 	pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
 
@@ -2043,18 +1983,15 @@ unsigned int OnDeAuth(_adapter *padapter
 
 	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
 
-	rtw_lock_rx_suspend_timeout(8000);
-
-#ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{		
 		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 		
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//spin_lock_bh(&(pstapriv->sta_hash_lock));
 		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		DBG_871X_LEVEL(_drv_always_, "ap recv deauth reason code(%d) sta:%pM\n",
 			       	reason, GetAddr2Ptr(pframe));
@@ -2064,15 +2001,15 @@ unsigned int OnDeAuth(_adapter *padapter
 		{
 			u8 updated = false;
 		
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-			if(rtw_is_list_empty(&psta->asoc_list)==false)
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if(list_empty(&psta->asoc_list)==false)
 			{			
-				rtw_list_delete(&psta->asoc_list);
+				list_del_init(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 				updated = ap_free_sta(padapter, psta, false, reason);
 
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 			associated_clients_update(padapter, updated);
 		}
@@ -2081,7 +2018,6 @@ unsigned int OnDeAuth(_adapter *padapter
 		return _SUCCESS;
 	}
 	else
-#endif
 	{
 		int	ignore_received_deauth = 0;
 
@@ -2131,18 +2067,15 @@ unsigned int OnDisassoc(_adapter *padapt
 
         DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
 
-	rtw_lock_rx_suspend_timeout(8000);
-	
-#ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{	
 		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 		
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+		//spin_lock_bh(&(pstapriv->sta_hash_lock));
 		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		DBG_871X_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",
 				reason, GetAddr2Ptr(pframe));
@@ -2152,15 +2085,15 @@ unsigned int OnDisassoc(_adapter *padapt
 		{
 			u8 updated = false;
 			
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-			if(rtw_is_list_empty(&psta->asoc_list)==false)
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if(list_empty(&psta->asoc_list)==false)
 			{
-				rtw_list_delete(&psta->asoc_list);
+				list_del_init(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 				updated = ap_free_sta(padapter, psta, false, reason);
 			
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 			associated_clients_update(padapter, updated);
 		}
@@ -2168,7 +2101,6 @@ unsigned int OnDisassoc(_adapter *padapt
 		return _SUCCESS;
 	}
 	else
-#endif
 	{
 		DBG_871X_LEVEL(_drv_always_, "sta recv disassoc reason code(%d) sta:%pM\n",
 				reason, GetAddr3Ptr(pframe));
@@ -2500,7 +2432,6 @@ exit:
 	return _SUCCESS;
 }
 
-#ifdef CONFIG_IEEE80211W
 unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame)
 {
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -2537,7 +2468,6 @@ unsigned int OnAction_sa_query(_adapter
 	
 	return _SUCCESS;
 }
-#endif //CONFIG_IEEE80211W
 
 unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame)
 {
@@ -2608,12 +2538,6 @@ inline struct xmit_frame *alloc_mgtxmitf
 	return _alloc_mgtxmitframe(pxmitpriv, false);
 }
 
-inline struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv)
-{
-	return _alloc_mgtxmitframe(pxmitpriv, true);
-}
-
-
 /****************************************************************************
 
 Following are some TX fuctions for WiFi MLME
@@ -2715,9 +2639,9 @@ s32 dump_mgntframe_and_wait(_adapter *pa
 	if (ret == _SUCCESS)
 		ret = rtw_sctx_wait(&sctx, __func__);
 
-	_enter_critical(&pxmitpriv->lock_sctx, &irqL);
+	spin_lock_irqsave(&pxmitpriv->lock_sctx, irqL);
 	pxmitbuf->sctx = NULL;
-	_exit_critical(&pxmitpriv->lock_sctx, &irqL);
+	spin_unlock_irqrestore(&pxmitpriv->lock_sctx, irqL);
 
 	 return ret;
 }
@@ -2737,16 +2661,17 @@ s32 dump_mgntframe_and_wait_ack(_adapter
 		return -1;
 	}
 
-	_enter_critical_mutex(&pxmitpriv->ack_tx_mutex, NULL);
-	pxmitpriv->ack_tx = true;
-	pxmitpriv->seq_no = seq_no++;
-	pmgntframe->ack_report = 1;
-	if (rtw_hal_mgnt_xmit(padapter, pmgntframe) == _SUCCESS) {
-		ret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);
-	}
+	if (mutex_lock_interruptible(&pxmitpriv->ack_tx_mutex) == 0) {
+		pxmitpriv->ack_tx = true;
+		pxmitpriv->seq_no = seq_no++;
+		pmgntframe->ack_report = 1;
+		if (rtw_hal_mgnt_xmit(padapter, pmgntframe) == _SUCCESS) {
+			ret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);
+		}
 
-	pxmitpriv->ack_tx = false;
-	_exit_critical_mutex(&pxmitpriv->ack_tx_mutex, NULL);
+		pxmitpriv->ack_tx = false;
+		mutex_unlock(&pxmitpriv->ack_tx_mutex);
+	}
 
 	 return ret;
 }
@@ -2798,10 +2723,8 @@ void issue_beacon(_adapter *padapter, in
 	unsigned short *fctrl;
 	unsigned int	rate_len;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	_irqL irqL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
@@ -2814,9 +2737,8 @@ void issue_beacon(_adapter *padapter, in
 		DBG_871X("%s, alloc mgnt frame fail\n", __FUNCTION__);
 		return;
 	}
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
 
 	//update attribute
 	pattrib = &pmgntframe->attrib;
@@ -2932,11 +2854,9 @@ void issue_beacon(_adapter *padapter, in
 
 _issue_bcn:
 
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	pmlmepriv->update_bcn = false;
-	
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);	
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
 
 	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
 	{
@@ -2963,11 +2883,10 @@ void issue_probersp(_adapter *padapter,
 	unsigned short				*fctrl;	
 	unsigned char					*mac, *bssid;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+
 	u8 *pwps_ie;
 	uint wps_ielen;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
@@ -3015,7 +2934,6 @@ void issue_probersp(_adapter *padapter,
 	if(cur_network->IELength>MAX_IE_SZ)
 		return;
 	
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
@@ -3091,11 +3009,9 @@ void issue_probersp(_adapter *padapter,
 				pattrib->pktlen += ssid_ielen_diff;
 			}
 		}
-	}	
-	else		
-#endif		
+	}
+	else
 	{
-	
 		//timestamp will be inserted by hardware
 		pframe += 8;
 		pattrib->pktlen += 8;
@@ -3387,13 +3303,10 @@ void issue_auth(_adapter *padapter, stru
 
 	if(psta)// for AP mode
 	{
-#ifdef CONFIG_NATIVEAP_MLME
-
 		memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);		
 		memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 		memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
-	
 		// setting auth algo number
 		val16 = (u16)psta->authalg;
 
@@ -3422,7 +3335,6 @@ void issue_auth(_adapter *padapter, stru
 		{
 			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));
 		}
-#endif
 	}
 	else
 	{		
@@ -3493,7 +3405,6 @@ void issue_auth(_adapter *padapter, stru
 
 void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type)
 {
-#ifdef CONFIG_AP_MODE
 	struct xmit_frame	*pmgntframe;
 	struct rtw_ieee80211_hdr	*pwlanhdr;
 	struct pkt_attrib *pattrib;
@@ -3634,8 +3545,6 @@ void issue_asocrsp(_adapter *padapter, u
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	
 	dump_mgntframe(padapter, pmgntframe);
-	
-#endif
 }
 
 void issue_assocreq(_adapter *padapter)
@@ -3827,10 +3736,6 @@ void issue_assocreq(_adapter *padapter)
 	}
 
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_build_assoc_req_wapi_ie(padapter, pframe, pattrib);
-#endif
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(padapter, pmgntframe);
 
@@ -4262,71 +4167,6 @@ exit:
 	return ret;
 }
 
-void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset)
-{	
-	_irqL	irqL;
-	_list		*plist, *phead;
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char				*pframe;
-	struct rtw_ieee80211_hdr	*pwlanhdr;
-	unsigned short			*fctrl;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-
-	DBG_871X(FUNC_NDEV_FMT" ra="MAC_FMT", ch:%u, offset:%u\n",
-		FUNC_NDEV_ARG(padapter->pnetdev), MAC_ARG(ra), new_ch, ch_offset);
-
-	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
-		return;
-
-	//update attribute
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_ctl);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, ra, ETH_ALEN); /* RA */
-	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN); /* TA */
-	memcpy(pwlanhdr->addr3, ra, ETH_ALEN); /* DA = RA */
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
-
-	/* category, action */
-	{
-		u8 category, action;
-		category = RTW_WLAN_CATEGORY_SPECTRUM_MGMT;
-		action = RTW_WLAN_ACTION_SPCT_CHL_SWITCH;
-
-		pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-		pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	}
-
-	pframe = rtw_set_ie_ch_switch(pframe, &(pattrib->pktlen), 0, new_ch, 0);
-	pframe = rtw_set_ie_secondary_ch_offset(pframe, &(pattrib->pktlen),
-		hal_ch_offset_to_secondary_ch_offset(ch_offset));
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-
-}
-
-#ifdef CONFIG_IEEE80211W
 void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid)
 {
 	u8	category = RTW_WLAN_CATEGORY_SA_QUERY;
@@ -4402,7 +4242,6 @@ void issue_action_SA_Query(_adapter *pad
 
 	dump_mgntframe(padapter, pmgntframe);
 }
-#endif //CONFIG_IEEE80211W
 
 void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status)
 {
@@ -4658,7 +4497,7 @@ static void issue_action_BSSCoexistPacke
 	{	
 		int i;
 	
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 		phead = get_list_head(queue);
 		plist = get_next(phead);
@@ -4669,7 +4508,7 @@ static void issue_action_BSSCoexistPacke
 			u8 *p;
 			WLAN_BSSID_EX *pbss_network;
 	
-			if (rtw_end_of_queue_search(phead,plist)== true)
+			if (phead == plist)
 				break;		
 
 			pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);      
@@ -4692,7 +4531,7 @@ static void issue_action_BSSCoexistPacke
 	
 		}        
 
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 
 		for(i= 0;i<8;i++)
@@ -4839,22 +4678,6 @@ Following are some utitity fuctions for
 
 *****************************************************************************/
 
-bool IsLegal5GChannel(
-	IN PADAPTER			Adapter,
-	IN u8			channel)
-{
-	
-	int i=0;
-	u8 Channel_5G[45] = {36,38,40,42,44,46,48,50,52,54,56,58,
-		60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,
-		124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,
-		161,163,165};
-	for(i=0;i<sizeof(Channel_5G);i++)
-		if(channel == Channel_5G[i])
-			return true;
-	return false;
-}
-
 void site_survey(_adapter *padapter)
 {
 	unsigned char		survey_channel = 0, val8;
@@ -5294,13 +5117,6 @@ void start_clnt_join(_adapter* padapter)
 
 		val8 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
 
-#ifdef CONFIG_WAPI_SUPPORT
-		if (padapter->wapiInfo.bWapiEnable && pmlmeinfo->auth_algo == dot11AuthAlgrthm_WAPI)
-		{
-			//Disable TxUseDefaultKey, RxUseDefaultKey, RxBroadcastUseDefaultKey.
-			val8 = 0x4c;
-		}
-#endif
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));
 
 		// Because of AP's not receiving deauth before
@@ -5413,7 +5229,6 @@ unsigned int receive_disconnect(_adapter
 	return _SUCCESS;
 }
 
-#ifdef CONFIG_80211D
 static void process_80211d(PADAPTER padapter, WLAN_BSSID_EX *bssid)
 {
 	struct registry_priv *pregistrypriv;
@@ -5678,7 +5493,6 @@ static void process_80211d(PADAPTER pada
 		i++;
 	}
 }
-#endif
 
 /****************************************************************************
 
@@ -5713,11 +5527,11 @@ void report_survey_event(_adapter *padap
 	cmdsz = (sizeof(struct survey_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -5735,14 +5549,12 @@ void report_survey_event(_adapter *padap
 
 	if (collect_bss_info(padapter, precv_frame, (WLAN_BSSID_EX *)&psurvey_evt->bss) == _FAIL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
-		rtw_mfree((u8 *)pevtcmd, cmdsz);
+		kfree((u8 *)pcmd_obj);
+		kfree((u8 *)pevtcmd);
 		return;
 	}
 
-#ifdef CONFIG_80211D
 	process_80211d(padapter, &psurvey_evt->bss);
-#endif
 
 	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
 
@@ -5770,11 +5582,11 @@ void report_surveydone_event(_adapter *p
 	cmdsz = (sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -5818,11 +5630,11 @@ void report_join_res(_adapter *padapter,
 	cmdsz = (sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -5871,11 +5683,11 @@ void report_wmm_edca_update(_adapter *pa
 	cmdsz = (sizeof(struct wmm_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -5918,11 +5730,11 @@ void report_del_sta_event(_adapter *pada
 	cmdsz = (sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -5974,11 +5786,11 @@ void report_add_sta_event(_adapter *pada
 	cmdsz = (sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header));
 	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
 	{
-		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		kfree((u8 *)pcmd_obj);
 		return;
 	}
 
-	_rtw_init_listhead(&pcmd_obj->list);
+	INIT_LIST_HEAD(&pcmd_obj->list);
 
 	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
 	pcmd_obj->cmdsz = cmdsz;
@@ -6075,9 +5887,9 @@ void update_sta_info(_adapter *padapter,
 
 	update_ldpc_stbc_cap(psta);
 
-	_enter_critical_bh(&psta->lock, &irqL);
+	spin_lock_bh(&psta->lock);
 	psta->state = _FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL);
+	spin_unlock_bh(&psta->lock);
 
 }
 
@@ -6335,10 +6147,10 @@ void _linked_info_dump(_adapter *padapte
 			struct sta_info *psta=NULL;	
 			struct sta_priv *pstapriv = &padapter->stapriv;
 			
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);	
+			spin_lock_bh(&pstapriv->asoc_list_lock);
 			phead = &pstapriv->asoc_list;
 			plist = get_next(phead);
-			while ((rtw_end_of_queue_search(phead, plist)) == false)
+			while (phead != plist)
 			{
 				psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 				plist = get_next(plist);			
@@ -6346,7 +6158,7 @@ void _linked_info_dump(_adapter *padapte
 				DBG_871X("STA[" MAC_FMT "]:UndecoratedSmoothedPWDB:%d\n", 
 					MAC_ARG(psta->hwaddr),psta->rssi_stat.UndecoratedSmoothedPWDB);
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);		
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 			
 		}
 		for(i=0; i<NUM_STA; i++)
@@ -6573,7 +6385,7 @@ void survey_timer_hdl(_adapter *padapter
 
 		if ((psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm))) == NULL)
 		{
-			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+			kfree((unsigned char *)ph2c);
 			goto exit_survey_timer_hdl;
 		}
 
@@ -6661,14 +6473,13 @@ void addba_timer_hdl(struct sta_info *ps
 	}
 }
 
-#ifdef CONFIG_IEEE80211W
 void sa_query_timer_hdl(_adapter *padapter)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_priv * pmlmepriv = &padapter->mlmepriv;
 	_irqL irqL;
 	//disconnect
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
@@ -6677,10 +6488,9 @@ void sa_query_timer_hdl(_adapter *padapt
 		rtw_free_assoc_resources(padapter, 1);	
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 	DBG_871X("SA query timeout disconnect\n");
 }
-#endif //CONFIG_IEEE80211W
 
 u8 NULL_hdl(_adapter *padapter, u8 *pbuf)
 {
@@ -6688,15 +6498,6 @@ u8 NULL_hdl(_adapter *padapter, u8 *pbuf
 }
 
 #ifdef CONFIG_AUTO_AP_MODE
-void rtw_start_auto_ap(_adapter *adapter)
-{
-	DBG_871X("%s\n", __FUNCTION__);
-
-	rtw_set_802_11_infrastructure_mode(adapter, Ndis802_11APMode);
-
-	rtw_setopmode_cmd(adapter, Ndis802_11APMode,true);
-}
-
 static int rtw_auto_ap_start_beacon(_adapter *adapter)
 {
 	int ret=0;
@@ -6792,7 +6593,7 @@ static int rtw_auto_ap_start_beacon(_ada
 	}
 
 
-	rtw_mfree(pbuf, len);
+	kfree(pbuf);
 
 	return ret;
 
@@ -6810,9 +6611,7 @@ u8 setopmode_hdl(_adapter *padapter, u8
 	{
 		pmlmeinfo->state = WIFI_FW_AP_STATE;
 		type = _HW_STATE_AP_;
-#ifdef CONFIG_NATIVEAP_MLME
 		//start_ap_mode(padapter);
-#endif
 	}
 	else if(psetop->mode == Ndis802_11Infrastructure)
 	{
@@ -6869,14 +6668,12 @@ u8 createbss_hdl(_adapter *padapter, u8
 	WLAN_BSSID_EX	*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
 	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
 	//u32	initialgain;
-	
-#ifdef CONFIG_AP_MODE
+
 	if (pmlmeinfo->state == WIFI_FW_AP_STATE) {
 		WLAN_BSSID_EX *network = &padapter->mlmepriv.cur_network.network;
 		start_bss_network(padapter, (u8*)network);
 		return H2C_SUCCESS;
 	}
-#endif
 
 	//below is for ad-hoc master
 	if(pparm->network.InfrastructureMode == Ndis802_11IBSS)
@@ -6959,10 +6756,6 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, NULL);
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_wapi_clear_all_cam_entry(padapter);
-#endif
-
 	rtw_joinbss_reset(padapter);
 	
 	pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
@@ -7297,10 +7090,8 @@ u8 setkey_hdl(_adapter *padapter, u8 *pb
 			,cam_id, MAC_ARG(addr), pparm->keyid, security_type_str(pparm->algorithm));
 	}
 
-	#ifdef DYNAMIC_CAMID_ALLOC
 	if (cam_id >=0 && cam_id <=3)
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)true);
-	#endif
 
 	//allow multicast packets to driver
 	padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_ON_RCR_AM, null_addr);
@@ -7427,7 +7218,7 @@ _func_enter_;
 
 	if ((ptxBeacon_parm = (struct Tx_Beacon_param *)rtw_zmalloc(sizeof(struct Tx_Beacon_param))) == NULL)
 	{
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
+		kfree((unsigned char *)ph2c);
 		res= _FAIL;
 		goto exit;
 	}
@@ -7531,7 +7322,6 @@ u8 h2c_msg_hdl(_adapter *padapter, unsig
 
 u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf)
 {
-#ifdef CONFIG_AP_MODE
 	_irqL irqL;
 	struct sta_info *psta_bmc;
 	_list	*xmitframe_plist, *xmitframe_phead;
@@ -7548,19 +7338,19 @@ u8 chk_bmc_sleepq_hdl(_adapter *padapter
 	{
 		msleep(10);// 10ms, ATIM(HIQ) Windows
 
-		//_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-		_enter_critical_bh(&pxmitpriv->lock, &irqL);
+		//spin_lock_bh(&psta_bmc->sleep_q.lock);
+		spin_lock_bh(&pxmitpriv->lock);
 
 		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 		xmitframe_plist = get_next(xmitframe_phead);
 
-		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+		while (xmitframe_phead != xmitframe_plist)
 		{
 			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 			xmitframe_plist = get_next(xmitframe_plist);
 
-			rtw_list_delete(&pxmitframe->list);
+			list_del_init(&pxmitframe->list);
 
 			psta_bmc->sleepq_len--;
 			if(psta_bmc->sleepq_len>0)
@@ -7576,13 +7366,12 @@ u8 chk_bmc_sleepq_hdl(_adapter *padapter
 			rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 		}
 
-		//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-		_exit_critical_bh(&pxmitpriv->lock, &irqL);
+		//spin_unlock_bh(&psta_bmc->sleep_q.lock);
+		spin_unlock_bh(&pxmitpriv->lock);
 
 		/* check hi queue and bmc_sleepq */
 		rtw_chk_hi_queue_cmd(padapter);
 	}
-#endif
 
 	return H2C_SUCCESS;
 }
@@ -7601,58 +7390,6 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 	return H2C_SUCCESS;
 }
 
-void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork)
-{
-	u8	network_type,rate_len, total_rate_len,remainder_rate_len;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8	erpinfo=0x4;
-
-	//DBG_871X("%s\n", __FUNCTION__);
-
-	if(pmlmeext->cur_channel >= 36)
-	{
-		network_type = WIRELESS_11A;
-		total_rate_len = IEEE80211_NUM_OFDM_RATESLEN;
-		DBG_871X("%s(): change to 5G Band\n",__FUNCTION__);
-		rtw_remove_bcn_ie(padapter, pnetwork, _ERPINFO_IE_);
-	}
-	else
-	{
-		network_type = WIRELESS_11BG;
-		total_rate_len = IEEE80211_CCK_RATE_LEN+IEEE80211_NUM_OFDM_RATESLEN;
-		DBG_871X("%s(): change to 2.4G Band\n",__FUNCTION__);
-		rtw_add_bcn_ie(padapter, pnetwork, _ERPINFO_IE_, &erpinfo, 1);
-	}
-
-	rtw_set_supported_rate(pnetwork->SupportedRates, network_type);
-
-	UpdateBrateTbl(padapter, pnetwork->SupportedRates);
-	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);
-
-	if(total_rate_len > 8)
-	{
-		rate_len = 8;
-		remainder_rate_len = total_rate_len - 8;
-	}
-	else
-	{
-		rate_len = total_rate_len;
-		remainder_rate_len = 0;
-	}
-
-	rtw_add_bcn_ie(padapter, pnetwork, _SUPPORTEDRATES_IE_, pnetwork->SupportedRates, rate_len);
-
-	if(remainder_rate_len)
-	{
-		rtw_add_bcn_ie(padapter, pnetwork, _EXT_SUPPORTEDRATES_IE_, (pnetwork->SupportedRates+8), remainder_rate_len);
-	}
-	else
-	{
-		rtw_remove_bcn_ie(padapter, pnetwork, _EXT_SUPPORTEDRATES_IE_);
-	}
-}
-
 int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_pwrctrl.c linux/3rdparty/rtl8723bs/core/rtw_pwrctrl.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_pwrctrl.c	2015-05-10 14:36:05.674667968 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_pwrctrl.c	2015-05-07 17:46:55.000000000 +0300
@@ -24,53 +24,6 @@
 #include <linux/jiffies.h>
 
 
-int rtw_fw_ps_state(PADAPTER padapter)
-{
-	struct dvobj_priv *psdpriv = padapter->dvobj;
-	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
-	int ret=_FAIL, dont_care=0;
-	u16 fw_ps_state=0;
-	u32 start_time;
-	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
-	struct registry_priv  *registry_par = &padapter->registrypriv;
-	
-	if(registry_par->check_fw_ps != 1)
-		return _SUCCESS;
-	
-	down(&pwrpriv->check_32k_lock);
-	
-	if ((padapter->bSurpriseRemoved == true))
-	{
-		DBG_871X("%s: bSurpriseRemoved=%d , hw_init_completed=%d, bDriverStopped=%d \n", __FUNCTION__, padapter->bSurpriseRemoved,
-		padapter->hw_init_completed,padapter->bDriverStopped);
-		goto exit_fw_ps_state;
-	}
-	rtw_hal_set_hwreg(padapter, HW_VAR_SET_REQ_FW_PS, (u8 *)&dont_care);
-	{
-		//4. if 0x88[7]=1, driver set cmd to leave LPS/IPS. 
-		//Else, hw will keep in active mode.
-		//debug info:
-		//0x88[7] = 32kpermission, 
-		//0x88[6:0] = current_ps_state
-		//0x89[7:0] = last_rpwm
-
-		rtw_hal_get_hwreg(padapter, HW_VAR_FW_PS_STATE, (u8 *)&fw_ps_state);
-		
-		if((fw_ps_state & 0x80) == 0)
-			ret=_SUCCESS;
-		else
-		{
-			pdbgpriv->dbg_poll_fail_cnt++;
-			DBG_871X("%s: fw_ps_state=%04x \n", __FUNCTION__, fw_ps_state);
-		}
-	}
-
-
-exit_fw_ps_state:
-	up(&pwrpriv->check_32k_lock);
-	return ret;
-}
-
 void _ips_enter(_adapter * padapter)
 {
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
@@ -152,9 +105,6 @@ int ips_leave(_adapter * padapter)
 	up(&pwrpriv->lock);
 
 	if (_SUCCESS == ret)
-		ODM_DMReset(&GET_HAL_DATA(padapter)->odmpriv);
-
-	if (_SUCCESS == ret)
 		rtw_btcoex_IpsNotify(padapter, IPS_NONE);
 
 	return ret;
@@ -1264,68 +1214,6 @@ _func_exit_;
 }
 
 /*
- * Caller: rx_isr
- *
- * Calling Context: Dispatch/ISR
- *
- * Return Value:
- *	_SUCCESS
- *	_FAIL
- */
-s32 rtw_register_rx_alive(PADAPTER padapter)
-{
-	struct pwrctrl_priv *pwrctrl;
-
-_func_enter_;
-
-	pwrctrl = adapter_to_pwrctl(padapter);
-
-	down(&pwrctrl->lock);
-
-	register_task_alive(pwrctrl, RECV_ALIVE);
-	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
-			 ("rtw_register_rx_alive: cpwm=0x%02x alives=0x%08x\n",
-			  pwrctrl->cpwm, pwrctrl->alives));
-
-	up(&pwrctrl->lock);
-
-_func_exit_;
-
-	return _SUCCESS;
-}
-
-/*
- * Caller: evt_isr or evt_thread
- *
- * Calling Context: Dispatch/ISR or Passive
- *
- * Return Value:
- *	_SUCCESS
- *	_FAIL
- */
-s32 rtw_register_evt_alive(PADAPTER padapter)
-{
-	struct pwrctrl_priv *pwrctrl;
-
-_func_enter_;
-
-	pwrctrl = adapter_to_pwrctl(padapter);
-
-	down(&pwrctrl->lock);
-
-	register_task_alive(pwrctrl, EVT_ALIVE);
-	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
-			 ("rtw_register_evt_alive: cpwm=0x%02x alives=0x%08x\n",
-			  pwrctrl->cpwm, pwrctrl->alives));
-
-	up(&pwrctrl->lock);
-
-_func_exit_;
-
-	return _SUCCESS;
-}
-
-/*
  * Caller: ISR
  *
  * If ISR's txdone,
@@ -1425,49 +1313,6 @@ _func_enter_;
 _func_exit_;
 }
 
-/*
- * Caller: ISR
- */
-void rtw_unregister_rx_alive(PADAPTER padapter)
-{
-	struct pwrctrl_priv *pwrctrl;
-
-_func_enter_;
-
-	pwrctrl = adapter_to_pwrctl(padapter);
-
-	down(&pwrctrl->lock);
-
-	unregister_task_alive(pwrctrl, RECV_ALIVE);
-
-	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
-			 ("rtw_unregister_rx_alive: cpwm=0x%02x alives=0x%08x\n",
-			  pwrctrl->cpwm, pwrctrl->alives));
-
-	up(&pwrctrl->lock);
-
-_func_exit_;
-}
-
-void rtw_unregister_evt_alive(PADAPTER padapter)
-{
-	struct pwrctrl_priv *pwrctrl;
-
-_func_enter_;
-
-	pwrctrl = adapter_to_pwrctl(padapter);
-
-	unregister_task_alive(pwrctrl, EVT_ALIVE);
-
-	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
-			 ("rtw_unregister_evt_alive: cpwm=0x%02x alives=0x%08x\n",
-			  pwrctrl->cpwm, pwrctrl->alives));
-
-	up(&pwrctrl->lock);
-
-_func_exit_;
-}
-
 void rtw_init_pwrctrl_priv(PADAPTER padapter)
 {
 	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
@@ -1558,15 +1403,6 @@ _func_enter_;
 _func_exit_;
 }
 
-u8 rtw_interface_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id,u8* val)
-{
-	u8 bResult = true;
-	rtw_hal_intf_ps_func(padapter,efunc_id,val);
-	
-	return bResult;
-}
-
-
 inline void rtw_set_ips_deny(_adapter *padapter, u32 ms)
 {
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_recv.c linux/3rdparty/rtl8723bs/core/rtw_recv.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_recv.c	2015-05-10 14:36:05.676667990 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_recv.c	2015-05-07 17:46:55.000000000 +0300
@@ -53,7 +53,7 @@ sint _rtw_init_recv_priv(struct recv_pri
 
 _func_enter_;
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc().
 	//memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));
 
 	spin_lock_init(&precvpriv->lock);
@@ -66,9 +66,7 @@ _func_enter_;
 
 	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
 
-	rtw_os_recv_resource_init(precvpriv, padapter);
-
-	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	precvpriv->pallocated_frame_buf = vzalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
 	
 	if(precvpriv->pallocated_frame_buf==NULL){
 		res= _FAIL;
@@ -85,9 +83,9 @@ _func_enter_;
 
 	for(i=0; i < NR_RECVFRAME ; i++)
 	{
-		_rtw_init_listhead(&(precvframe->u.list));
+		INIT_LIST_HEAD(&(precvframe->u.list));
 
-		rtw_list_insert_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));
+		list_add_tail(&(precvframe->u.list), &(precvpriv->free_recv_queue.queue));
 
 		res = rtw_os_recv_resource_alloc(padapter, precvframe);
 
@@ -126,7 +124,7 @@ _func_enter_;
 	rtw_os_recv_resource_free(precvpriv);
 
 	if(precvpriv->pallocated_frame_buf) {
-		rtw_vmfree(precvpriv->pallocated_frame_buf, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+		vfree(precvpriv->pallocated_frame_buf);
 	}
 
 	rtw_hal_free_recv_priv(padapter);
@@ -144,7 +142,7 @@ union recv_frame *_rtw_alloc_recvframe (
 	struct recv_priv *precvpriv;
 _func_enter_;
 
-	if(_rtw_queue_empty(pfree_recv_queue) == true)
+	if(list_empty(&pfree_recv_queue->queue))
 	{
 		precvframe = NULL;
 	}
@@ -156,7 +154,7 @@ _func_enter_;
 
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 
-		rtw_list_delete(&precvframe->u.hdr.list);
+		list_del_init(&precvframe->u.hdr.list);
 		padapter=precvframe->u.hdr.adapter;
 		if(padapter !=NULL){
 			precvpriv=&padapter->recvpriv;
@@ -176,23 +174,15 @@ union recv_frame *rtw_alloc_recvframe (_
 	_irqL irqL;
 	union recv_frame  *precvframe;
 	
-	_enter_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_lock_bh(&pfree_recv_queue->lock);
 
 	precvframe = _rtw_alloc_recvframe(pfree_recv_queue);
 
-	_exit_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_unlock_bh(&pfree_recv_queue->lock);
 
 	return precvframe;
 }
 
-void rtw_init_recvframe(union recv_frame *precvframe, struct recv_priv *precvpriv)
-{
-	/* Perry: This can be removed */
-	_rtw_init_listhead(&precvframe->u.hdr.list);
-
-	precvframe->u.hdr.len=0;
-}
-
 int rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue)
 {
 	_irqL irqL;
@@ -204,20 +194,20 @@ _func_enter_;
 	rtw_os_free_recvframe(precvframe);
 
 
-	_enter_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_lock_bh(&pfree_recv_queue->lock);
 
-	rtw_list_delete(&(precvframe->u.hdr.list));
+	list_del_init(&(precvframe->u.hdr.list));
 
 	precvframe->u.hdr.len = 0;
 
-	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
+	list_add_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
 
 	if(padapter !=NULL){
 		if(pfree_recv_queue == &precvpriv->free_recv_queue)
 				precvpriv->free_recvframe_cnt++;
 	}
 
-      _exit_critical_bh(&pfree_recv_queue->lock, &irqL);
+      spin_unlock_bh(&pfree_recv_queue->lock);
 
 _func_exit_;
 
@@ -236,11 +226,11 @@ sint _rtw_enqueue_recvframe(union recv_f
 
 _func_enter_;
 
-	//_rtw_init_listhead(&(precvframe->u.hdr.list));
-	rtw_list_delete(&(precvframe->u.hdr.list));
+	//INIT_LIST_HEAD(&(precvframe->u.hdr.list));
+	list_del_init(&(precvframe->u.hdr.list));
 
 
-	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(queue));
+	list_add_tail(&(precvframe->u.hdr.list), get_list_head(queue));
 
 	if (padapter != NULL) {
 		if (queue == &precvpriv->free_recv_queue)
@@ -258,10 +248,10 @@ sint rtw_enqueue_recvframe(union recv_fr
 	_irqL irqL;
 	
 	//_spinlock(&pfree_recv_queue->lock);
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 	ret = _rtw_enqueue_recvframe(precvframe, queue);
 	//spin_unlock(&pfree_recv_queue->lock);
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	return ret;
 }
@@ -295,13 +285,13 @@ _func_enter_;
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while(rtw_end_of_queue_search(phead, plist) == false)
+	while(phead != plist)
 	{
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 
 		plist = get_next(plist);
 
-		//rtw_list_delete(&precvframe->u.hdr.list); // will do this in rtw_free_recvframe()
+		//list_del_init(&precvframe->u.hdr.list); // will do this in rtw_free_recvframe()
 
 		rtw_free_recvframe(precvframe, pfree_recv_queue);
 	}
@@ -332,12 +322,12 @@ sint rtw_enqueue_recvbuf_to_head(struct
 {
 	_irqL irqL;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	rtw_list_delete(&precvbuf->list);
-	rtw_list_insert_head(&precvbuf->list, get_list_head(queue));
+	list_del_init(&precvbuf->list);
+	list_add(&precvbuf->list, get_list_head(queue));
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	return _SUCCESS;
 }
@@ -345,12 +335,12 @@ sint rtw_enqueue_recvbuf_to_head(struct
 sint rtw_enqueue_recvbuf(struct recv_buf *precvbuf, _queue *queue)
 {
 	_irqL irqL;	
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	rtw_list_delete(&precvbuf->list);
+	list_del_init(&precvbuf->list);
 
-	rtw_list_insert_tail(&precvbuf->list, get_list_head(queue));
-	_exit_critical_bh(&queue->lock, &irqL);
+	list_add_tail(&precvbuf->list, get_list_head(queue));
+	spin_unlock_bh(&queue->lock);
 	return _SUCCESS;
 	
 }
@@ -361,9 +351,9 @@ struct recv_buf *rtw_dequeue_recvbuf (_q
 	struct recv_buf *precvbuf;
 	_list	*plist, *phead;	
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	if(_rtw_queue_empty(queue) == true)
+	if(list_empty(&queue->queue))
 	{
 		precvbuf = NULL;
 	}
@@ -375,11 +365,11 @@ struct recv_buf *rtw_dequeue_recvbuf (_q
 
 		precvbuf = LIST_CONTAINOR(plist, struct recv_buf, list);
 
-		rtw_list_delete(&precvbuf->list);
+		list_del_init(&precvbuf->list);
 		
 	}
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	return precvbuf;
 
@@ -597,12 +587,6 @@ _func_enter_;
 			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_aes);
 			res = rtw_aes_decrypt(padapter, (u8 * )precv_frame);
 			break;
-#ifdef CONFIG_WAPI_SUPPORT
-		case _SMS4_:
-			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_wapi);
-			rtw_sms4_decrypt(padapter, (u8 * )precv_frame);
-			break;
-#endif
 		default:
 				break;
 		}
@@ -783,7 +767,6 @@ _func_exit_;
 void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame);
 void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame)
 {
-#ifdef CONFIG_AP_MODE
 	unsigned char pwrbit;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
@@ -822,14 +805,11 @@ void process_pwrbit_data(_adapter *padap
 		}
 
 	}
-
-#endif
 }
 
 void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame);
 void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame)
 {
-#ifdef CONFIG_AP_MODE		
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *psta=NULL;
@@ -882,12 +862,7 @@ void process_wmmps_data(_adapter *padapt
 				issue_qos_nulldata(padapter, psta->hwaddr, (u16)pattrib->priority, 0, 0);
 			}
 		}
-				
 	}
-
-	
-#endif	
-
 }
 
 void count_rx_stats(_adapter *padapter, union recv_frame *prframe, struct sta_info*sta);
@@ -1320,7 +1295,6 @@ sint validate_recv_ctrl_frame(_adapter *
 	//only handle ps-poll
 	if(GetFrameSubType(pframe) == WIFI_PSPOLL)
 	{
-#ifdef CONFIG_AP_MODE
 		u16 aid;
 		u8 wmmps_ac=0;	
 	
@@ -1368,19 +1342,19 @@ sint validate_recv_ctrl_frame(_adapter *
 			struct xmit_frame *pxmitframe=NULL;
 			struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 		
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-			_enter_critical_bh(&pxmitpriv->lock, &irqL);
+			//spin_lock_bh(&psta->sleep_q.lock);
+			spin_lock_bh(&pxmitpriv->lock);
 
 			xmitframe_phead = get_list_head(&psta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
 
-			if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+			if (xmitframe_phead != xmitframe_plist)
 			{			
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 				xmitframe_plist = get_next(xmitframe_plist);
 
-				rtw_list_delete(&pxmitframe->list);
+				list_del_init(&pxmitframe->list);
 
 				psta->sleepq_len--;
 
@@ -1406,14 +1380,14 @@ sint validate_recv_ctrl_frame(_adapter *
 					update_beacon(padapter, _TIM_IE_, NULL, true);
 				}
 				
-				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-				_exit_critical_bh(&pxmitpriv->lock, &irqL);
+				//spin_unlock_bh(&psta->sleep_q.lock);
+				spin_unlock_bh(&pxmitpriv->lock);
 				
 			}
 			else
 			{
-				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-				_exit_critical_bh(&pxmitpriv->lock, &irqL);
+				//spin_unlock_bh(&psta->sleep_q.lock);
+				spin_unlock_bh(&pxmitpriv->lock);
 			
 				//DBG_871X("no buffered packets to xmit\n");
 				if(pstapriv->tim_bitmap&BIT(psta->aid))
@@ -1439,7 +1413,6 @@ sint validate_recv_ctrl_frame(_adapter *
 				}
 			}				
 		}
-#endif //CONFIG_AP_MODE
 	}
 
 	return _FAIL;
@@ -1640,7 +1613,6 @@ _func_exit_;
 	return ret;
 }
 
-#ifdef CONFIG_IEEE80211W
 static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
@@ -1695,7 +1667,7 @@ static sint validate_80211w_mgmt(_adapte
 			memcpy(ptr+pattrib->hdrlen, mgmt_DATA, data_len);
 			//remove the iv and icv length
 			pattrib->pkt_len = pattrib->pkt_len - pattrib->iv_len - pattrib->icv_len;
-			rtw_mfree(mgmt_DATA, data_len);
+			kfree(mgmt_DATA);
 			/*//print packet content after decryption
 			{
 				int pp;
@@ -1759,7 +1731,6 @@ validate_80211w_fail:
 	return _FAIL;
 	
 }
-#endif //CONFIG_IEEE80211W
 
 static inline void dump_rx_packet(u8 *ptr)
 {
@@ -1788,14 +1759,6 @@ sint validate_recv_frame(_adapter *adapt
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	u8  ver =(unsigned char) (*ptr)&0x3 ;
 
-#ifdef CONFIG_WAPI_SUPPORT
-	PRT_WAPI_T	pWapiInfo = &adapter->wapiInfo;
-	struct recv_frame_hdr *phdr = &precv_frame->u.hdr;
-	u8 wai_pkt = 0;
-	u16 sc;
-	u8	external_len = 0;
-#endif
-
 _func_enter_;
 
 	//add version chk
@@ -1819,9 +1782,6 @@ _func_enter_;
 	pattrib->mdata = GetMData(ptr);
 	pattrib->privacy = GetPrivacy(ptr);
 	pattrib->order = GetOrder(ptr);
-#ifdef CONFIG_WAPI_SUPPORT
-	sc = (pattrib->seq_num<<4) | pattrib->frag_num;
-#endif
 {
 	u8 bDumpRxPkt;
 	rtw_hal_get_def_var(adapter, HAL_DEF_DBG_DUMP_RXPKT, &(bDumpRxPkt));
@@ -1837,15 +1797,13 @@ _func_enter_;
 	{
 		case WIFI_MGT_TYPE: //mgnt
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_mgmt);
-#ifdef CONFIG_IEEE80211W
 			if(validate_80211w_mgmt(adapter, precv_frame) == _FAIL)
 			{
 				retval = _FAIL;
 				DBG_COUNTER(padapter->rx_logs.core_rx_pre_mgmt_err_80211w);
 				break;
 			}
-#endif //CONFIG_IEEE80211W
-			
+
 			retval = validate_recv_mgnt_frame(adapter, precv_frame);
 			if (retval == _FAIL)
 			{
@@ -1866,39 +1824,6 @@ _func_enter_;
 			break;
 		case WIFI_DATA_TYPE: //data
 			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data);
-#ifdef CONFIG_WAPI_SUPPORT
-			if(pattrib->qos)
-				external_len = 2;
-			else
-				external_len= 0;
-			
-			wai_pkt = rtw_wapi_is_wai_packet(adapter,ptr);
-
-			phdr->bIsWaiPacket = wai_pkt;
-
-			if(wai_pkt !=0){
-				if(sc != adapter->wapiInfo.wapiSeqnumAndFragNum)
-				{
-					adapter->wapiInfo.wapiSeqnumAndFragNum = sc;
-				}
-				else
-				{
-					retval = _FAIL;
-					DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_wapi_seq_err);
-					break;
-				}
-			}
-			else{
-
-					if(rtw_wapi_drop_for_key_absent(adapter,GetAddr2Ptr(ptr))){
-						retval=_FAIL;
-						WAPI_TRACE(WAPI_RX,"drop for key absent for rx \n");
-						DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_wapi_key_err);
-						break;
-					}
-			}
-
-#endif
 
 			pattrib->qos = (subtype & BIT(7))? 1:0;
 			retval = validate_recv_data_frame(adapter, precv_frame);
@@ -2080,7 +2005,7 @@ _func_enter_;
 	plist = get_next(phead);
 	prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 	pfhdr=&prframe->u.hdr;
-	rtw_list_delete(&(prframe->u.list));
+	list_del_init(&(prframe->u.list));
 
 	if(curfragnum!=pfhdr->attrib.frag_num)
 	{
@@ -2100,7 +2025,7 @@ _func_enter_;
 
 	data=get_recvframe_data(prframe);
 
-	while(rtw_end_of_queue_search(phead, plist) == false)
+	while(phead != plist)
 	{
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame , u);
 		pnfhdr=&pnextrframe->u.hdr;
@@ -2202,7 +2127,7 @@ _func_enter_;
 			if(fragnum==0)
 			{
 				//the first fragment
-				if(_rtw_queue_empty(pdefrag_q) == false)
+				if(!list_empty(&pdefrag_q->queue))
 				{
 					//free current defrag_q
 					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
@@ -2214,7 +2139,7 @@ _func_enter_;
 
 			//spin_lock(&pdefrag_q->lock);
 			phead = get_list_head(pdefrag_q);
-			rtw_list_insert_tail(&pfhdr->list, phead);
+			list_add_tail(&pfhdr->list, phead);
 			//spin_unlock(&pdefrag_q->lock);
 
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Enqueuq: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
@@ -2240,7 +2165,7 @@ _func_enter_;
 		{
 			//spin_lock(&pdefrag_q->lock);
 			phead = get_list_head(pdefrag_q);
-			rtw_list_insert_tail(&pfhdr->list,phead);
+			list_add_tail(&pfhdr->list,phead);
 			//spin_unlock(&pdefrag_q->lock);
 
 			//call recvframe_defrag to defrag
@@ -2445,14 +2370,14 @@ int enqueue_reorder_recvframe(struct rec
 
 	//DbgPrint("+enqueue_reorder_recvframe()\n");
 
-	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
 	//spin_lock(&ppending_recvframe_queue->lock);
 
 
 	phead = get_list_head(ppending_recvframe_queue);
 	plist = get_next(phead);
 
-	while(rtw_end_of_queue_search(phead, plist) == false)
+	while (phead != plist)
 	{
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnextattrib = &pnextrframe->u.hdr.attrib;
@@ -2466,7 +2391,7 @@ int enqueue_reorder_recvframe(struct rec
 			//Duplicate entry is found!! Do not insert current entry.
 			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
 
-			//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+			//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 
 			return false;
 		}
@@ -2480,15 +2405,15 @@ int enqueue_reorder_recvframe(struct rec
 	}
 
 
-	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
 	//spin_lock(&ppending_recvframe_queue->lock);
 
-	rtw_list_delete(&(prframe->u.hdr.list));
+	list_del_init(&(prframe->u.hdr.list));
 
-	rtw_list_insert_tail(&(prframe->u.hdr.list), plist);
+	list_add_tail(&(prframe->u.hdr.list), plist);
 
 	//spin_unlock(&ppending_recvframe_queue->lock);
-	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 
 
 	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
@@ -2528,7 +2453,7 @@ int recv_indicatepkts_in_order(_adapter
 
 	//DbgPrint("+recv_indicatepkts_in_order\n");
 
-	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_lock_irqsave(&ppending_recvframe_queue->lock, irql);
 	//spin_lock(&ppending_recvframe_queue->lock);
 
 	phead = 	get_list_head(ppending_recvframe_queue);
@@ -2538,9 +2463,9 @@ int recv_indicatepkts_in_order(_adapter
 	if(bforced==true)
 	{
 		pdbgpriv->dbg_rx_ampdu_forced_indicate_count++;
-		if(rtw_is_list_empty(phead))
+		if(list_empty(phead))
 		{
-			// _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+			// spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 			//spin_unlock(&ppending_recvframe_queue->lock);
 			return true;
 		}
@@ -2559,7 +2484,7 @@ int recv_indicatepkts_in_order(_adapter
 
 	// Prepare indication list and indication.
 	// Check if there is any packet need indicate.
-	while(!rtw_is_list_empty(phead))
+	while(!list_empty(phead))
 	{
 	
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
@@ -2572,7 +2497,7 @@ int recv_indicatepkts_in_order(_adapter
 				  preorder_ctrl->indicate_seq, pattrib->seq_num, pattrib->amsdu));
 
 			plist = get_next(plist);
-			rtw_list_delete(&(prframe->u.hdr.list));
+			list_del_init(&(prframe->u.hdr.list));
 
 			if(SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))
 			{
@@ -2632,7 +2557,7 @@ int recv_indicatepkts_in_order(_adapter
 	}
 
 	//spin_unlock(&ppending_recvframe_queue->lock);
-	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 
 /*
 	//Release the indication lock and set to new indication step.
@@ -2649,7 +2574,7 @@ int recv_indicatepkts_in_order(_adapter
 		//pTS->RxIndicateState = RXTS_INDICATE_IDLE;
 	}
 */
-	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 
 	//return true;
 	return bPktInBuf;
@@ -2744,7 +2669,7 @@ int recv_indicatepkt_reorder(_adapter *p
 		}
 	}
 
-	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+	spin_lock_bh(&ppending_recvframe_queue->lock);
 
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
 		 ("recv_indicatepkt_reorder: indicate=%d seq=%d\n",
@@ -2757,7 +2682,7 @@ int recv_indicatepkt_reorder(_adapter *p
 		//pHTInfo->RxReorderDropCounter++;
 		//ReturnRFDList(Adapter, pRfd);
 		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));
-		//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 		//return _FAIL;
 
 		#ifdef DBG_RX_DROP_FRAME
@@ -2771,7 +2696,7 @@ int recv_indicatepkt_reorder(_adapter *p
 	if(!enqueue_reorder_recvframe(preorder_ctrl, prframe))
 	{
 		//DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
-		//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
+		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, irql);
 		//return _FAIL;
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_871X("DBG_RX_DROP_FRAME %s enqueue_reorder_recvframe fail\n", __FUNCTION__);
@@ -2794,11 +2719,11 @@ int recv_indicatepkt_reorder(_adapter *p
 	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 	}
 	else
 	{
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
 	}
 
@@ -2806,7 +2731,7 @@ int recv_indicatepkt_reorder(_adapter *p
 
 _err_exit:
 
-        _exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+        spin_unlock_bh(&ppending_recvframe_queue->lock);
 
 	return _FAIL;
 }
@@ -2827,14 +2752,14 @@ void rtw_reordering_ctrl_timeout_handler
 
 	//DBG_871X("+rtw_reordering_ctrl_timeout_handler()=>\n");
 
-	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+	spin_lock_bh(&ppending_recvframe_queue->lock);
 
 	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, true)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);		
 	}
 
-	_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
 
 }
 
@@ -2934,9 +2859,6 @@ static int recv_func_posthandle(_adapter
 
 	DBG_COUNTER(padapter->rx_logs.core_rx_post);
 
-	// DATA FRAME
-	rtw_led_control(padapter, LED_CTL_RX);
-
 	prframe = decryptor(padapter, prframe);
 	if (prframe == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decryptor: drop pkt\n"));
@@ -2971,10 +2893,6 @@ static int recv_func_posthandle(_adapter
 
 	count_rx_stats(padapter, prframe, NULL);
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_wapi_update_info(padapter, prframe);
-#endif
-
 	ret = process_recv_indicatepkts(padapter, prframe);
 	if (ret != _SUCCESS)
 	{
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_rf.c linux/3rdparty/rtl8723bs/core/rtw_rf.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_rf.c	2015-05-10 14:36:05.676667990 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_rf.c	2015-05-07 17:46:55.000000000 +0300
@@ -69,23 +69,3 @@ u32 rtw_ch2freq(u32 channel)
 
 	return freq;
 }
-
-u32 rtw_freq2ch(u32 freq)
-{
-	u8	i;
-	u32	ch = 0;
-
-	for (i = 0; i < ch_freq_map_num; i++)
-	{
-		if (freq == ch_freq_map[i].frequency)
-		{
-			ch = ch_freq_map[i].channel;
-				break;
-		}
-	}
-	if (i == ch_freq_map_num)
-		ch = 1;
-
-	return ch;
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_security.c linux/3rdparty/rtl8723bs/core/rtw_security.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_security.c	2015-05-10 14:36:05.677668002 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_security.c	2015-05-07 17:46:55.000000000 +0300
@@ -35,11 +35,7 @@ static const char *_security_type_str[]
 
 const char *security_type_str(u8 value)
 {
-#ifdef CONFIG_IEEE80211W
 	if (value <= _BIP_)
-#else
-	if (value <= _WEP_WPA_MIXED_)
-#endif
 		return _security_type_str[value];
 	return NULL;
 }
@@ -1259,11 +1255,9 @@ _func_enter_;
     if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
     if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
     if (!qc_exists) mic_iv[1] = 0x00;
-#ifdef CONFIG_IEEE80211W
 	//802.11w management frame should set management bit(4)
     if(frtype == WIFI_MGT_TYPE)
 		mic_iv[1] |= BIT(4);
-#endif //CONFIG_IEEE80211W
     for (i = 2; i < 8; i++)
         mic_iv[i] = mpdu[i + 8];                    /* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
     #ifdef CONSISTENT_PN_ORDER
@@ -1295,14 +1289,13 @@ static void construct_mic_header1(
 _func_enter_;	
     mic_header1[0] = (u8)((header_length - 2) / 256);
     mic_header1[1] = (u8)((header_length - 2) % 256);
-#ifdef CONFIG_IEEE80211W
+
     //802.11w management frame don't AND subtype bits 4,5,6 of frame control field
     if(frtype == WIFI_MGT_TYPE)
 		mic_header1[2] = mpdu[0];
 	else
-#endif //CONFIG_IEEE80211W
 		mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
-    
+
     mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
     mic_header1[4] = mpdu[4];       /* A1 */
     mic_header1[5] = mpdu[5];
@@ -1399,11 +1392,9 @@ _func_enter_;
 		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
     if (qc_exists && !a4_exists) 
 		ctr_preload[1] = mpdu[24] & 0x0f;
-#ifdef CONFIG_IEEE80211W
 	//802.11w management frame should set management bit(4)
 	if(frtype == WIFI_MGT_TYPE)
 		ctr_preload[1] |= BIT(4);
-#endif //CONFIG_IEEE80211W
     for (i = 2; i < 8; i++)
         ctr_preload[i] = mpdu[i + 8];                       /* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
     #ifdef CONSISTENT_PN_ORDER
@@ -2129,7 +2120,6 @@ exit:
 	return res;
 }
 
-#ifdef CONFIG_IEEE80211W
 u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 {
 	struct rx_pkt_attrib *pattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
@@ -2226,10 +2216,9 @@ u32	rtw_BIP_verify(_adapter *padapter, u
 		res = RTW_RX_HANDLED;
 BIP_exit:
 
-	rtw_mfree(BIP_AAD, ori_len);
+	kfree(BIP_AAD);
 	return res;
 }
-#endif //CONFIG_IEEE80211W
 
 /* AES tables*/
 const u32 Te0[256] = {
@@ -2509,7 +2498,7 @@ static void gf_mulx(u8 *pad)
 static void aes_encrypt_deinit(void *ctx)
 {
 	memset(ctx, 0, AES_PRIV_SIZE);
-	rtw_mfree(ctx, AES_PRIV_SIZE);
+	kfree(ctx);
 }
 
 
@@ -2604,30 +2593,6 @@ int omac1_aes_128(u8 *key, u8 *data, siz
 	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
 }
 
-void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS)
-{
-        _adapter *padapter = (_adapter *)FunctionContext;
-
-_func_enter_;			
-
-	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler ^^^\n"));
-	
-/*
-	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved){
-			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler (padapter->bDriverStopped %d)(padapter->bSurpriseRemoved %d)^^^\n",padapter->bDriverStopped,padapter->bSurpriseRemoved));
-
-		return;
-	}
-	*/
-	
-	padapter->securitypriv.busetkipkey=true;
-
-	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
-
-_func_exit_;	
-
-}
-
 /* Restore HW wep key setting according to key_mask */
 void rtw_sec_restore_wep_key(_adapter *adapter)
 {
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_sta_mgt.c linux/3rdparty/rtl8723bs/core/rtw_sta_mgt.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_sta_mgt.c	2015-05-10 14:36:05.678668013 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_sta_mgt.c	2015-05-07 17:46:55.000000000 +0300
@@ -30,23 +30,21 @@ _func_enter_;
 	memset((u8 *)psta, 0, sizeof (struct sta_info));
 
 	 spin_lock_init(&psta->lock);
-	_rtw_init_listhead(&psta->list);
-	_rtw_init_listhead(&psta->hash_list);
-	//_rtw_init_listhead(&psta->asoc_list);
-	//_rtw_init_listhead(&psta->sleep_list);
-	//_rtw_init_listhead(&psta->wakeup_list);	
+	INIT_LIST_HEAD(&psta->list);
+	INIT_LIST_HEAD(&psta->hash_list);
+	//INIT_LIST_HEAD(&psta->asoc_list);
+	//INIT_LIST_HEAD(&psta->sleep_list);
+	//INIT_LIST_HEAD(&psta->wakeup_list);	
 
 	_rtw_init_queue(&psta->sleep_q);
 	psta->sleepq_len = 0;
 
 	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
 	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
-	
-#ifdef CONFIG_AP_MODE
 
-	_rtw_init_listhead(&psta->asoc_list);
+	INIT_LIST_HEAD(&psta->asoc_list);
 
-	_rtw_init_listhead(&psta->auth_list);
+	INIT_LIST_HEAD(&psta->auth_list);
 	
 	psta->expire_to = 0;
 	
@@ -56,24 +54,17 @@ _func_enter_;
 
 	psta->bpairwise_key_installed = false;
 
-
-#ifdef CONFIG_NATIVEAP_MLME
 	psta->nonerp_set = 0;
 	psta->no_short_slot_time_set = 0;
 	psta->no_short_preamble_set = 0;
 	psta->no_ht_gf_set = 0;
 	psta->no_ht_set = 0;
 	psta->ht_20mhz_set = 0;
-#endif	
 
-#ifdef CONFIG_TX_MCAST2UNI
 	psta->under_exist_checking = 0;
-#endif	// CONFIG_TX_MCAST2UNI
-	
+
 	psta->keep_alive_trycnt = 0;
 
-#endif	// CONFIG_AP_MODE	
-	
 _func_exit_;	
 
 }
@@ -85,7 +76,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 
 _func_enter_;	
 
-	pstapriv->pallocated_stainfo_buf = rtw_zvmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
+	pstapriv->pallocated_stainfo_buf = vzalloc (sizeof(struct sta_info) * NUM_STA+ 4);
 	
 	if(!pstapriv->pallocated_stainfo_buf)
 		return _FAIL;
@@ -109,22 +100,18 @@ _func_enter_;
 	{
 		_rtw_init_stainfo(psta);
 
-		_rtw_init_listhead(&(pstapriv->sta_hash[i]));
+		INIT_LIST_HEAD(&(pstapriv->sta_hash[i]));
 
-		rtw_list_insert_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
+		list_add_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
 
 		psta++;
 	}
 
-	
-
-#ifdef CONFIG_AP_MODE
-
 	pstapriv->sta_dz_bitmap = 0;
 	pstapriv->tim_bitmap = 0;
 
-	_rtw_init_listhead(&pstapriv->asoc_list);
-	_rtw_init_listhead(&pstapriv->auth_list);
+	INIT_LIST_HEAD(&pstapriv->asoc_list);
+	INIT_LIST_HEAD(&pstapriv->auth_list);
 	spin_lock_init(&pstapriv->asoc_list_lock);
 	spin_lock_init(&pstapriv->auth_list_lock);
 	pstapriv->asoc_list_cnt = 0;
@@ -136,9 +123,7 @@ _func_enter_;
 	//pstapriv->expire_to = 30;// 30*2 = 60 sec = 1 min, expire after no any traffic.
 	pstapriv->expire_to = 3; // 3*2 = 6 sec
 	pstapriv->max_num_sta = NUM_STA;
-		
-#endif
-	
+
 _func_exit_;		
 
 	return _SUCCESS;
@@ -164,8 +149,8 @@ inline struct sta_info *rtw_get_stainfo_
 }
 
 // this function is used to free the memory of lock || sema for all stainfos
-void rtw_mfree_all_stainfo(struct sta_priv *pstapriv );
-void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
+void kfree_all_stainfo(struct sta_priv *pstapriv );
+void kfree_all_stainfo(struct sta_priv *pstapriv )
 {
 	_irqL	 irqL;
 	_list	*plist, *phead;
@@ -173,31 +158,29 @@ void rtw_mfree_all_stainfo(struct sta_pr
 	
 _func_enter_;	
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	phead = get_list_head(&pstapriv->free_sta_queue);
 	plist = get_next(phead);
 		
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info ,list);
 		plist = get_next(plist);
 	}
 	
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 _func_exit_;	
 
 }
 
-void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv);
-void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+void kfree_sta_priv_lock(struct	sta_priv *pstapriv);
+void kfree_sta_priv_lock(struct	sta_priv *pstapriv)
 {
-#ifdef CONFIG_AP_MODE
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-#endif
 
-	 rtw_mfree_all_stainfo(pstapriv); //be done before free sta_hash_lock
+	 kfree_all_stainfo(pstapriv); //be done before free sta_hash_lock
 }
 
 u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
@@ -212,13 +195,13 @@ _func_enter_;
 	if(pstapriv){
 
 		/*	delete all reordering_ctrl_timer		*/ 
-		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_lock_bh(&pstapriv->sta_hash_lock);
 		for(index = 0; index < NUM_STA; index++)
 		{
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
 			
-			while ((rtw_end_of_queue_search(phead, plist)) == false)
+			while (phead != plist)
 			{
 				int i;	
 				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
@@ -231,13 +214,13 @@ _func_enter_;
 				}
 			}
 		}
-		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
 		/*===============================*/
 		
-		rtw_mfree_sta_priv_lock(pstapriv);
+		kfree_sta_priv_lock(pstapriv);
 
 		if(pstapriv->pallocated_stainfo_buf) {
-			rtw_vmfree(pstapriv->pallocated_stainfo_buf, sizeof(struct sta_info)*NUM_STA+4);
+			vfree(pstapriv->pallocated_stainfo_buf);
 		}
 	}
 	
@@ -263,12 +246,12 @@ _func_enter_;
 
 	pfree_sta_queue = &pstapriv->free_sta_queue;
 
-	//_enter_critical_bh(&(pfree_sta_queue->lock), &irqL);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
-	if (_rtw_queue_empty(pfree_sta_queue) == true)
+	//spin_lock_bh(&(pfree_sta_queue->lock));
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	if (list_empty(&pfree_sta_queue->queue))
 	{
-		//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		//spin_unlock_bh(&(pfree_sta_queue->lock));
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 		psta = NULL;
 		return psta;
 	}
@@ -276,9 +259,9 @@ _func_enter_;
 	{
 		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue), struct sta_info, list);
 		
-		rtw_list_delete(&(psta->list));
+		list_del_init(&(psta->list));
 
-		//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
+		//spin_unlock_bh(&(pfree_sta_queue->lock));
 		
 		tmp_aid = psta->aid;	
 	
@@ -299,13 +282,13 @@ _func_enter_;
 		}
 		phash_list = &(pstapriv->sta_hash[index]);
 
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		//spin_lock_bh(&(pstapriv->sta_hash_lock));
 
-		rtw_list_insert_tail(&psta->hash_list, phash_list);
+		list_add_tail(&psta->hash_list, phash_list);
 
 		pstapriv->asoc_sta_count ++ ;
 
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		//spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 // Commented by Albert 2009/08/13
 // For the SMC router, the sequence number of first packet of WPS handshake will be 0.
@@ -360,7 +343,7 @@ _func_enter_;
 	
 exit:
 
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 _func_exit_;
 
@@ -389,63 +372,63 @@ _func_enter_;
 		goto exit;
 
 
-	_enter_critical_bh(&psta->lock, &irqL0);
+	spin_lock_bh(&psta->lock);
 	psta->state &= ~_FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL0);
+	spin_unlock_bh(&psta->lock);
 
 	pfree_sta_queue = &pstapriv->free_sta_queue;
 
 
 	pstaxmitpriv = &psta->sta_xmitpriv;
 	
-	//rtw_list_delete(&psta->sleep_list);
+	//list_del_init(&psta->sleep_list);
 	
-	//rtw_list_delete(&psta->wakeup_list);
+	//list_del_init(&psta->wakeup_list);
 	
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 	
 	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
 	psta->sleepq_len = 0;
 	
 	//vo
-	//_enter_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+	//spin_lock_bh(&(pxmitpriv->vo_pending.lock));
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits;
 	phwxmit->accnt -= pstaxmitpriv->vo_q.qcnt;
 	pstaxmitpriv->vo_q.qcnt = 0;
-	//_exit_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+	//spin_unlock_bh(&(pxmitpriv->vo_pending.lock));
 
 	//vi
-	//_enter_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+	//spin_lock_bh(&(pxmitpriv->vi_pending.lock));
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+1;
 	phwxmit->accnt -= pstaxmitpriv->vi_q.qcnt;
 	pstaxmitpriv->vi_q.qcnt = 0;
-	//_exit_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+	//spin_unlock_bh(&(pxmitpriv->vi_pending.lock));
 
 	//be
-	//_enter_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+	//spin_lock_bh(&(pxmitpriv->be_pending.lock));
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+2;
 	phwxmit->accnt -= pstaxmitpriv->be_q.qcnt;
 	pstaxmitpriv->be_q.qcnt = 0;
-	//_exit_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+	//spin_unlock_bh(&(pxmitpriv->be_pending.lock));
 	
 	//bk
-	//_enter_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+	//spin_lock_bh(&(pxmitpriv->bk_pending.lock));
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+3;
 	phwxmit->accnt -= pstaxmitpriv->bk_q.qcnt;
 	pstaxmitpriv->bk_q.qcnt = 0;
-	//_exit_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+	//spin_unlock_bh(&(pxmitpriv->bk_pending.lock));
 	
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_unlock_bh(&pxmitpriv->lock);
 	
-	rtw_list_delete(&psta->hash_list);
+	list_del_init(&psta->hash_list);
 	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
 	pstapriv->asoc_sta_count --;
 	
@@ -472,23 +455,23 @@ _func_enter_;
 		
 		ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
-		_enter_critical_bh(&ppending_recvframe_queue->lock, &irqL);
+		spin_lock_bh(&ppending_recvframe_queue->lock);
 
 		phead = 	get_list_head(ppending_recvframe_queue);
 		plist = get_next(phead);
 		
-		while(!rtw_is_list_empty(phead))
+		while(!list_empty(phead))
 		{	
 			prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 			
 			plist = get_next(plist);
 			
-			rtw_list_delete(&(prframe->u.hdr.list));
+			list_del_init(&(prframe->u.hdr.list));
 
 			rtw_free_recvframe(prframe, pfree_recv_queue);
 		}
 
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irqL);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 		
 	}
 
@@ -499,19 +482,17 @@ _func_enter_;
 	//release mac id for non-bc/mc station,
 	rtw_release_macid(pstapriv->padapter, psta);
 
-#ifdef CONFIG_AP_MODE
-
 /*
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
-	rtw_list_delete(&psta->asoc_list);	
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	list_del_init(&psta->asoc_list);	
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 */
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL0);
-	if (!rtw_is_list_empty(&psta->auth_list)) {
-		rtw_list_delete(&psta->auth_list);
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!list_empty(&psta->auth_list)) {
+		list_del_init(&psta->auth_list);
 		pstapriv->auth_list_cnt--;
 	}
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL0);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 	
 	psta->expire_to = 0;
 	psta->sleepq_ac_len = 0;
@@ -525,30 +506,20 @@ _func_enter_;
 
 	psta->has_legacy_ac = 0;
 
-#ifdef CONFIG_NATIVEAP_MLME
-	
 	pstapriv->sta_dz_bitmap &=~BIT(psta->aid);
 	pstapriv->tim_bitmap &=~BIT(psta->aid);	
 
-	//rtw_indicate_sta_disassoc_event(padapter, psta);
-
 	if ((psta->aid >0)&&(pstapriv->sta_aid[psta->aid - 1] == psta))
 	{
 		pstapriv->sta_aid[psta->aid - 1] = NULL;
 		psta->aid = 0;
-	}	
-	
-#endif	// CONFIG_NATIVEAP_MLME	
+	}
 
-#ifdef CONFIG_TX_MCAST2UNI
 	psta->under_exist_checking = 0;
-#endif	// CONFIG_TX_MCAST2UNI
-
-#endif	// CONFIG_AP_MODE	
 
-	//_enter_critical_bh(&(pfree_sta_queue->lock), &irqL0);
-	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
-	//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL0);
+	//spin_lock_bh(&(pfree_sta_queue->lock));
+	list_add_tail(&psta->list, get_list_head(pfree_sta_queue));
+	//spin_unlock_bh(&(pfree_sta_queue->lock));
 
 exit:
 	
@@ -573,14 +544,14 @@ _func_enter_;
 	if(pstapriv->asoc_sta_count==1)
 		goto exit;
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	for(index=0; index< NUM_STA; index++)
 	{
 		phead = &(pstapriv->sta_hash[index]);
 		plist = get_next(phead);
 		
-		while ((rtw_end_of_queue_search(phead, plist)) == false)
+		while (phead != plist)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
 
@@ -592,7 +563,7 @@ _func_enter_;
 		}
 	}
 	
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 	
 exit:	
 	
@@ -632,13 +603,13 @@ _func_enter_;
 
 	index = wifi_mac_hash(addr);
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 	
 	phead = &(pstapriv->sta_hash[index]);
 	plist = get_next(phead);
 
 
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 	
 		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
@@ -651,7 +622,7 @@ _func_enter_;
 		plist = get_next(plist);
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 _func_exit_;	
 	return psta;
 	
@@ -683,13 +654,13 @@ _func_enter_;
 
 	ptxservq= &(psta->sta_xmitpriv.be_q);
 
-/*
-	_enter_critical(&pstapending->lock, &irqL0);
+/* DEADCODE
+	spin_lock_irqsave(&pstapending->lock, irqL0);
 
 	if (rtw_is_list_empty(&ptxservq->tx_pending))
-		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+		list_add_tail(&ptxservq->tx_pending, get_list_head(pstapending));
 
-	_exit_critical(&pstapending->lock, &irqL0);
+	spin_unlock_irqrestore(&pstapending->lock, irqL0);
 */
 	
 exit:
@@ -714,7 +685,6 @@ _func_exit_;
 u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr)
 {
 	u8 res = true;
-#ifdef  CONFIG_AP_MODE
 	_irqL irqL;
 	_list	*plist, *phead;
 	struct rtw_wlan_acl_node *paclnode;
@@ -723,10 +693,10 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 	_queue	*pacl_node_q =&pacl_list->acl_node_q;
 	
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);		
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	while (phead != plist)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
@@ -740,7 +710,7 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 			}
 		}		
 	}	
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 	
 
 	if(pacl_list->mode == 1)//accept unless in deny list
@@ -755,10 +725,7 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 	{
 		 res = true;
 	}		
-	
-#endif
 
 	return res;
-
 }
 
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_wapi.c linux/3rdparty/rtl8723bs/core/rtw_wapi.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_wapi.c	2015-05-10 14:36:05.678668013 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_wapi.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,1047 +0,0 @@
-#ifdef CONFIG_WAPI_SUPPORT
-
-#include <linux/unistd.h>
-#include <linux/etherdevice.h>
-#include <drv_types.h>
-#include <rtw_wapi.h>
-
-
-u32 wapi_debug_component =
-//				WAPI_INIT	|
-//				WAPI_API    	|
-//				WAPI_TX    	|
-//				WAPI_RX    	|
-				WAPI_ERR ; //always open err flags on
-
-void WapiFreeAllStaInfo(_adapter *padapter)
-{
-	PRT_WAPI_T				pWapiInfo;
-	PRT_WAPI_STA_INFO		pWapiStaInfo;
-	PRT_WAPI_BKID			pWapiBkid;
-
-	WAPI_TRACE(WAPI_INIT, "===========> %s\n", __FUNCTION__);
-	pWapiInfo = &padapter->wapiInfo;
-
-	//Pust to Idle List
-	rtw_wapi_return_all_sta_info(padapter);
-
-	//Sta Info List
-	while(!list_empty(&(pWapiInfo->wapiSTAIdleList)))
-	{
-		pWapiStaInfo = (PRT_WAPI_STA_INFO)list_entry(pWapiInfo->wapiSTAIdleList.next, RT_WAPI_STA_INFO, list);
-		list_del_init(&pWapiStaInfo->list);
-	}
-
-	//BKID List
-	while(!list_empty(&(pWapiInfo->wapiBKIDIdleList)))
-	{
-		pWapiBkid = (PRT_WAPI_BKID)list_entry(pWapiInfo->wapiBKIDIdleList.next, RT_WAPI_BKID, list);
-		list_del_init(&pWapiBkid->list);
-	}
-	WAPI_TRACE(WAPI_INIT, "<=========== %s\n", __FUNCTION__);
-	return;
-}
-
-void WapiSetIE(_adapter *padapter)
-{
-	PRT_WAPI_T		pWapiInfo = &(padapter->wapiInfo);
-	//PRT_WAPI_BKID	pWapiBkid;
-	u16		protocolVer = 1;
-	u16		akmCnt = 1;
-	u16		suiteCnt = 1;
-	u16		capability = 0;
-	u8		OUI[3];
-
-	OUI[0] = 0x00;
-	OUI[1] = 0x14;
-	OUI[2] = 0x72;
-
-	pWapiInfo->wapiIELength = 0;
-//protocol version
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength, &protocolVer, 2);
-	pWapiInfo->wapiIELength +=2;
-//akm
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength, &akmCnt, 2);
-	pWapiInfo->wapiIELength +=2;
-
-	if(pWapiInfo->bWapiPSK){
-		memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength,OUI, 3);
-		pWapiInfo->wapiIELength +=3;
-		pWapiInfo->wapiIE[pWapiInfo->wapiIELength] = 0x2;
-		pWapiInfo->wapiIELength +=1;
-	}else{
-		memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength,OUI, 3);
-		pWapiInfo->wapiIELength +=3;
-		pWapiInfo->wapiIE[pWapiInfo->wapiIELength] = 0x1;
-		pWapiInfo->wapiIELength +=1;
-	}
-
-//usk
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength, &suiteCnt, 2);
-	pWapiInfo->wapiIELength +=2;
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength,OUI, 3);
-	pWapiInfo->wapiIELength +=3;
-	pWapiInfo->wapiIE[pWapiInfo->wapiIELength] = 0x1;
-	pWapiInfo->wapiIELength +=1;
-
-//msk
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength,OUI, 3);
-	pWapiInfo->wapiIELength +=3;
-	pWapiInfo->wapiIE[pWapiInfo->wapiIELength] = 0x1;
-	pWapiInfo->wapiIELength +=1;
-
-//Capbility
-	memcpy(pWapiInfo->wapiIE+pWapiInfo->wapiIELength, &capability, 2);
-	pWapiInfo->wapiIELength +=2;
-}
-
-
-/*  PN1 > PN2, return 1,
- *  else return 0.
- */
-u32 WapiComparePN(u8 *PN1, u8 *PN2)
-{
-	char i;
-
-	if ((NULL == PN1) || (NULL == PN2))
-		return 1;
-
-	// overflow case
-	if ((PN2[15] - PN1[15]) & 0x80)
-		return 1;
-
-	for (i=16; i>0; i--)
-	{
-		if(PN1[i-1] == PN2[i-1])
-		    	continue;
-		else if(PN1[i-1] > PN2[i-1])
-			return 1;
-		else
-			return 0;
-	}
-
-	return 0;
-}
-
-u8
-WapiGetEntryForCamWrite(_adapter *padapter,u8 *pMacAddr,u8 KID,bool IsMsk)
-{
-	PRT_WAPI_T		pWapiInfo=NULL;
-	//PRT_WAPI_CAM_ENTRY	pEntry=NULL;
-	u8 i=0;
-	u8 ret = 0xff;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	pWapiInfo =  &padapter->wapiInfo;
-
-	//exist?
-	for(i=0;i<WAPI_CAM_ENTRY_NUM;i++)
-	{
-		if(pWapiInfo->wapiCamEntry[i].IsUsed
-			&& (!memcmp(pMacAddr, pWapiInfo->wapiCamEntry[i].PeerMacAddr, ETH_ALEN))
-			&& pWapiInfo->wapiCamEntry[i].keyidx == KID
-			&& pWapiInfo->wapiCamEntry[i].type == IsMsk)
-		{
-			ret = pWapiInfo->wapiCamEntry[i].entry_idx; //cover it
-			break;
-		}
-	}
-
-	if(i == WAPI_CAM_ENTRY_NUM) //not found
-	{
-		for(i=0;i<WAPI_CAM_ENTRY_NUM;i++)
-		{
-			if(pWapiInfo->wapiCamEntry[i].IsUsed == 0)
-			{
-				pWapiInfo->wapiCamEntry[i].IsUsed = 1;
-				pWapiInfo->wapiCamEntry[i].type = IsMsk;
-				pWapiInfo->wapiCamEntry[i].keyidx = KID;
-				memcpy(pWapiInfo->wapiCamEntry[i].PeerMacAddr, pMacAddr,ETH_ALEN);
-				ret = pWapiInfo->wapiCamEntry[i].entry_idx;
-				break;
-			}
-		}
-	}
-
-	WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-	return ret;
-
-/*
-	if(RTIsListEmpty(&pWapiInfo->wapiCamIdleList)){
-		RT_TRACE(COMP_SEC,DBG_LOUD,("No Entry for wapi!!!\n"));
-		return 0;
-	}
-
-	pEntry = (PRT_WAPI_CAM_ENTRY)RTRemoveHeadList(&pWapiInfo->wapiCamIdleList);
-	RTInsertTailList(&pWapiInfo->wapiCamUsedList, &pEntry->list);
-
-	RT_TRACE(COMP_SEC,DBG_LOUD,("<====WapiGetCamEntry(),Get Entry Idx:%d.but we just return 4 for test\n",pEntry->entry_idx));
-
-	return pEntry->entry_idx;*/
-}
-
-u8 WapiGetEntryForCamClear(_adapter *padapter,u8 *pPeerMac,u8 keyid,u8 IsMsk)
-{
-	PRT_WAPI_T		pWapiInfo=NULL;
-	u8		i=0;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	pWapiInfo =  &padapter->wapiInfo;
-
-	for(i=0;i<WAPI_CAM_ENTRY_NUM;i++)
-	{
-		if(pWapiInfo->wapiCamEntry[i].IsUsed
-			&& (!memcmp(pPeerMac, pWapiInfo->wapiCamEntry[i].PeerMacAddr, ETH_ALEN))
-			&& pWapiInfo->wapiCamEntry[i].keyidx == keyid
-			&& pWapiInfo->wapiCamEntry[i].type == IsMsk)
-		{
-				pWapiInfo->wapiCamEntry[i].IsUsed = 0;
-				pWapiInfo->wapiCamEntry[i].keyidx = 2;
-				memset(pWapiInfo->wapiCamEntry[i].PeerMacAddr,0,ETH_ALEN);
-
-				WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-				return pWapiInfo->wapiCamEntry[i].entry_idx;
-		}
-	}
-
-	WAPI_TRACE(WAPI_API,"<====WapiGetReturnCamEntry(), No this cam entry.\n");
-	return 0xff;
-/*
-	if(RTIsListEmpty(&pWapiInfo->wapiCamUsedList)){
-		RT_TRACE(COMP_SEC,DBG_LOUD,("No Entry for wapi!!!\n"));
-		return false;
-	}
-
-	pList = &pWapiInfo->wapiCamUsedList;
-	while(pList->Flink != &pWapiInfo->wapiCamUsedList)
-	{
-		pEntry = (PRT_WAPI_CAM_ENTRY)pList->Flink;
-		if(PlatformCompareMemory(pPeerMac,pEntry->PeerMacAddr, ETHER_ADDRLEN)== 0
-			&& keyid == pEntry->keyidx)
-		{
-			RTRemoveEntryList(pList);
-			RTInsertHeadList(&pWapiInfo->wapiCamIdleList, pList);
-			return pEntry->entry_idx;
-		}
-		pList = pList->Flink;
-	}
-
-	return 0;
-*/
-}
-
-void
-WapiResetAllCamEntry(_adapter *padapter)
-{
-	PRT_WAPI_T		pWapiInfo;
-	int				i;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	pWapiInfo =  &padapter->wapiInfo;
-
-	for (i=0;i<WAPI_CAM_ENTRY_NUM;i++)
-	{
-		memset(pWapiInfo->wapiCamEntry[i].PeerMacAddr, 0, ETH_ALEN);
-		pWapiInfo->wapiCamEntry[i].IsUsed = 0;
-	 	pWapiInfo->wapiCamEntry[i].keyidx = 2; //invalid
-	 	pWapiInfo->wapiCamEntry[i].entry_idx = 4+i*2;
- 	}
-
-	WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-
-	return;
-}
-
-u8 WapiWriteOneCamEntry(
-	_adapter 	*padapter,
-	u8 			*pMacAddr,
-	u8 			KeyId,
-	u8			EntryId,
-	u8 			EncAlg,
-	u8 			bGroupKey,
-	u8 			*pKey
-)
-{
-	u8 retVal = 0;
-	u16 usConfig = 0;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	if(EntryId >= 32)
-	{
-		WAPI_TRACE(WAPI_ERR, "<=== CamAddOneEntry(): ulKeyId exceed!\n");
-		return retVal;
-	}
-
-	usConfig=usConfig|(0x01<<15)|((u16)(EncAlg)<<2)|(KeyId);
-
-	if(EncAlg == _SMS4_ )
-	{
-		if(bGroupKey == 1)
-			usConfig |= (0x01<<6);
-		if((EntryId % 2)==1)  // ==0 sec key; == 1mic key
-			usConfig |= (0x01<<5);
-	}
-
-	write_cam(padapter, EntryId, usConfig, pMacAddr, pKey);
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-    	return 1;
-}
-
-void rtw_wapi_init(_adapter *padapter)
-{
-	PRT_WAPI_T		pWapiInfo;
-	int				i;
-
-	WAPI_TRACE(WAPI_INIT, "===========> %s\n", __FUNCTION__);
-	RT_ASSERT_RET(padapter);
-
-	if (!padapter->WapiSupport)
-	{
-		WAPI_TRACE(WAPI_INIT, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	pWapiInfo =  &padapter->wapiInfo;
-	pWapiInfo->bWapiEnable = false;
-
-	//Init BKID List
-	INIT_LIST_HEAD(&pWapiInfo->wapiBKIDIdleList);
-	INIT_LIST_HEAD(&pWapiInfo->wapiBKIDStoreList);
-	for(i=0;i<WAPI_MAX_BKID_NUM;i++)
-	{
-		list_add_tail(&pWapiInfo->wapiBKID[i].list, &pWapiInfo->wapiBKIDIdleList);
-	}
-
-	//Init STA List
-	INIT_LIST_HEAD(&pWapiInfo->wapiSTAIdleList);
-	INIT_LIST_HEAD(&pWapiInfo->wapiSTAUsedList);
-	for(i=0;i<WAPI_MAX_STAINFO_NUM;i++)
-	{
-		list_add_tail(&pWapiInfo->wapiSta[i].list, &pWapiInfo->wapiSTAIdleList);
-	}
-
-	 for (i=0;i<WAPI_CAM_ENTRY_NUM;i++)
-	 {
-		pWapiInfo->wapiCamEntry[i].IsUsed = 0;
-	 	pWapiInfo->wapiCamEntry[i].keyidx = 2; //invalid
-	 	pWapiInfo->wapiCamEntry[i].entry_idx = 4+i*2;
- 	}
-
-	WAPI_TRACE(WAPI_INIT, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_free(_adapter *padapter)
-{
-	WAPI_TRACE(WAPI_INIT, "===========> %s\n", __FUNCTION__);
-	RT_ASSERT_RET(padapter);
-
-	if (!padapter->WapiSupport)
-	{
-		WAPI_TRACE(WAPI_INIT, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	WapiFreeAllStaInfo(padapter);
-
-	WAPI_TRACE(WAPI_INIT, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_disable_tx(_adapter *padapter)
-{
-	WAPI_TRACE(WAPI_INIT, "===========> %s\n", __FUNCTION__);
-	RT_ASSERT_RET(padapter);
-
-	if (!padapter->WapiSupport)
-	{
-		WAPI_TRACE(WAPI_INIT, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	padapter->wapiInfo.wapiTxMsk.bTxEnable = false;
-	padapter->wapiInfo.wapiTxMsk.bSet = false;
-
-	WAPI_TRACE(WAPI_INIT, "<========== %s\n", __FUNCTION__);
-}
-
-u8 rtw_wapi_is_wai_packet(_adapter* padapter,u8 *pkt_data)
-{
-	PRT_WAPI_T pWapiInfo = &(padapter->wapiInfo);
-	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
-	struct security_priv   *psecuritypriv = &padapter->securitypriv;
-	PRT_WAPI_STA_INFO pWapiSta = NULL;
-	u8 WaiPkt = 0, *pTaddr, bFind = false;
-	u8 Offset_TypeWAI = 0 ;	// (mac header len + llc length)
-	
-	WAPI_TRACE(WAPI_TX|WAPI_RX, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return 0;
-	}
-
-	 Offset_TypeWAI = 24 + 6 ;
-
-	//YJ,add,091103. Data frame may also have skb->data[30]=0x88 and skb->data[31]=0xb4.
-	if ((pkt_data[1]&0x40) !=0)
-	{
-		//DBG_871X("data is privacy \n");
-	    	return 0;
-	}
-	
-	pTaddr = GetAddr2Ptr(pkt_data);
-	if(list_empty(&pWapiInfo->wapiSTAUsedList)){
-		bFind = false;
-	}else{
-		list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list){
-			if (!memcmp(pTaddr, pWapiSta->PeerMacAddr, 6)) {
-				bFind = true;
-				break;
-			}
-		}
-	}
-
-	WAPI_TRACE(WAPI_TX|WAPI_RX, "%s: bFind=%d pTaddr="MAC_FMT"\n", __FUNCTION__, bFind, MAC_ARG(pTaddr));
-
-	if (pkt_data[0] == WIFI_QOS_DATA_TYPE)
-	{
-		Offset_TypeWAI += 2;
-	}
-
-	// 88b4?
-	if( (pkt_data[Offset_TypeWAI]==0x88) && (pkt_data[Offset_TypeWAI+1]==0xb4) ){
-		WaiPkt = pkt_data[Offset_TypeWAI+5];
-
-		psecuritypriv->hw_decrypted = true;
-	}else{
-		WAPI_TRACE(WAPI_TX|WAPI_RX, "%s(): non wai packet\n",__FUNCTION__);
-	}
-
-	WAPI_TRACE(WAPI_TX|WAPI_RX, "%s(): Recvd WAI frame. IsWAIPkt(%d)\n",__FUNCTION__, WaiPkt);
-
-	return	WaiPkt;
-}
-
-
-void rtw_wapi_update_info(_adapter *padapter, union recv_frame *precv_frame)
-{
-	PRT_WAPI_T     pWapiInfo = &(padapter->wapiInfo);
-	struct recv_frame_hdr *precv_hdr;
-	u8 	*ptr;
-	u8 	*pTA;
-	u8 	*pRecvPN;
-
-
-	WAPI_TRACE(WAPI_RX, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_RX, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	precv_hdr = &precv_frame->u.hdr;
-	ptr = precv_hdr->rx_data;
-
-	if (precv_hdr->attrib.qos == 1)
-	{
-		precv_hdr->UserPriority = GetTid(ptr);
-	}
-	else
-	{
-		precv_hdr->UserPriority = 0;
-	}
-
-	pTA = GetAddr2Ptr(ptr);
-	memcpy((u8 *)precv_hdr->WapiSrcAddr, pTA, 6);
-	pRecvPN = ptr + precv_hdr->attrib.hdrlen + 2;
-	memcpy((u8 *)precv_hdr->WapiTempPN, pRecvPN, 16);
-
-	WAPI_TRACE(WAPI_RX, "<========== %s\n", __FUNCTION__);
-}
-
-/****************************************************************************
-true-----------------Drop
-false---------------- handle
-add to support WAPI to N-mode
-*****************************************************************************/
-u8 rtw_wapi_check_for_drop(
-	_adapter *padapter,
-	union recv_frame *precv_frame
-)
-{
-	PRT_WAPI_T     pWapiInfo = &(padapter->wapiInfo);
-	u8			*pLastRecvPN = NULL;
-	u8			bFind = false;
-	PRT_WAPI_STA_INFO	pWapiSta = NULL;
-	u8 			bDrop = false;
-	struct recv_frame_hdr *precv_hdr = &precv_frame->u.hdr;
-	u8					WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-	u8 					WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-	u8 					*ptr = precv_frame->u.hdr.rx_data;
-	int					i;
-
-	WAPI_TRACE(WAPI_RX, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_RX, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return false;
-	}
-
-	if(precv_hdr->bIsWaiPacket !=0)
-	{
-		if(precv_hdr->bIsWaiPacket== 0x8)
-		{
-
-			DBG_871X("rtw_wapi_check_for_drop: dump packet \n");
-			for(i=0;i<50;i++)
-			{
-				DBG_871X("%02X  ",ptr[i]);
-				if((i+1) %8 ==0)
-					DBG_871X("\n");
-			}
-			DBG_871X("\n rtw_wapi_check_for_drop: dump packet \n");
-
-			for(i=0;i<16;i++)
-			{
-				if(ptr[i+27] !=0)
-					break;
-			}
-
-			if(i== 16)
-			{
-				WAPI_TRACE(WAPI_RX,"rtw_wapi_check_for_drop: drop with zero BKID \n");
-				return true;
-			}
-			else
-			{
-				return false;
-			}
-		}
-			else
-				return false;
-	}
-
-	if(list_empty(&pWapiInfo->wapiSTAUsedList)){
-		bFind = false;
-	}else{
-		list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-			if (!memcmp(precv_hdr->WapiSrcAddr, pWapiSta->PeerMacAddr, ETH_ALEN)) {
-				bFind = true;
-				break;
-			}
-		}
-	}
-	WAPI_TRACE(WAPI_RX, "%s: bFind=%d prxb->WapiSrcAddr="MAC_FMT"\n", __FUNCTION__, bFind, MAC_ARG(precv_hdr->WapiSrcAddr));
-
-	if(bFind)
-	{
-		if(IS_MCAST(precv_hdr->attrib.ra))
-		{
-			WAPI_TRACE(WAPI_RX,"rtw_wapi_check_for_drop: multicast case \n");
-			pLastRecvPN = pWapiSta->lastRxMulticastPN;
-		}
-		else
-		{
-			WAPI_TRACE(WAPI_RX,"rtw_wapi_check_for_drop: unicast case \n");
-			switch(precv_hdr->UserPriority)
-			{
-				case 0:
-				case 3:
-					pLastRecvPN = pWapiSta->lastRxUnicastPNBEQueue;
-					break;
-				case 1:
-				case 2:
-					pLastRecvPN = pWapiSta->lastRxUnicastPNBKQueue;
-					break;
-				case 4:
-				case 5:
-					pLastRecvPN = pWapiSta->lastRxUnicastPNVIQueue;
-					break;
-				case 6:
-				case 7:
-					pLastRecvPN = pWapiSta->lastRxUnicastPNVOQueue;
-					break;
-				default:
-					WAPI_TRACE(WAPI_ERR,"%s: Unknown TID \n",__FUNCTION__);
-					break;
-			}
-		}
-
-		if(!WapiComparePN(precv_hdr->WapiTempPN,pLastRecvPN))
-		{
-			WAPI_TRACE(WAPI_RX,"%s: Equal PN!!\n",__FUNCTION__);
-			if(IS_MCAST(precv_hdr->attrib.ra))
-				memcpy(pLastRecvPN,WapiAEMultiCastPNInitialValueSrc,16);
-			else
-				memcpy(pLastRecvPN,WapiAEPNInitialValueSrc,16);
-			bDrop = true;
-		}
-		else
-		{
-			memcpy(pLastRecvPN,precv_hdr->WapiTempPN,16);
-		}
-	}
-
-	WAPI_TRACE(WAPI_RX, "<========== %s\n", __FUNCTION__);
-	return bDrop;
-}
-
-void rtw_build_probe_resp_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib)
-{
-	PRT_WAPI_T pWapiInfo = &(padapter->wapiInfo);
-	u8 WapiIELength = 0;
-
-	WAPI_TRACE(WAPI_MLME, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport)  || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	WapiSetIE(padapter);
-	WapiIELength = pWapiInfo->wapiIELength;
-	pframe[0] = _WAPI_IE_;
-	pframe[1] = WapiIELength;
-	memcpy(pframe+2, pWapiInfo->wapiIE, WapiIELength);
-	pframe += WapiIELength+2;
-	pattrib->pktlen += WapiIELength+2;
-
-	WAPI_TRACE(WAPI_MLME, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_build_beacon_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib)
-{
-	PRT_WAPI_T pWapiInfo = &(padapter->wapiInfo);
-	u8 WapiIELength = 0;
-	WAPI_TRACE(WAPI_MLME, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport)  || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	WapiSetIE(padapter);
-	WapiIELength = pWapiInfo->wapiIELength;
-	pframe[0] = _WAPI_IE_;
-	pframe[1] = WapiIELength;
-	memcpy(pframe+2, pWapiInfo->wapiIE, WapiIELength);
-	pframe += WapiIELength+2;
-	pattrib->pktlen += WapiIELength+2;
-
-	WAPI_TRACE(WAPI_MLME, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_build_assoc_req_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib)
-{
-	PRT_WAPI_BKID		pWapiBKID;
-	u16					bkidNum;
-	PRT_WAPI_T			pWapiInfo = &(padapter->wapiInfo);
-	u8					WapiIELength = 0;
-
-	WAPI_TRACE(WAPI_MLME, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported!\n", __FUNCTION__);
-		return;
-	}
-
-	WapiSetIE(padapter);
-	WapiIELength = pWapiInfo->wapiIELength;
-	bkidNum = 0;
-	if(!list_empty(&(pWapiInfo->wapiBKIDStoreList))){
-		list_for_each_entry(pWapiBKID, &pWapiInfo->wapiBKIDStoreList, list) {
-			bkidNum ++;
-			memcpy(pWapiInfo->wapiIE+WapiIELength+2, pWapiBKID->bkid,16);
-			WapiIELength += 16;
-		}
-	}
-	memcpy(pWapiInfo->wapiIE+WapiIELength, &bkidNum, 2);
-	WapiIELength += 2;
-
-	 pframe[0] = _WAPI_IE_;
-	 pframe[1] = WapiIELength;
-	memcpy(pframe+2, pWapiInfo->wapiIE, WapiIELength);
-	pframe += WapiIELength+2;
-	pattrib->pktlen += WapiIELength+2;
-	WAPI_TRACE(WAPI_MLME, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_on_assoc_ok(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
-{
-	PRT_WAPI_T pWapiInfo = &(padapter->wapiInfo);
-	PRT_WAPI_STA_INFO pWapiSta;
-	u8 WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-	//u8 WapiASUEPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-	u8 WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-
-	WAPI_TRACE(WAPI_MLME, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	pWapiSta =(PRT_WAPI_STA_INFO)list_entry(pWapiInfo->wapiSTAIdleList.next, RT_WAPI_STA_INFO, list);
-	list_del_init(&pWapiSta->list);
-	list_add_tail(&pWapiSta->list, &pWapiInfo->wapiSTAUsedList);
-	memcpy(pWapiSta->PeerMacAddr,padapter->mlmeextpriv.mlmext_info.network.MacAddress,6);
-	memcpy(pWapiSta->lastRxMulticastPN, WapiAEMultiCastPNInitialValueSrc, 16);
-	memcpy(pWapiSta->lastRxUnicastPN, WapiAEPNInitialValueSrc, 16);
-
-	//For chenk PN error with Qos Data after s3: add by ylb 20111114
-	memcpy(pWapiSta->lastRxUnicastPNBEQueue,WapiAEPNInitialValueSrc,16);
-	memcpy(pWapiSta->lastRxUnicastPNBKQueue,WapiAEPNInitialValueSrc,16);
-	memcpy(pWapiSta->lastRxUnicastPNVIQueue,WapiAEPNInitialValueSrc,16);
-	memcpy(pWapiSta->lastRxUnicastPNVOQueue,WapiAEPNInitialValueSrc,16);
-
-	WAPI_TRACE(WAPI_MLME, "<========== %s\n", __FUNCTION__);
-}
-
-
-void rtw_wapi_return_one_sta_info(_adapter *padapter, u8 *MacAddr)
-{
-	PRT_WAPI_T				pWapiInfo;
-	PRT_WAPI_STA_INFO		pWapiStaInfo = NULL;
-	PRT_WAPI_BKID			pWapiBkid = NULL;
-	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
-
-	pWapiInfo = &padapter->wapiInfo;
-
-	WAPI_TRACE(WAPI_API, "==========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-       if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
-       {
-             while(!list_empty(&(pWapiInfo->wapiBKIDStoreList)))
-                 {
-                        pWapiBkid = (PRT_WAPI_BKID)list_entry(pWapiInfo->wapiBKIDStoreList.next, RT_WAPI_BKID, list);
-                           list_del_init(&pWapiBkid->list);
-                           memset(pWapiBkid->bkid,0,16);
-                        list_add_tail(&pWapiBkid->list, &pWapiInfo->wapiBKIDIdleList);
-                 }
-        }
-
-
-	WAPI_TRACE(WAPI_API, " %s: after clear bkid \n", __FUNCTION__);
-
-
-	//Remove STA info
-	if(list_empty(&(pWapiInfo->wapiSTAUsedList))){
-		WAPI_TRACE(WAPI_API, " %s: wapiSTAUsedList is null \n", __FUNCTION__);
-		return;
-	}else{
-		WAPI_TRACE(WAPI_API, " %s: wapiSTAUsedList is not null \n", __FUNCTION__);
-
-		while(!list_empty(&(pWapiInfo->wapiSTAUsedList)))
-		{
-			pWapiStaInfo = (PRT_WAPI_STA_INFO)list_entry(pWapiInfo->wapiSTAUsedList.next, RT_WAPI_STA_INFO, list);
-
-			DBG_871X("peer Addr %02x-%02x-%02x-%02x-%02x-%02x \n",pWapiStaInfo->PeerMacAddr[0],pWapiStaInfo->PeerMacAddr[1],pWapiStaInfo->PeerMacAddr[2],pWapiStaInfo->PeerMacAddr[3],pWapiStaInfo->PeerMacAddr[4],pWapiStaInfo->PeerMacAddr[5]);
-
-			list_del_init(&pWapiStaInfo->list);
-			memset(pWapiStaInfo->PeerMacAddr,0,ETH_ALEN);
-			pWapiStaInfo->bSetkeyOk = 0;
-			list_add_tail(&pWapiStaInfo->list, &pWapiInfo->wapiSTAIdleList);
-		}
-
-	}
-
-        WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-	return;
-}
-
-void rtw_wapi_return_all_sta_info(_adapter *padapter)
-{
-	PRT_WAPI_T				pWapiInfo;
-	PRT_WAPI_STA_INFO		pWapiStaInfo;
-	PRT_WAPI_BKID			pWapiBkid;
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	pWapiInfo = &padapter->wapiInfo;
-
-	if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	//Sta Info List
-	while(!list_empty(&(pWapiInfo->wapiSTAUsedList)))
-	{
-		pWapiStaInfo = (PRT_WAPI_STA_INFO)list_entry(pWapiInfo->wapiSTAUsedList.next, RT_WAPI_STA_INFO, list);
-		list_del_init(&pWapiStaInfo->list);
-		memset(pWapiStaInfo->PeerMacAddr,0,ETH_ALEN);
-		pWapiStaInfo->bSetkeyOk = 0;
-		list_add_tail(&pWapiStaInfo->list, &pWapiInfo->wapiSTAIdleList);
-	}
-
-	//BKID List
-	while(!list_empty(&(pWapiInfo->wapiBKIDStoreList)))
-	{
-		pWapiBkid = (PRT_WAPI_BKID)list_entry(pWapiInfo->wapiBKIDStoreList.next, RT_WAPI_BKID, list);
-		list_del_init(&pWapiBkid->list);
-		memset(pWapiBkid->bkid,0,16);
-		list_add_tail(&pWapiBkid->list, &pWapiInfo->wapiBKIDIdleList);
-	}
-	WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_clear_cam_entry(_adapter *padapter, u8 *pMacAddr)
-{
-	u8 UcIndex = 0;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!padapter->wapiInfo.bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	UcIndex = WapiGetEntryForCamClear(padapter, pMacAddr, 0, 0);
-	if(UcIndex != 0xff){
-		//CAM_mark_invalid(Adapter, UcIndex);
-		CAM_empty_entry(padapter, UcIndex);
-	}
-
-	UcIndex = WapiGetEntryForCamClear(padapter, pMacAddr, 1, 0);
-	if(UcIndex != 0xff){
-		//CAM_mark_invalid(Adapter, UcIndex);
-		CAM_empty_entry(padapter, UcIndex);
-	}
-
-	UcIndex = WapiGetEntryForCamClear(padapter, pMacAddr, 0, 1);
-	if(UcIndex != 0xff){
-		//CAM_mark_invalid(Adapter, UcIndex);
-		CAM_empty_entry(padapter, UcIndex);
-	}
-
-	UcIndex = WapiGetEntryForCamClear(padapter, pMacAddr, 1, 1);
-	if(UcIndex != 0xff){
-		//CAM_mark_invalid(padapter, UcIndex);
-		CAM_empty_entry(padapter, UcIndex);
-	}
-
-	WAPI_TRACE(WAPI_API, "<========== %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_clear_all_cam_entry(_adapter *padapter)
-{
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!padapter->wapiInfo.bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_MLME, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	invalidate_cam_all(padapter); // is this ok?
-	WapiResetAllCamEntry(padapter);
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-}
-
-void rtw_wapi_set_key(_adapter *padapter, RT_WAPI_KEY *pWapiKey, RT_WAPI_STA_INFO *pWapiSta, u8 bGroupKey, u8 bUseDefaultKey)
-{
-	PRT_WAPI_T		pWapiInfo =  &padapter->wapiInfo;
-	u8				*pMacAddr = pWapiSta->PeerMacAddr;
-	u32 EntryId = 0;
-	bool IsPairWise = false ;
-	u8 EncAlgo;
-
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!padapter->wapiInfo.bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_API, "<========== %s, WAPI not supported or not enabled!\n", __FUNCTION__);
-		return;
-	}
-
-	EncAlgo = _SMS4_;
-
-	//For Tx bc/mc pkt,use defualt key entry
-	if(bUseDefaultKey)
-	{
-		// when WAPI update key, keyid will be 0 or 1 by turns.
-		if (pWapiKey->keyId == 0)
-			EntryId = 0;
-		else
-			EntryId = 2;
-	}
-	else
-	{
-		// tx/rx unicast pkt, or rx broadcast, find the key entry by peer's MacAddr
-		EntryId = WapiGetEntryForCamWrite(padapter,pMacAddr,pWapiKey->keyId,bGroupKey);
-	}
-
-	if(EntryId == 0xff){
-		WAPI_TRACE(WAPI_API, "===>No entry for WAPI setkey! !!\n");
-		return;
-	}
-
-	//EntryId is also used to diff Sec key and Mic key
-	//Sec Key
-	WapiWriteOneCamEntry(padapter,
-					pMacAddr,
-					pWapiKey->keyId, //keyid
-					EntryId,	//entry
-					EncAlgo, //type
-					bGroupKey, //pairwise or group key
-					pWapiKey->dataKey);
-	//MIC key
-	WapiWriteOneCamEntry(padapter,
-					pMacAddr,
-					pWapiKey->keyId, //keyid
-					EntryId+1,	//entry
-					EncAlgo, //type
-					bGroupKey, //pairwise or group key
-					pWapiKey->micKey);
-
-	WAPI_TRACE(WAPI_API, "Set Wapi Key :KeyId:%d,EntryId:%d,PairwiseKey:%d.\n",pWapiKey->keyId,EntryId,!bGroupKey);
-	WAPI_TRACE(WAPI_API, "===========> %s\n", __FUNCTION__);
-
-}
-
-void rtw_wapi_get_iv(_adapter *padapter,u8 *pRA, u8*IV)
-{
-	PWLAN_HEADER_WAPI_EXTENSION pWapiExt = NULL;
-       PRT_WAPI_T         pWapiInfo = &padapter->wapiInfo;
-	bool	bPNOverflow = false;
-	bool	bFindMatchPeer = false;
-	PRT_WAPI_STA_INFO  pWapiSta = NULL;
-
-	pWapiExt = (PWLAN_HEADER_WAPI_EXTENSION)IV;
-
-	WAPI_DATA(WAPI_RX,"wapi_get_iv: pra",pRA,6);
-
-	if(IS_MCAST(pRA)){
-		if(!pWapiInfo->wapiTxMsk.bTxEnable){
-			 WAPI_TRACE(WAPI_ERR,"%s: bTxEnable = 0!!\n",__FUNCTION__);
-			 return;
-		}
-
-		if(pWapiInfo->wapiTxMsk.keyId <= 1){
-			 pWapiExt->KeyIdx = pWapiInfo->wapiTxMsk.keyId;
-			 pWapiExt->Reserved = 0;
-			 bPNOverflow = WapiIncreasePN(pWapiInfo->lastTxMulticastPN, 1);
-			 memcpy(pWapiExt->PN, pWapiInfo->lastTxMulticastPN, 16);
-		}
-	}
-	else
-	{
-		if(list_empty(&pWapiInfo->wapiSTAUsedList)){
-			WAPI_TRACE(WAPI_RX,"rtw_wapi_get_iv: list is empty \n");
-			memset(IV,10,18);
-			return;
-		}
-		else{
-				list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list){
-					WAPI_DATA(WAPI_RX,"rtw_wapi_get_iv: peermacaddr ",pWapiSta->PeerMacAddr,6);
-					if (!memcmp((u8*)pWapiSta->PeerMacAddr, pRA, 6)) {
-						bFindMatchPeer = true;
-						break;
-					}
-				}
-
-				WAPI_TRACE(WAPI_RX,"bFindMatchPeer: %d \n",bFindMatchPeer);
-				WAPI_DATA(WAPI_RX,"Addr",pRA,6);
-
-				if (bFindMatchPeer){
-					if((!pWapiSta->wapiUskUpdate.bTxEnable) && (!pWapiSta->wapiUsk.bTxEnable))
-						return;
-
-					if (pWapiSta->wapiUsk.keyId <= 1){
-						if(pWapiSta->wapiUskUpdate.bTxEnable)
-							pWapiExt->KeyIdx = pWapiSta->wapiUskUpdate.keyId;
-						else
-							pWapiExt->KeyIdx = pWapiSta->wapiUsk.keyId;
-
-						pWapiExt->Reserved = 0;
-						bPNOverflow = WapiIncreasePN(pWapiSta->lastTxUnicastPN, 2);
-						memcpy(pWapiExt->PN, pWapiSta->lastTxUnicastPN, 16);
-
-					}
-				}
-		}
-
-	}
-
-}
-
-bool rtw_wapi_drop_for_key_absent(_adapter *padapter,u8 *pRA)
-{
-	PRT_WAPI_T         pWapiInfo = &padapter->wapiInfo;
-	bool				bFindMatchPeer = false;
-	bool				bDrop = false;
-	PRT_WAPI_STA_INFO  pWapiSta = NULL;
-	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
-
-	WAPI_DATA(WAPI_RX,"rtw_wapi_drop_for_key_absent: ra ",pRA,6);
-
-	if(psecuritypriv->dot11PrivacyAlgrthm == _SMS4_)
-	{
-		if ((!padapter->WapiSupport) || (!pWapiInfo->bWapiEnable))
-			return true;
-
-		if(IS_MCAST(pRA)){
-			if(!pWapiInfo->wapiTxMsk.bTxEnable){
-				bDrop = true;
-				WAPI_TRACE(WAPI_RX,"rtw_wapi_drop_for_key_absent: multicast key is absent \n");
-				return bDrop;
-			}
-		}
-		else{
-				if(!list_empty(&pWapiInfo->wapiSTAUsedList)){
-					list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list){
-						WAPI_DATA(WAPI_RX,"rtw_wapi_drop_for_key_absent: pWapiSta->PeerMacAddr ",pWapiSta->PeerMacAddr,6);
-						if (!memcmp(pRA, pWapiSta->PeerMacAddr, 6)){
-							bFindMatchPeer = true;
-							break;
-						}
-					}
-					if (bFindMatchPeer)	{
-						if (!pWapiSta->wapiUsk.bTxEnable){
-							bDrop = true;
-							WAPI_TRACE(WAPI_RX,"rtw_wapi_drop_for_key_absent: unicast key is absent \n");
-							return bDrop;
-						}
-					}
-					else{
-						bDrop = true;
-						WAPI_TRACE(WAPI_RX,"rtw_wapi_drop_for_key_absent: no peer find \n");
-						return bDrop;
-					}
-
-				}
-				else{
-						bDrop = true;
-						WAPI_TRACE(WAPI_RX,"rtw_wapi_drop_for_key_absent: no sta  exist \n");
-						return bDrop;
-				}
-		}
-	}
-	else
-	{
-		return bDrop;
-	}
-
-	return bDrop;
-}
-
-#endif
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_wapi_sms4.c linux/3rdparty/rtl8723bs/core/rtw_wapi_sms4.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_wapi_sms4.c	2015-05-10 14:36:05.678668013 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_wapi_sms4.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,713 +0,0 @@
-#ifdef CONFIG_WAPI_SUPPORT
-
-#include <linux/unistd.h>
-#include <linux/etherdevice.h>
-#include <drv_types.h>
-#include <rtw_wapi.h>
-
-
-#ifdef CONFIG_WAPI_SW_SMS4
-
-#define WAPI_LITTLE_ENDIAN
-//#define BIG_ENDIAN
-#define ENCRYPT  0
-#define DECRYPT  1
-
-
-/**********************************************************
- **********************************************************/
-const u8 Sbox[256] = {
-0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
-0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
-0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
-0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
-0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
-0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
-0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
-0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
-0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
-0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
-0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
-0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
-0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
-0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
-0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
-0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
-};
-
-const u32 CK[32] = {
-	0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
-	0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
-	0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
-	0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
-	0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
-	0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
-	0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
-	0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 };
-
-#define Rotl(_x, _y) (((_x) << (_y)) | ((_x) >> (32 - (_y))))
-
-#define ByteSub(_A) (Sbox[(_A) >> 24 & 0xFF] << 24 | \
-                     Sbox[(_A) >> 16 & 0xFF] << 16 | \
-                     Sbox[(_A) >>  8 & 0xFF] <<  8 | \
-                     Sbox[(_A) & 0xFF])
-
-#define L1(_B) ((_B) ^ Rotl(_B, 2) ^ Rotl(_B, 10) ^ Rotl(_B, 18) ^ Rotl(_B, 24))
-#define L2(_B) ((_B) ^ Rotl(_B, 13) ^ Rotl(_B, 23))
-
-static void
-xor_block(void *dst, void *src1, void *src2)
-/* 128-bit xor: *dst = *src1 xor *src2. Pointers must be 32-bit aligned  */
-{
-    ((u32 *)dst)[0] = ((u32 *)src1)[0] ^ ((u32 *)src2)[0];
-    ((u32 *)dst)[1] = ((u32 *)src1)[1] ^ ((u32 *)src2)[1];
-    ((u32 *)dst)[2] = ((u32 *)src1)[2] ^ ((u32 *)src2)[2];
-    ((u32 *)dst)[3] = ((u32 *)src1)[3] ^ ((u32 *)src2)[3];
-}
-
-
-void SMS4Crypt(u8 *Input, u8 *Output, u32 *rk)
-{
-	 u32 r, mid, x0, x1, x2, x3, *p;
-	 p = (u32 *)Input;
-	 x0 = p[0];
-	 x1 = p[1];
-	 x2 = p[2];
-	 x3 = p[3];
-#ifdef WAPI_LITTLE_ENDIAN
-	 x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) | ((x0 & 0xFF00FF00) >> 8);
-	 x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) | ((x1 & 0xFF00FF00) >> 8);
-	 x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) | ((x2 & 0xFF00FF00) >> 8);
-	 x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) | ((x3 & 0xFF00FF00) >> 8);
-#endif
-	 for (r = 0; r < 32; r += 4)
-	 {
-		  mid = x1 ^ x2 ^ x3 ^ rk[r + 0];
-		  mid = ByteSub(mid);
-		  x0 ^= L1(mid);
-		  mid = x2 ^ x3 ^ x0 ^ rk[r + 1];
-		  mid = ByteSub(mid);
-		  x1 ^= L1(mid);
-		  mid = x3 ^ x0 ^ x1 ^ rk[r + 2];
-		  mid = ByteSub(mid);
-		  x2 ^= L1(mid);
-		  mid = x0 ^ x1 ^ x2 ^ rk[r + 3];
-		  mid = ByteSub(mid);
-		  x3 ^= L1(mid);
-	 }
-#ifdef WAPI_LITTLE_ENDIAN
-	 x0 = Rotl(x0, 16); x0 = ((x0 & 0x00FF00FF) << 8) | ((x0 & 0xFF00FF00) >> 8);
-	 x1 = Rotl(x1, 16); x1 = ((x1 & 0x00FF00FF) << 8) | ((x1 & 0xFF00FF00) >> 8);
-	 x2 = Rotl(x2, 16); x2 = ((x2 & 0x00FF00FF) << 8) | ((x2 & 0xFF00FF00) >> 8);
-	 x3 = Rotl(x3, 16); x3 = ((x3 & 0x00FF00FF) << 8) | ((x3 & 0xFF00FF00) >> 8);
-#endif
-	 p = (u32 *)Output;
-	 p[0] = x3;
-	 p[1] = x2;
-	 p[2] = x1;
-	 p[3] = x0;
-}
-
-
-
-void SMS4KeyExt(u8 *Key, u32 *rk, u32 CryptFlag)
-{
-	 u32 r, mid, x0, x1, x2, x3, *p;
-
-	 p = (u32 *)Key;
-	 x0 = p[0];
-	 x1 = p[1];
-	 x2 = p[2];
-	 x3 = p[3];
-#ifdef WAPI_LITTLE_ENDIAN
-	 x0 = Rotl(x0, 16); x0 = ((x0 & 0xFF00FF) << 8) | ((x0 & 0xFF00FF00) >> 8);
-	 x1 = Rotl(x1, 16); x1 = ((x1 & 0xFF00FF) << 8) | ((x1 & 0xFF00FF00) >> 8);
-	 x2 = Rotl(x2, 16); x2 = ((x2 & 0xFF00FF) << 8) | ((x2 & 0xFF00FF00) >> 8);
-	 x3 = Rotl(x3, 16); x3 = ((x3 & 0xFF00FF) << 8) | ((x3 & 0xFF00FF00) >> 8);
-#endif
-
-	 x0 ^= 0xa3b1bac6;
-	 x1 ^= 0x56aa3350;
-	 x2 ^= 0x677d9197;
-	 x3 ^= 0xb27022dc;
-	 for (r = 0; r < 32; r += 4)
-	 {
-		  mid = x1 ^ x2 ^ x3 ^ CK[r + 0];
-		  mid = ByteSub(mid);
-		  rk[r + 0] = x0 ^= L2(mid);
-		  mid = x2 ^ x3 ^ x0 ^ CK[r + 1];
-		  mid = ByteSub(mid);
-		  rk[r + 1] = x1 ^= L2(mid);
-		  mid = x3 ^ x0 ^ x1 ^ CK[r + 2];
-		  mid = ByteSub(mid);
-		  rk[r + 2] = x2 ^= L2(mid);
-		  mid = x0 ^ x1 ^ x2 ^ CK[r + 3];
-		  mid = ByteSub(mid);
-		  rk[r + 3] = x3 ^= L2(mid);
-	 }
-	 if (CryptFlag == DECRYPT)
-	 {
-	 	  for (r = 0; r < 16; r++)
-	 	  	 mid = rk[r], rk[r] = rk[31 - r], rk[31 - r] = mid;
-	 }
-}
-
-
-void WapiSMS4Cryption(u8 *Key, u8 *IV, u8 *Input, u16 InputLength,
-                                                u8 *Output, u16 *OutputLength, u32 CryptFlag)
-{
-	u32 blockNum,i,j, rk[32];
-	u16 remainder;
-	u8 blockIn[16],blockOut[16], tempIV[16], k;
-
-	*OutputLength = 0;
-	remainder = InputLength & 0x0F;
-	blockNum = InputLength >> 4;
-	if(remainder !=0)
-		blockNum++;
-	else
-		remainder = 16;
-
-	for(k=0;k<16;k++)
-		tempIV[k] = IV[15-k];
-
-	memcpy(blockIn, tempIV, 16);
-
-      SMS4KeyExt((u8 *)Key, rk,CryptFlag);
-
-	for(i=0; i<blockNum-1; i++)
-	{
-		SMS4Crypt((u8 *)blockIn, blockOut, rk);
-             xor_block(&Output[i*16], &Input[i*16], blockOut);
-		memcpy(blockIn,blockOut,16);
-	}
-
-	*OutputLength = i*16;
-
-	SMS4Crypt((u8 *)blockIn, blockOut, rk);
-
-	for(j=0; j<remainder; j++)
-	{
-		Output[i*16+j] = Input[i*16+j] ^ blockOut[j];
-	}
-      *OutputLength += remainder;
-
-}
-
-void WapiSMS4Encryption(u8 *Key, u8 *IV, u8 *Input, u16 InputLength,
-                                                    u8 *Output, u16 *OutputLength)
-{
-
-	WapiSMS4Cryption(Key, IV, Input, InputLength, Output, OutputLength, ENCRYPT);
-}
-
-void WapiSMS4Decryption(u8 *Key, u8 *IV, u8 *Input, u16 InputLength,
-                                                    u8 *Output, u16 *OutputLength)
-{
-	// OFB mode: is also ENCRYPT flag
-	WapiSMS4Cryption(Key, IV, Input, InputLength, Output, OutputLength, ENCRYPT);
-}
-
-void WapiSMS4CalculateMic(u8 *Key, u8 *IV, u8 *Input1, u8 Input1Length,
-                                                 u8 *Input2, u16 Input2Length, u8 *Output, u8 *OutputLength)
-{
-	u32 blockNum, i, remainder, rk[32];
-	u8 BlockIn[16], BlockOut[16], TempBlock[16], tempIV[16], k;
-
-	*OutputLength = 0;
-	remainder = Input1Length & 0x0F;
-	blockNum = Input1Length >> 4;
-
-	for(k=0;k<16;k++)
-		tempIV[k] = IV[15-k];
-
-	memcpy(BlockIn, tempIV, 16);
-
-	SMS4KeyExt((u8 *)Key, rk, ENCRYPT);
-
-	SMS4Crypt((u8 *)BlockIn, BlockOut, rk);
-
-	for(i=0; i<blockNum; i++){
-		xor_block(BlockIn, (Input1+i*16), BlockOut);
-		SMS4Crypt((u8 *)BlockIn, BlockOut, rk);
-	}
-
-	if(remainder !=0){
-		memset(TempBlock, 0, 16);
-		memcpy(TempBlock, (Input1+blockNum*16), remainder);
-
-		xor_block(BlockIn, TempBlock, BlockOut);
-		SMS4Crypt((u8 *)BlockIn, BlockOut, rk);
-      }
-
-	remainder = Input2Length & 0x0F;
-	blockNum = Input2Length >> 4;
-
-  	for(i=0; i<blockNum; i++){
-		xor_block(BlockIn, (Input2+i*16), BlockOut);
-		SMS4Crypt((u8 *)BlockIn, BlockOut, rk);
-	}
-
-	if(remainder !=0){
-		memset(TempBlock, 0, 16);
-		memcpy(TempBlock, (Input2+blockNum*16), remainder);
-
-		xor_block(BlockIn, TempBlock, BlockOut);
-		SMS4Crypt((u8 *)BlockIn, BlockOut, rk);
-	}
-
-	memcpy(Output, BlockOut, 16);
-	*OutputLength = 16;
-}
-
-/* AddCount: 1 or 2.
- *  If overflow, return 1,
- *  else return 0.
- */
-u8 WapiIncreasePN(u8 *PN, u8 AddCount)
-{
-	u8  i;
-
-	if (NULL == PN)
-		return 1;
-	//YJ,test,091102
-	/*
-	if(AddCount == 2){
-		DBG_8192C("############################%s(): PN[0]=0x%x\n", __FUNCTION__, PN[0]);
-		if(PN[0] == 0x48){
-			PN[0] += AddCount;
-			return 1;
-		}else{
-			PN[0] += AddCount;
-			return 0;
-		}
-	}
-	*/
-	//YJ,test,091102,end
-
-	for (i=0; i<16; i++)
-	{
-		if (PN[i] + AddCount <= 0xff)
-		{
-			PN[i] += AddCount;
-			return 0;
-		}
-		else
-		{
-			PN[i] += AddCount;
-			AddCount = 1;
-		}
-	}
-	return 1;
-}
-
-
-void WapiGetLastRxUnicastPNForQoSData(
-	u8 			UserPriority,
-	PRT_WAPI_STA_INFO    pWapiStaInfo,
-	u8 *PNOut
-)
-{
-	WAPI_TRACE(WAPI_RX, "===========> %s\n", __FUNCTION__);
-	switch(UserPriority)
-	{
-		case 0:
-		case 3:
-			      memcpy(PNOut,pWapiStaInfo->lastRxUnicastPNBEQueue,16);
-			      break;
-		case 1:
-		case 2:
-			      memcpy(PNOut,pWapiStaInfo->lastRxUnicastPNBKQueue,16);
-			      break;
-		case 4:
-		case 5:
-			      memcpy(PNOut,pWapiStaInfo->lastRxUnicastPNVIQueue,16);
-			      break;
-		case 6:
-		case 7:
-			      memcpy(PNOut,pWapiStaInfo->lastRxUnicastPNVOQueue,16);
-			      break;
-		default:
-				WAPI_TRACE(WAPI_ERR, "%s: Unknown TID \n", __FUNCTION__);
-				break;
-	}
-	WAPI_TRACE(WAPI_RX, "<=========== %s\n", __FUNCTION__);
-}
-
-
-void WapiSetLastRxUnicastPNForQoSData(
-	u8 		UserPriority,
-	u8           *PNIn,
-	PRT_WAPI_STA_INFO    pWapiStaInfo
-)
-{
-	WAPI_TRACE(WAPI_RX, "===========> %s\n", __FUNCTION__);
-	switch(UserPriority)
-	{
-		case 0:
-		case 3:
-			      memcpy(pWapiStaInfo->lastRxUnicastPNBEQueue,PNIn,16);
-			      break;
-		case 1:
-		case 2:
-			      memcpy(pWapiStaInfo->lastRxUnicastPNBKQueue,PNIn,16);
-			      break;
-		case 4:
-		case 5:
-			      memcpy(pWapiStaInfo->lastRxUnicastPNVIQueue,PNIn,16);
-			      break;
-		case 6:
-		case 7:
-			      memcpy(pWapiStaInfo->lastRxUnicastPNVOQueue,PNIn,16);
-			      break;
-		default:
-				WAPI_TRACE(WAPI_ERR, "%s: Unknown TID \n", __FUNCTION__);
-				break;
-	}
-	WAPI_TRACE(WAPI_RX, "<=========== %s\n", __FUNCTION__);
-}
-
-// WAPI SW Enc: must have done Coalesce!
-void SecSWSMS4Encryption(
-	_adapter *padapter,
-	u8 * pxmitframe
-	)
-{
-	PRT_WAPI_T		pWapiInfo = &padapter->wapiInfo;
-	PRT_WAPI_STA_INFO   pWapiSta = NULL;
-	u8 *pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_SIZE;
-	struct pkt_attrib *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
-
-	u8 *SecPtr = NULL, *pRA, *pMicKey = NULL, *pDataKey = NULL, *pIV = NULL;
-	u8 IVOffset, DataOffset, bFindMatchPeer = false, KeyIdx = 0, MicBuffer[16];
-	u16 OutputLength;
-
-	WAPI_TRACE(WAPI_TX, "=========>%s\n", __FUNCTION__);
-
-	WAPI_TRACE(WAPI_TX,"hdrlen: %d \n",pattrib->hdrlen);
-
-	return;
-
-	DataOffset = pattrib->hdrlen + pattrib->iv_len;
-
-	pRA = pframe + 4;
-
-
-	if( IS_MCAST(pRA) ){
-		KeyIdx = pWapiInfo->wapiTxMsk.keyId;
-		pIV = pWapiInfo->lastTxMulticastPN;
-		pMicKey = pWapiInfo->wapiTxMsk.micKey;
-		pDataKey = pWapiInfo->wapiTxMsk.dataKey;
-	}else{
-		if (!list_empty(&(pWapiInfo->wapiSTAUsedList))){
-			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-				if (!memcmp(pWapiSta->PeerMacAddr, pRA, 6)){
-					bFindMatchPeer = true;
-					break;
-				}
-			}
-
-			if (bFindMatchPeer){
-				if (pWapiSta->wapiUskUpdate.bTxEnable){
-					KeyIdx = pWapiSta->wapiUskUpdate.keyId;
-					WAPI_TRACE(WAPI_TX, "%s(): Use update USK!! KeyIdx=%d\n", __FUNCTION__, KeyIdx);
-					pIV = pWapiSta->lastTxUnicastPN;
-					pMicKey = pWapiSta->wapiUskUpdate.micKey;
-					pDataKey = pWapiSta->wapiUskUpdate.dataKey;
-				}else{
-					KeyIdx = pWapiSta->wapiUsk.keyId;
-					WAPI_TRACE(WAPI_TX, "%s(): Use USK!! KeyIdx=%d\n", __FUNCTION__, KeyIdx);
-					pIV = pWapiSta->lastTxUnicastPN;
-					pMicKey = pWapiSta->wapiUsk.micKey;
-					pDataKey = pWapiSta->wapiUsk.dataKey;
-				}
-  			}else{
-				WAPI_TRACE(WAPI_ERR,"%s: Can not find Peer Sta!!\n",__FUNCTION__);
-				return;
-			}
-		}else{
-			WAPI_TRACE(WAPI_ERR,"%s: wapiSTAUsedList is empty!!\n",__FUNCTION__);
-			return;
-		}
-	}
-
-	SecPtr = pframe;
-
-	WAPI_DATA(WAPI_TX, "Encryption - MIC", MicBuffer, padapter->wapiInfo.extra_postfix_len);
-
-	memcpy(pframe+pattrib->hdrlen+pattrib->iv_len+pattrib->pktlen-pattrib->icv_len,
-			(u8 *)MicBuffer,
-			padapter->wapiInfo.extra_postfix_len
-			);
-
-
-	WapiSMS4Encryption(pDataKey, pIV, (SecPtr+DataOffset),pattrib->pktlen+pattrib->icv_len, (SecPtr+DataOffset), &OutputLength);
-
-	WAPI_DATA(WAPI_TX, "Encryption - After SMS4 encryption",pframe,pattrib->hdrlen+pattrib->iv_len+pattrib->pktlen);
-
-	WAPI_TRACE(WAPI_TX, "<=========%s\n", __FUNCTION__);
-}
-
-u8 SecSWSMS4Decryption(
-	_adapter *padapter,
-	u8 		*precv_frame,
-	struct recv_priv *precv_priv
-	)
-{
-	PRT_WAPI_T pWapiInfo = &padapter->wapiInfo;
-	struct recv_frame_hdr *precv_hdr;
-	PRT_WAPI_STA_INFO   pWapiSta = NULL;
-	u8 IVOffset, DataOffset, bFindMatchPeer = false, bUseUpdatedKey = false;
-	u8 KeyIdx, MicBuffer[16], lastRxPNforQoS[16];
-	u8 *pRA, *pTA, *pMicKey, *pDataKey, *pLastRxPN, *pRecvPN, *pSecData, *pRecvMic, *pos;
-	u8 TID = 0;
-	u16 OutputLength, DataLen;
-	u8   bQosData;
-	struct sk_buff * 	pskb;
-
-	WAPI_TRACE(WAPI_RX, "=========>%s\n", __FUNCTION__);
-
-	return 0;
-
-	precv_hdr = &((union recv_frame*)precv_frame)->u.hdr;
-	pskb = (struct sk_buff *)(precv_hdr->rx_data);
-	precv_hdr->bWapiCheckPNInDecrypt = false;
-	WAPI_TRACE(WAPI_RX, "=========>%s: check PN  %d\n", __FUNCTION__,precv_hdr->bWapiCheckPNInDecrypt);
-	WAPI_DATA(WAPI_RX, "Decryption - Before decryption", pskb->data, pskb->len);
-
-	IVOffset = sMacHdrLng;
-	bQosData = GetFrameType(pskb->data) == WIFI_QOS_DATA_TYPE;
-	if (bQosData){
-		IVOffset += 2;
-	}
-
-	//if(GetHTC())
-	//	IVOffset += 4;
-
-	//IVOffset += SNAP_SIZE + sizeof(u16);
-
-	DataOffset = IVOffset + padapter->wapiInfo.extra_prefix_len;
-
-	pRA = pskb->data + 4;
-	pTA = pskb->data + 10;
-	KeyIdx = *(pskb->data + IVOffset);
-	pRecvPN = pskb->data + IVOffset + 2;
-	pSecData = pskb->data + DataOffset;
-	DataLen = pskb->len - DataOffset;
-	pRecvMic = pskb->data + pskb->len - padapter->wapiInfo.extra_postfix_len;
-	TID = GetTid(pskb->data);
-
-	if (!list_empty(&(pWapiInfo->wapiSTAUsedList))){
-		list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-			if (!memcmp(pWapiSta->PeerMacAddr, pTA, 6)){
-				bFindMatchPeer = true;
-				break;
-			}
-		}
-	}
-
-	if (!bFindMatchPeer){
-		WAPI_TRACE(WAPI_ERR, "%s: Can not find Peer Sta "MAC_FMT" for Key Info!!!\n", __FUNCTION__, MAC_ARG(pTA));
-		return false;
-	}
-
-	if( IS_MCAST(pRA) ){
-		WAPI_TRACE(WAPI_RX, "%s: Multicast decryption !!!\n", __FUNCTION__);
-		if (pWapiSta->wapiMsk.keyId == KeyIdx && pWapiSta->wapiMsk.bSet){
-			pLastRxPN = pWapiSta->lastRxMulticastPN;
-			if (!WapiComparePN(pRecvPN, pLastRxPN)){
-				WAPI_TRACE(WAPI_ERR, "%s: MSK PN is not larger than last, Dropped!!!\n", __FUNCTION__);
-				WAPI_DATA(WAPI_ERR, "pRecvPN:", pRecvPN, 16);
-				WAPI_DATA(WAPI_ERR, "pLastRxPN:", pLastRxPN, 16);
-				return false;
-			}
-
-			memcpy(pLastRxPN, pRecvPN, 16);
-			pMicKey = pWapiSta->wapiMsk.micKey;
-			pDataKey = pWapiSta->wapiMsk.dataKey;
-		}else if (pWapiSta->wapiMskUpdate.keyId == KeyIdx && pWapiSta->wapiMskUpdate.bSet){
-			WAPI_TRACE(WAPI_RX, "%s: Use Updated MSK for Decryption !!!\n", __FUNCTION__);
-			bUseUpdatedKey = true;
-			memcpy(pWapiSta->lastRxMulticastPN, pRecvPN, 16);
-			pMicKey = pWapiSta->wapiMskUpdate.micKey;
-			pDataKey = pWapiSta->wapiMskUpdate.dataKey;
-		}else{
-			WAPI_TRACE(WAPI_ERR, "%s: Can not find MSK with matched KeyIdx(%d), Dropped !!!\n", __FUNCTION__,KeyIdx);
-			return false;
-		}
-	}
-	else{
-		WAPI_TRACE(WAPI_RX, "%s: Unicast decryption !!!\n", __FUNCTION__);
-		if (pWapiSta->wapiUsk.keyId == KeyIdx && pWapiSta->wapiUsk.bSet){
-			WAPI_TRACE(WAPI_RX, "%s: Use USK for Decryption!!!\n", __FUNCTION__);
-			if(precv_hdr->bWapiCheckPNInDecrypt){
-				if(GetFrameType(pskb->data) == WIFI_QOS_DATA_TYPE){
-					WapiGetLastRxUnicastPNForQoSData(TID, pWapiSta, lastRxPNforQoS);
-					pLastRxPN = lastRxPNforQoS;
-				}else{
-					pLastRxPN = pWapiSta->lastRxUnicastPN;
-				}
-				if (!WapiComparePN(pRecvPN, pLastRxPN)){
-					return false;
-				}
-				if(bQosData){
-					WapiSetLastRxUnicastPNForQoSData(TID, pRecvPN, pWapiSta);
-				}else{
-					memcpy(pWapiSta->lastRxUnicastPN, pRecvPN, 16);
-				}
-			}else{
-				memcpy(precv_hdr->WapiTempPN,pRecvPN,16);
-			}
-
-			if (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE))
-			{
-				if ((pRecvPN[0] & 0x1) == 0){
-					WAPI_TRACE(WAPI_ERR, "%s: Rx USK PN is not odd when Infra STA mode, Dropped !!!\n", __FUNCTION__);
-					return false;
-				}
-			}
-
-			pMicKey = pWapiSta->wapiUsk.micKey;
-			pDataKey = pWapiSta->wapiUsk.dataKey;
-		}
-		else if (pWapiSta->wapiUskUpdate.keyId == KeyIdx && pWapiSta->wapiUskUpdate.bSet ){
-			WAPI_TRACE(WAPI_RX, "%s: Use Updated USK for Decryption!!!\n", __FUNCTION__);
-			if(pWapiSta->bAuthenticatorInUpdata)
-				bUseUpdatedKey = true;
-			else
-				bUseUpdatedKey = false;
-
-			if(bQosData){
-				WapiSetLastRxUnicastPNForQoSData(TID, pRecvPN, pWapiSta);
-			}else{
-				memcpy(pWapiSta->lastRxUnicastPN, pRecvPN, 16);
-			}
-			pMicKey = pWapiSta->wapiUskUpdate.micKey;
-			pDataKey = pWapiSta->wapiUskUpdate.dataKey;
-		}else{
-			WAPI_TRACE(WAPI_ERR, "%s: No valid USK!!!KeyIdx=%d pWapiSta->wapiUsk.keyId=%d pWapiSta->wapiUskUpdate.keyId=%d\n", __FUNCTION__, KeyIdx, pWapiSta->wapiUsk.keyId, pWapiSta->wapiUskUpdate.keyId);
-			//dump_buf(pskb->data,pskb->len);
-			return false;
-		}
-	}
-
-	WAPI_DATA(WAPI_RX, "Decryption - DataKey", pDataKey, 16);
-	WAPI_DATA(WAPI_RX, "Decryption - IV", pRecvPN, 16);
-	WapiSMS4Decryption(pDataKey, pRecvPN, pSecData, DataLen, pSecData, &OutputLength);
-
-	if (OutputLength != DataLen)
-		WAPI_TRACE(WAPI_ERR, "%s:  Output Length Error!!!!\n", __FUNCTION__);
-
-	WAPI_DATA(WAPI_RX, "Decryption - After decryption", pskb->data, pskb->len);
-
-	DataLen -= padapter->wapiInfo.extra_postfix_len;
-
-	WAPI_DATA(WAPI_RX, "Decryption - MIC received", pRecvMic, SMS4_MIC_LEN);
-	WAPI_DATA(WAPI_RX, "Decryption - MIC calculated", MicBuffer, SMS4_MIC_LEN);
-
-	if (!memcmp(MicBuffer, pRecvMic, padapter->wapiInfo.extra_postfix_len)){
-		WAPI_TRACE(WAPI_RX, "%s: Check MIC OK!!\n", __FUNCTION__);
-		if (bUseUpdatedKey){
-			// delete the old key
-			if ( IS_MCAST(pRA) ){
-				WAPI_TRACE(WAPI_API, "%s(): AE use new update MSK!!\n", __FUNCTION__);
-				pWapiSta->wapiMsk.keyId = pWapiSta->wapiMskUpdate.keyId;
-				memcpy(pWapiSta->wapiMsk.dataKey, pWapiSta->wapiMskUpdate.dataKey, 16);
-				memcpy(pWapiSta->wapiMsk.micKey, pWapiSta->wapiMskUpdate.micKey, 16);
-				pWapiSta->wapiMskUpdate.bTxEnable = pWapiSta->wapiMskUpdate.bSet = false;
-			}else{
-				WAPI_TRACE(WAPI_API, "%s(): AE use new update USK!!\n", __FUNCTION__);
-				pWapiSta->wapiUsk.keyId = pWapiSta->wapiUskUpdate.keyId;
-				memcpy(pWapiSta->wapiUsk.dataKey, pWapiSta->wapiUskUpdate.dataKey, 16);
-				memcpy(pWapiSta->wapiUsk.micKey, pWapiSta->wapiUskUpdate.micKey, 16);
-				pWapiSta->wapiUskUpdate.bTxEnable = pWapiSta->wapiUskUpdate.bSet = false;
-			}
-		}
-	}else{
-		WAPI_TRACE(WAPI_ERR, "%s:  Check MIC Error, Dropped !!!!\n", __FUNCTION__);
-		return false;
-	}
-
-	pos = pskb->data;
-	memmove(pos+padapter->wapiInfo.extra_prefix_len, pos, IVOffset);
-	skb_pull(pskb, padapter->wapiInfo.extra_prefix_len);
-
-	WAPI_TRACE(WAPI_RX, "<=========%s\n", __FUNCTION__);
-
-	return true;
-}
-
-u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe)
-{
-
-	u8	*pframe;
-	u32 res = _SUCCESS;
-
-	WAPI_TRACE(WAPI_TX, "=========>%s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!padapter->wapiInfo.bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_TX, "<========== %s, WAPI not supported or enabled!\n", __FUNCTION__);
-		return _FAIL;
-	}
-
-	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
-		return _FAIL;
-
-	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
-
-	SecSWSMS4Encryption(padapter, pxmitframe);
-
-	WAPI_TRACE(WAPI_TX, "<=========%s\n", __FUNCTION__);
-	return res;
-}
-
-u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe)
-{
-	u8	*pframe;
-	u32 res = _SUCCESS;
-
-	WAPI_TRACE(WAPI_RX, "=========>%s\n", __FUNCTION__);
-
-	if ((!padapter->WapiSupport) || (!padapter->wapiInfo.bWapiEnable))
-	{
-		WAPI_TRACE(WAPI_RX, "<========== %s, WAPI not supported or enabled!\n", __FUNCTION__);
-		return _FAIL;
-	}
-
-
-	//drop packet when hw decrypt fail
-       //return tempraily
-	return _FAIL;
-
-	//pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-
-	if (false == SecSWSMS4Decryption(padapter, precvframe, &padapter->recvpriv))
-	{
-		WAPI_TRACE(WAPI_ERR, "%s():SMS4 decrypt frame error\n",__FUNCTION__);
-		return _FAIL;
-	}
-
-	WAPI_TRACE(WAPI_RX, "<=========%s\n", __FUNCTION__);
-	return res;
-}
-
-#else
-
-u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe)
-{
-	WAPI_TRACE(WAPI_TX, "=========>Dummy %s\n", __FUNCTION__);
-	WAPI_TRACE(WAPI_TX, "<=========Dummy %s\n", __FUNCTION__);
-	return _SUCCESS;
-}
-
-u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe)
-{
-	WAPI_TRACE(WAPI_RX, "=========>Dummy %s\n", __FUNCTION__);
-	WAPI_TRACE(WAPI_RX, "<=========Dummy %s\n", __FUNCTION__);
-	return _SUCCESS;
-}
-
-#endif
-
-#endif
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_wlan_util.c linux/3rdparty/rtl8723bs/core/rtw_wlan_util.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_wlan_util.c	2015-05-10 14:36:05.680668035 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_wlan_util.c	2015-05-07 17:46:55.000000000 +0300
@@ -101,41 +101,6 @@ int cckratesonly_included(unsigned char
 	return true;
 }
 
-u8 networktype_to_raid(_adapter *adapter,struct sta_info *psta)
-{
-	unsigned char raid;
-	switch(psta->wireless_mode)
-	{
-		case WIRELESS_11B:
-			raid = RATR_INX_WIRELESS_B;
-			break;
-		case WIRELESS_11A:
-		case WIRELESS_11G:
-			raid = RATR_INX_WIRELESS_G;
-			break;
-		case WIRELESS_11BG:
-			raid = RATR_INX_WIRELESS_GB;
-			break;
-		case WIRELESS_11_24N:
-		case WIRELESS_11_5N:
-			raid = RATR_INX_WIRELESS_N;
-			break;
-		case WIRELESS_11A_5N:
-		case WIRELESS_11G_24N:
-			raid = RATR_INX_WIRELESS_NG;
-			break;
-		case WIRELESS_11BG_24N:
-			raid = RATR_INX_WIRELESS_NGB;
-			break;
-		default:
-			raid = RATR_INX_WIRELESS_GB;
-			break;	
-
-	}
-	return raid;
-	
-}
-
 u8 networktype_to_raid_ex(_adapter *adapter, struct sta_info *psta)
 {
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
@@ -199,46 +164,6 @@ u8 networktype_to_raid_ex(_adapter *adap
 	
 }
 
-u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
-{
-	u8 network_type = 0;
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	
-
-	if(pmlmeext->cur_channel > 14)
-	{
-		if (pmlmeinfo->VHT_enable)
-			network_type = WIRELESS_11AC;
-		else if (pmlmeinfo->HT_enable)
-			network_type = WIRELESS_11_5N;
-
-		network_type |= WIRELESS_11A;
-	}
-	else
-	{
-		if (pmlmeinfo->HT_enable)
-		{
-			network_type = WIRELESS_11_24N;
-		}
-
-		if ((cckratesonly_included(rate, ratelen)) == true)
-		{
-			network_type |= WIRELESS_11B;
-		}
-		else if((cckrates_included(rate, ratelen)) == true)
-		{
-			network_type |= WIRELESS_11BG;
-		}
-		else
-		{
-			network_type |= WIRELESS_11G;
-		}
-	}
-		
-	return 	network_type;
-}
-
 unsigned char ratetbl_val_2wifirate(unsigned char rate);
 unsigned char ratetbl_val_2wifirate(unsigned char rate)
 {
@@ -522,59 +447,6 @@ inline void rtw_set_oper_choffset(_adapt
 	adapter_to_dvobj(adapter)->oper_ch_offset = offset;
 }
 
-u8 rtw_get_offset_by_ch(u8 channel)
-{
-	u8 offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-
-	if(channel>=1 && channel<=4)
-	{
-		offset = HAL_PRIME_CHNL_OFFSET_LOWER;
-	}
-	else if(channel>=5 && channel<=14)
-	{
-		offset = HAL_PRIME_CHNL_OFFSET_UPPER;						
-	}
-	else
-	{
-		switch(channel)
-		{
-			case 36:
-			case 44:
-			case 52:
-			case 60:
-			case 100:
-			case 108:
-			case 116:
-			case 124:
-			case 132:
-			case 149:
-			case 157:
-				offset = HAL_PRIME_CHNL_OFFSET_LOWER;				
-				break;		
-			case 40:
-			case 48:
-			case 56:
-			case 64:
-			case 104:
-			case 112:
-			case 120:
-			case 128:
-			case 136:
-			case 153:
-			case 161:				
-				offset = HAL_PRIME_CHNL_OFFSET_UPPER;				
-				break;				
-			default:
-				offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-				break;
-		}
-
-	}
-
-	return offset;
-		
-}
-
 u8	rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset)
 {
 	u8	center_ch = channel;
@@ -607,11 +479,6 @@ u8	rtw_get_center_ch(u8 channel, u8 chnl
 	return center_ch;
 }
 
-inline u32 rtw_get_on_oper_ch_time(_adapter *adapter)
-{
-	return adapter_to_dvobj(adapter)->on_oper_ch_time;
-}
-
 inline unsigned long rtw_get_on_cur_ch_time(_adapter *adapter)
 {
 	if (adapter->mlmeextpriv.cur_channel == adapter_to_dvobj(adapter)->oper_channel)
@@ -624,29 +491,15 @@ void SelectChannel(_adapter *padapter, u
 {
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;	
 
-	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
+	if (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))
+		return;
 	
 	//saved channel info
 	rtw_set_oper_ch(padapter, channel);
 
 	rtw_hal_set_chan(padapter, channel);
 	
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
-}
-
-void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset)
-{
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-
-	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex), NULL);
-
-	//saved bw info
-	rtw_set_oper_bw(padapter, bwmode);
-	rtw_set_oper_choffset(padapter, channel_offset);
-
-	rtw_hal_set_bwmode(padapter, (CHANNEL_WIDTH)bwmode, channel_offset);
-
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex), NULL);
+	mutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));
 }
 
 void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
@@ -672,7 +525,8 @@ void set_channel_bwmode(_adapter *padapt
 	}
 
 	//set Channel
-	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
+	if (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->setch_mutex)))
+		return;
 
 	//saved channel/bw info
 	rtw_set_oper_ch(padapter, channel);
@@ -681,23 +535,7 @@ void set_channel_bwmode(_adapter *padapt
 
 	rtw_hal_set_chnl_bw(padapter, center_ch, bwmode, channel_offset, chnl_offset80); // set center channel
 
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
-}
-
-int get_bsstype(unsigned short capability)
-{
-	if (capability & BIT(0))
-	{
-		return WIFI_FW_AP_STATE;
-	}
-	else if (capability & BIT(1))
-	{
-		return WIFI_FW_ADHOC_STATE;
-	}
-	else
-	{
-		return 0;		
-	}
+	mutex_unlock(&(adapter_to_dvobj(padapter)->setch_mutex));
 }
 
 __inline u8 *get_my_bssid(WLAN_BSSID_EX *pnetwork)
@@ -784,14 +622,6 @@ unsigned int decide_wait_for_beacon_time
 	}
 }
 
-void CAM_empty_entry(
-	PADAPTER     	Adapter,	
-	u8 			ucIndex
-)
-{
-	rtw_hal_set_hwreg(Adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
-}
-
 void invalidate_cam_all(_adapter *padapter)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
@@ -800,10 +630,10 @@ void invalidate_cam_all(_adapter *padapt
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 	cam_ctl->bitmap = 0;
 	memset(dvobj->cam_cache, 0, sizeof(struct cam_entry_cache)*TOTAL_CAM_ENTRY);
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 }
 
 static u32 _ReadCAM(_adapter *padapter ,u32 addr)
@@ -875,12 +705,8 @@ void _clear_cam_entry(_adapter *padapter
 
 inline void write_cam(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)
 {
-#ifdef CONFIG_WRITE_CACHE_ONLY
-	write_cam_cache(adapter, id ,ctrl, mac, key);
-#else
 	_write_cam(adapter, id, ctrl, mac, key);
 	write_cam_cache(adapter, id ,ctrl, mac, key);
-#endif
 }
 
 inline void clear_cam_entry(_adapter *adapter, u8 id)
@@ -896,9 +722,9 @@ inline void write_cam_from_cache(_adapte
 	_irqL irqL;
 	struct cam_entry_cache cache;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 	memcpy(&cache, &dvobj->cam_cache[id], sizeof(struct cam_entry_cache));
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 
 	_write_cam(adapter, id, cache.ctrl, cache.mac, cache.key);
 }
@@ -909,13 +735,13 @@ void write_cam_cache(_adapter *adapter,
 	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
 	_irqL irqL;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 
 	dvobj->cam_cache[id].ctrl = ctrl;
 	memcpy(dvobj->cam_cache[id].mac, mac, ETH_ALEN);
 	memcpy(dvobj->cam_cache[id].key, key, 16);
 
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 }
 
 void clear_cam_cache(_adapter *adapter, u8 id)
@@ -924,54 +750,11 @@ void clear_cam_cache(_adapter *adapter,
 	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
 	_irqL irqL;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 
 	memset(&(dvobj->cam_cache[id]), 0, sizeof(struct cam_entry_cache));
 
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
-}
-
-s16 rtw_get_camid(_adapter *adapter, struct sta_info *sta, s16 kid)
-{
-	u8 macid;
-	s16 camid;
-
-	//cam_entry:
-	//0~3 for default key
-
-	//for concurrent mode (ap+sta, sta+sta):
-	//default key is disable, using sw encrypt/decrypt
-	//camid 0, 1, 2, 3 is default entry for default key/group key
-	//macid = 1 is for bc/mc stainfo, no mapping to camid
-	//macid = 0 mapping to camid 4
-	//for macid >=2, camid = macid+3;
-
-	if (sta) {
-		struct mlme_ext_info *mlmeinfo = &adapter->mlmeextpriv.mlmext_info;
-		macid = sta->mac_id;
-
-		if((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {
-			if((macid == 1) || (macid>(NUM_STA-4))){
-				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" failed, mac_id=%d\n", FUNC_ADPT_ARG(adapter), macid);
-				camid = -1;
-				goto exit;
-			}
-		}
-
-		if(macid==0)
-			camid = 4;
-		else if(macid >=2)
-			camid = macid + 3;
-		else
-			camid = 4;
-	}
-	else {
-		/* default key is disabled */
-		camid = -1;
-	}
-
-exit:
-	return (s16)camid;
+	spin_unlock_bh(&cam_ctl->lock);
 }
 
 static bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id)
@@ -1026,9 +809,9 @@ s16 rtw_camid_search(_adapter *adapter,
 	_irqL irqL;
 	s16 cam_id = -1;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 	cam_id = _rtw_camid_search(adapter, addr, kid);
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 
 	return cam_id;
 }
@@ -1039,75 +822,70 @@ s16 rtw_camid_alloc(_adapter *adapter, s
 	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
 	_irqL irqL;
 	s16 cam_id = -1;
+	struct mlme_ext_info *mlmeinfo;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 
-#ifdef DYNAMIC_CAMID_ALLOC
-	{
-		struct mlme_ext_info *mlmeinfo = &adapter->mlmeextpriv.mlmext_info;
+	mlmeinfo = &adapter->mlmeextpriv.mlmext_info;
 
-		if((((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) || ((mlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
-			&& !sta) {
-			/* AP/Ad-hoc mode group key: static alloction to default key by key ID */
-			if (kid > 3) {
-				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key with invalid key id:%u\n"
-					, FUNC_ADPT_ARG(adapter), kid);
-				rtw_warn_on(1);
-				goto bitmap_handle;
-			}
-
-			cam_id = kid;
+	if((((mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) || ((mlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
+		&& !sta) {
+		/* AP/Ad-hoc mode group key: static alloction to default key by key ID */
+		if (kid > 3) {
+			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key with invalid key id:%u\n"
+				, FUNC_ADPT_ARG(adapter), kid);
+			rtw_warn_on(1);
+			goto bitmap_handle;
 		}
-		else {
-			int i;
-			u8 *addr = sta?sta->hwaddr:NULL;
-
-			if(!sta) {
-				if (!(mlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
-					/* bypass STA mode group key setting before connected(ex:WEP) because bssid is not ready */
-					goto bitmap_handle;
-				}
 
-				addr = get_bssid(&adapter->mlmepriv);
-			}
+		cam_id = kid;
+	}
+	else {
+		int i;
+		u8 *addr = sta?sta->hwaddr:NULL;
 
-			if ((i = _rtw_camid_search(adapter, addr, kid)) >= 0) {
-				/* Fix issue that pairwise and group key have same key id. Pairwise key first, group key can overwirte group only(ex: rekey) */
-				if (sta || _rtw_camid_is_gk(adapter, i) == true)
-					cam_id = i;
-				else
-					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"
-						, FUNC_ADPT_ARG(adapter), kid);
+		if(!sta) {
+			if (!(mlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
+				/* bypass STA mode group key setting before connected(ex:WEP) because bssid is not ready */
 				goto bitmap_handle;
 			}
 
-			for (i=4;i<TOTAL_CAM_ENTRY;i++)
-				if (!(cam_ctl->bitmap & BIT(i)))
-					break;
+			addr = get_bssid(&adapter->mlmepriv);
+		}
 
-			if (i == TOTAL_CAM_ENTRY) {
-				if (sta)
-					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pairwise key with "MAC_FMT" id:%u no room\n"
-					, FUNC_ADPT_ARG(adapter), MAC_ARG(sta->hwaddr), kid);
-				else
-					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u no room\n"
+		if ((i = _rtw_camid_search(adapter, addr, kid)) >= 0) {
+			/* Fix issue that pairwise and group key have same key id. Pairwise key first, group key can overwirte group only(ex: rekey) */
+			if (sta || _rtw_camid_is_gk(adapter, i) == true)
+				cam_id = i;
+			else
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"
 					, FUNC_ADPT_ARG(adapter), kid);
-				rtw_warn_on(1);
-				goto bitmap_handle;
-			}
+			goto bitmap_handle;
+		}
+
+		for (i=4;i<TOTAL_CAM_ENTRY;i++)
+			if (!(cam_ctl->bitmap & BIT(i)))
+				break;
 
-			cam_id = i;
+		if (i == TOTAL_CAM_ENTRY) {
+			if (sta)
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" pairwise key with "MAC_FMT" id:%u no room\n"
+				, FUNC_ADPT_ARG(adapter), MAC_ARG(sta->hwaddr), kid);
+			else
+				DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u no room\n"
+				, FUNC_ADPT_ARG(adapter), kid);
+			rtw_warn_on(1);
+			goto bitmap_handle;
 		}
+
+		cam_id = i;
 	}
-#else
-	cam_id = rtw_get_camid(adapter, sta, kid);
-#endif /* DYNAMIC_CAMID_ALLOC */
 
 bitmap_handle:
 	if (cam_id >= 0)
 		cam_ctl->bitmap |= BIT(cam_id);
 
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 
 	return cam_id;
 }
@@ -1118,12 +896,12 @@ void rtw_camid_free(_adapter *adapter, u
 	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
 	_irqL irqL;
 
-	_enter_critical_bh(&cam_ctl->lock, &irqL);
+	spin_lock_bh(&cam_ctl->lock);
 
 	if (cam_id < TOTAL_CAM_ENTRY)
 		cam_ctl->bitmap &= ~(BIT(cam_id));
 
-	_exit_critical_bh(&cam_ctl->lock, &irqL);
+	spin_unlock_bh(&cam_ctl->lock);
 }
 
 int allocate_fw_sta_entry(_adapter *padapter)
@@ -1153,9 +931,7 @@ void flush_all_cam_entry(_adapter *padap
 
 	invalidate_cam_all(padapter);
 	/* clear default key related key search setting */
-	#ifdef DYNAMIC_CAMID_ALLOC
 	rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)false);
-	#endif
 
 	memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
 	
@@ -1221,8 +997,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 
 	acm_mask = 0;
 
-	if (IsSupported5G(pmlmeext->cur_wireless_mode) || 
-		(pmlmeext->cur_wireless_mode & WIRELESS_11_24N) )
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11_24N)
 		aSifsTime = 16;
 	else
 		aSifsTime = 10;
@@ -1916,11 +1691,11 @@ int rtw_check_bcn_info(ADAPTER *Adapter,
 		}
 	}
 
-	rtw_mfree((u8 *)bssid, sizeof(WLAN_BSSID_EX));
+	kfree((u8 *)bssid);
 	return _SUCCESS;
 
 _mismatch:
-	rtw_mfree((u8 *)bssid, sizeof(WLAN_BSSID_EX));
+	kfree((u8 *)bssid);
 
 	if (pmlmepriv->NumOfBcnInfoChkFail == 0)
 	{
@@ -2030,190 +1805,6 @@ unsigned int is_ap_in_tkip(_adapter *pad
 	
 }
 
-unsigned int should_forbid_n_rate(_adapter * padapter)
-{
-	u32 i;
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	WLAN_BSSID_EX  *cur_network = &pmlmepriv->cur_network.network;
-
-	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
-	{
-		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < cur_network->IELength;)
-		{
-			pIE = (PNDIS_802_11_VARIABLE_IEs)(cur_network->IEs + i);
-
-			switch (pIE->ElementID)
-			{
-				case _VENDOR_SPECIFIC_IE_:
-					if (!memcmp(pIE->data, RTW_WPA_OUI, 4) &&
-						((!memcmp((pIE->data + 12), WPA_CIPHER_SUITE_CCMP, 4)) ||
-						  (!memcmp((pIE->data + 16), WPA_CIPHER_SUITE_CCMP, 4))))
-						return false;
-					break;
-
-				case _RSN_IE_2_:
-					if  ((!memcmp((pIE->data + 8), RSN_CIPHER_SUITE_CCMP, 4))  ||
-					       (!memcmp((pIE->data + 12), RSN_CIPHER_SUITE_CCMP, 4)))
-					return false;
-
-				default:
-					break;
-			}
-
-			i += (pIE->Length + 2);
-		}
-
-		return true;
-	}
-	else
-	{
-		return false;
-	}
-
-}
-
-
-unsigned int is_ap_in_wep(_adapter *padapter)
-{
-	u32 i;
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
-
-	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
-	{
-		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
-		{
-			pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
-
-			switch (pIE->ElementID)
-			{
-				case _VENDOR_SPECIFIC_IE_:
-					if (!memcmp(pIE->data, RTW_WPA_OUI, 4))
-						return false;
-					break;
-
-				case _RSN_IE_2_:
-					return false;
-
-				default:
-					break;
-			}
-
-			i += (pIE->Length + 2);
-		}
-
-		return true;
-	}
-	else
-	{
-		return false;
-	}
-
-}
-
-int wifirate2_ratetbl_inx(unsigned char rate);
-int wifirate2_ratetbl_inx(unsigned char rate)
-{
-	int	inx = 0;
-	rate = rate & 0x7f;
-
-	switch (rate) 
-	{
-		case 54*2:
-			inx = 11;
-			break;
-
-		case 48*2:
-			inx = 10;
-			break;
-
-		case 36*2:
-			inx = 9;
-			break;
-
-		case 24*2:
-			inx = 8;
-			break;
-			
-		case 18*2:
-			inx = 7;
-			break;
-
-		case 12*2:
-			inx = 6;
-			break;
-
-		case 9*2:
-			inx = 5;
-			break;
-			
-		case 6*2:
-			inx = 4;
-			break;
-
-		case 11*2:
-			inx = 3;
-			break;
-		case 11:
-			inx = 2;
-			break;
-
-		case 2*2:
-			inx = 1;
-			break;
-		
-		case 1*2:
-			inx = 0;
-			break;
-
-	}
-	return inx;	
-}
-
-unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz)
-{
-	unsigned int i, num_of_rate;
-	unsigned int mask = 0;
-	
-	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
-		
-	for (i = 0; i < num_of_rate; i++)
-	{
-		if ((*(ptn + i)) & 0x80)
-		{
-			mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
-		}
-	}
-	return mask;
-}
-
-unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
-{
-	unsigned int i, num_of_rate;
-	unsigned int mask = 0;
-	
-	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
-		
-	for (i = 0; i < num_of_rate; i++)
-	{
-		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
-	}
-
-	return mask;
-}
-
-unsigned int update_MCS_rate(struct HT_caps_element *pHT_caps)
-{
-	unsigned int mask = 0;
-	
-	mask = ((pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
-						
-	return mask;
-}
-
 int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode)
 {
 	unsigned char					bit_offset;
@@ -2252,24 +1843,6 @@ unsigned char get_highest_rate_idx(u32 m
 	return rate_idx;
 }
 
-unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps);
-unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
-{
-	int i, mcs_rate;
-	
-	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
-	
-	for (i = 15; i >= 0; i--)
-	{
-		if (mcs_rate & (0x1 << i))
-		{
-			break;
-		}
-	}
-	
-	return i;
-}
-
 void Update_RA_Entry(_adapter *padapter, struct sta_info *psta)
 {
 	rtw_hal_update_ra_mask(psta, 0);
@@ -2287,38 +1860,6 @@ void set_sta_rate(_adapter *padapter, st
 	enable_rate_adaptive(padapter, psta);
 }
 
-// Update RRSR and Rate for USERATE
-void update_tx_basic_rate(_adapter *padapter, u8 wirelessmode)
-{
-	NDIS_802_11_RATES_EX	supported_rates;
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-#ifdef CONFIG_INTEL_WIDI
-	if (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_NONE)
-		return;
-#endif //CONFIG_INTEL_WIDI
-
-	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
-
-	//clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band.
-	if(pmlmeext->cur_channel > 14)
-		wirelessmode &= ~(WIRELESS_11B);
-
-	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B)) {
-		memcpy(supported_rates, rtw_basic_rate_cck, 4);
-	} else if (wirelessmode & WIRELESS_11B) {
-		memcpy(supported_rates, rtw_basic_rate_mix, 7);
-	} else {
-		memcpy(supported_rates, rtw_basic_rate_ofdm, 3);
-	}
-
-	if (wirelessmode & WIRELESS_11B)
-		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
-	else
-		update_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);
-
-	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, supported_rates);
-}
-
 unsigned char check_assoc_AP(u8 *pframe, uint len)
 {
 	unsigned int	i;
@@ -2338,7 +1879,7 @@ unsigned char check_assoc_AP(u8 *pframe,
 				}
 				else if ((!memcmp(pIE->data, BROADCOM_OUI1, 3))
 							|| (!memcmp(pIE->data, BROADCOM_OUI2, 3))
-							|| (!memcmp(pIE->data, BROADCOM_OUI2, 3)))
+							|| (!memcmp(pIE->data, BROADCOM_OUI3, 3)))
 				{
 					DBG_871X("link to Broadcom AP\n");
 					return HT_IOT_PEER_BROADCOM;
@@ -2797,7 +2338,7 @@ void rtw_alloc_macid(_adapter *padapter,
 		return;
 	}
 
-	_enter_critical_bh(&pdvobj->lock, &irqL);
+	spin_lock_bh(&pdvobj->lock);
 	for(i=0; i<NUM_STA; i++)
 	{
 		if(pdvobj->macid[i] == false)
@@ -2806,7 +2347,7 @@ void rtw_alloc_macid(_adapter *padapter,
 			break;
 		}
 	}
-	_exit_critical_bh(&pdvobj->lock, &irqL);
+	spin_unlock_bh(&pdvobj->lock);
 
 	if( i > (NUM_STA-1))
 	{
@@ -2837,7 +2378,7 @@ void rtw_release_macid(_adapter *padapte
 		return;
 	}
 
-	_enter_critical_bh(&pdvobj->lock, &irqL);
+	spin_lock_bh(&pdvobj->lock);
 	if(psta->mac_id<NUM_STA && psta->mac_id !=1 )
 	{
 		if(pdvobj->macid[psta->mac_id] == true)
@@ -2848,7 +2389,7 @@ void rtw_release_macid(_adapter *padapte
 		}
 
 	}
-	_exit_critical_bh(&pdvobj->lock, &irqL);
+	spin_unlock_bh(&pdvobj->lock);
 
 }
 //For 8188E RA
@@ -2858,7 +2399,7 @@ u8 rtw_search_max_mac_id(_adapter *padap
 	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 	int i;
 	_irqL	irqL;	
-	_enter_critical_bh(&pdvobj->lock, &irqL);
+	spin_lock_bh(&pdvobj->lock);
 	for(i=(NUM_STA-1); i>=0 ; i--)
 	{
 		if(pdvobj->macid[i] == true)
@@ -2867,7 +2408,7 @@ u8 rtw_search_max_mac_id(_adapter *padap
 		}
 	}
 	max_mac_id = i;
-	_exit_critical_bh(&pdvobj->lock, &irqL);
+	spin_unlock_bh(&pdvobj->lock);
 
 	return max_mac_id;
 
@@ -2892,93 +2433,6 @@ _adapter *dvobj_get_port0_adapter(struct
 	return port0_iface;
 }
 
-/*
- * Description:
- * rtw_check_invalid_mac_address: 
- * This is only used for checking mac address valid or not.
- *
- * Input:
- * adapter: mac_address pointer.
- *
- * Output:
- * true: The mac address is invalid.
- * false: The mac address is valid.
- *
- * Auther: Isaac.Li
- */
-u8 rtw_check_invalid_mac_address(u8 *mac_addr) {
-	u8 null_mac_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
-	u8 multi_mac_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	u8 res = false;
-
-	if (!memcmp(mac_addr, null_mac_addr, ETH_ALEN)) {
-		res = true;
-		goto func_exit;
-	}
-
-	if (!memcmp(mac_addr, multi_mac_addr, ETH_ALEN)) {
-		res = true;
-		goto func_exit;
-	}
-
-	if (mac_addr[0] & BIT0) {
-		res = true;
-		goto func_exit;
-	}
-
-	if (mac_addr[0] & BIT1) {
-		res = true;
-		goto func_exit;
-	}
-
-func_exit:
-	return res;
-}
-
-/*
- * Description:
- * dump_TX_FIFO: This is only used to dump TX_FIFO for debug WoW mode offload
- * contant.
- *
- * Input:
- * adapter: adapter pointer.
- * page_num: The max. page number that user want to dump. 
- * page_size: page size of each page. eg. 128 bytes, 256 bytes.
- */
-void dump_TX_FIFO(_adapter* padapter, u8 page_num, u16 page_size){
-
-	int i;
-	u8 val = 0;
-	u8 base = 0;
-	u32 addr = 0;
-	u32 count = (page_size / 8);
-
-	if (page_num <= 0) {
-		DBG_871X("!!%s: incorrect input page_num paramter!\n", __func__);
-		return;
-	}
-
-	if (page_size < 128 || page_size > 256) {
-		DBG_871X("!!%s: incorrect input page_size paramter!\n", __func__);
-		return;
-	}
-
-	DBG_871X("+%s+\n", __func__);
-	val = rtw_read8(padapter, 0x106);
-	rtw_write8(padapter, 0x106, 0x69);
-	DBG_871X("0x106: 0x%02x\n", val);
-	base = rtw_read8(padapter, 0x209);
-	DBG_871X("0x209: 0x%02x\n", base);
-
-	addr = ((base) * page_size)/8;
-	for (i = 0 ; i < page_num * count ; i+=2) {
-		rtw_write32(padapter, 0x140, addr + i);
-		printk(" %08x %08x ", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
-		rtw_write32(padapter, 0x140, addr + i + 1);
-		printk(" %08x %08x \n", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
-	}
-}
-
 #ifdef CONFIG_GPIO_API
 int rtw_get_gpio(struct net_device *netdev, int gpio_num)
 {
@@ -3165,334 +2619,5 @@ void rtw_set_sec_pn(PADAPTER padapter)
 #define CIPHER_NONE "NONE"
 #define CIPHER_WPA_PSK "WPA-PSK"
 #define CIPHER_WPA_EAP "WPA-EAP IEEE8021X"
-/*
- *  SSIDs list parsing from cscan tlv list
- */
-int rtw_parse_ssid_list_tlv(char** list_str, pno_ssid_t* ssid,
-	int max, int *bytes_left) {
-	char* str;
-
-	int idx = 0;
-
-	if ((list_str == NULL) || (*list_str == NULL) || (*bytes_left < 0)) {
-		DBG_871X("%s error paramters\n", __func__);
-		return -1;
-	}
-
-	str = *list_str;
-	while (*bytes_left > 0) {
-
-		if (str[0] != CSCAN_TLV_TYPE_SSID_IE) {
-			*list_str = str;
-			DBG_871X("nssid=%d left_parse=%d %d\n", idx, *bytes_left, str[0]);
-			return idx;
-		}
-
-		/* Get proper CSCAN_TLV_TYPE_SSID_IE */
-		*bytes_left -= 1;
-		str += 1;
-
-		if (str[0] == 0) {
-			/* Broadcast SSID */
-			ssid[idx].SSID_len = 0;
-			memset((char*)ssid[idx].SSID, 0x0, WLAN_SSID_MAXLEN);
-			*bytes_left -= 1;
-			str += 1;
-
-			DBG_871X("BROADCAST SCAN  left=%d\n", *bytes_left);
-		}
-		else if (str[0] <= WLAN_SSID_MAXLEN) {
-			 /* Get proper SSID size */
-			ssid[idx].SSID_len = str[0];
-			*bytes_left -= 1;
-			str += 1;
-
-			/* Get SSID */
-			if (ssid[idx].SSID_len > *bytes_left) {
-				DBG_871X("%s out of memory range len=%d but left=%d\n",
-				__func__, ssid[idx].SSID_len, *bytes_left);
-				return -1;
-			}
-
-			memcpy((char*)ssid[idx].SSID, str, ssid[idx].SSID_len);
-
-			*bytes_left -= ssid[idx].SSID_len;
-			str += ssid[idx].SSID_len;
-
-			DBG_871X("%s :size=%d left=%d\n",
-				(char*)ssid[idx].SSID, ssid[idx].SSID_len, *bytes_left);
-		}
-		else {
-			DBG_871X("### SSID size more that %d\n", str[0]);
-			return -1;
-		}
-
-		if (idx++ >  max) {
-			DBG_871X("%s number of SSIDs more that %d\n", __func__, idx);
-			return -1;
-		}
-	}
-
-	*list_str = str;
-	return idx;
-}
-
-int rtw_parse_cipher_list(struct pno_nlo_info *nlo_info, char* list_str) {
-
-	char *pch, *pnext, *pend;
-	u8 key_len = 0, index = 0;
-
-	pch = list_str;
-
-	if (nlo_info == NULL || list_str == NULL) {
-		DBG_871X("%s error paramters\n", __func__);
-		return -1;
-	}
-
-	while (strlen(pch) != 0) {
-		pnext = strstr(pch, "key_mgmt=");
-		if (pnext != NULL) {
-			pch = pnext + strlen(CIPHER_IE);
-			pend = strstr(pch, "}");
-			if (strncmp(pch, CIPHER_NONE,
-						strlen(CIPHER_NONE)) == 0) {
-				nlo_info->ssid_cipher_info[index] = 0x00;
-			} else if (strncmp(pch, CIPHER_WPA_PSK,
-						strlen(CIPHER_WPA_PSK)) == 0) {
-				nlo_info->ssid_cipher_info[index] = 0x66;
-			} else if (strncmp(pch, CIPHER_WPA_EAP,
-						strlen(CIPHER_WPA_EAP)) == 0) {
-				nlo_info->ssid_cipher_info[index] = 0x01;
-			}
-			index ++;
-			pch = pend + 1;
-		} else {
-			break;
-		}
-	}
-	return 0;
-}
-
-int rtw_dev_nlo_info_set(struct pno_nlo_info *nlo_info, pno_ssid_t* ssid,
-	int num, int pno_time, int pno_repeat, int pno_freq_expo_max) {
-
-	int i = 0;
-	struct file *fp;
-	mm_segment_t fs;
-	loff_t pos = 0;
-	u8 *source = NULL;
-	long len = 0;
-
-	DBG_871X("+%s+\n", __func__);
-
-	nlo_info->fast_scan_period = pno_time;
-	nlo_info->ssid_num = num & BIT_LEN_MASK_32(8);
-	nlo_info->slow_scan_period = (pno_time * 2);
-	nlo_info->fast_scan_iterations = 5;
-
-	//TODO: channel list and probe index is all empty.
-	for (i = 0 ; i < num ; i++) {
-		nlo_info->ssid_length[i]
-			= ssid[i].SSID_len;
-	}
-
-	/* cipher array */
-	fp = filp_open("/data/misc/wifi/wpa_supplicant.conf", O_RDONLY,  0644);
-	if (IS_ERR(fp)) {
-		DBG_871X("Error, wpa_supplicant.conf doesn't exist.\n");
-		DBG_871X("Error, cipher array using default value.\n");
-		return 0;
-	}
-
-	len = i_size_read(fp->f_path.dentry->d_inode);
-	if (len < 0 || len > 2048) {
-		DBG_871X("Error, file size is bigger than 2048.\n");
-		DBG_871X("Error, cipher array using default value.\n");
-		return 0;
-	}
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	source = rtw_zmalloc(2048);
-
-	if (source != NULL) {
-		len = vfs_read(fp, source, len, &pos);
-		rtw_parse_cipher_list(nlo_info, source);
-		rtw_mfree(source, 2048);
-	}
-
-	set_fs(fs);
-	filp_close(fp, NULL);
-
-	DBG_871X("-%s-\n", __func__);
-	return 0;
-}
-
-int rtw_dev_ssid_list_set(struct pno_ssid_list *pno_ssid_list,
-	pno_ssid_t* ssid, u8 num) {
-
-	int i = 0;
-	if(num > MAX_PNO_LIST_COUNT)
-		num = MAX_PNO_LIST_COUNT;
-
-	for (i = 0 ; i < num ; i++) {
-		memcpy(&pno_ssid_list->node[i].SSID,
-			ssid[i].SSID, ssid[i].SSID_len);
-	}
-	return 0;
-}
-
-int rtw_dev_scan_info_set(_adapter *padapter, pno_ssid_t* ssid,
-	unsigned char ch, unsigned char ch_offset, unsigned short bw_mode) {
-
-	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
-	struct pno_scan_info *scan_info = pwrctl->pscan_info;
-	int i;
-
-	scan_info->channel_num = MAX_SCAN_LIST_COUNT;
-	scan_info->orig_ch = ch;
-	scan_info->orig_bw = bw_mode;
-	scan_info->orig_40_offset = ch_offset;
-
-	for(i = 0 ; i < scan_info->channel_num ; i++) {
-		if (i < 11)
-			scan_info->ssid_channel_info[i].active = 1;
-		else
-			scan_info->ssid_channel_info[i].active = 0;
-
-		scan_info->ssid_channel_info[i].timeout = 100;
-
-		scan_info->ssid_channel_info[i].tx_power =
-			PHY_GetTxPowerIndex(padapter, 0, 0x02, bw_mode, i+1);
-
-		scan_info->ssid_channel_info[i].channel = i+1;
-	}
 
-	DBG_871X("%s, channel_num: %d, orig_ch: %d, orig_bw: %d orig_40_offset: %d\n",
-		__func__, scan_info->channel_num, scan_info->orig_ch,
-		scan_info->orig_bw, scan_info->orig_40_offset);
-	return 0;
-}
-
-int rtw_dev_pno_set(struct net_device *net, pno_ssid_t* ssid, int num,
-	int pno_time, int pno_repeat, int pno_freq_expo_max) {
-
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-
-	int ret = -1;
-
-	if (num == 0) {
-		DBG_871X("%s, nssid is zero, no need to setup pno ssid list\n", __func__);
-		return 0;
-	}
-
-	if (pwrctl == NULL) {
-		DBG_871X("%s, ERROR: pwrctl is NULL\n", __func__);
-		return -1;
-	} else {
-		pwrctl->pnlo_info =
-			(pno_nlo_info_t*)rtw_zmalloc(sizeof(pno_nlo_info_t));
-		pwrctl->pno_ssid_list =
-			(pno_ssid_list_t*)rtw_zmalloc(sizeof(pno_ssid_list_t));
-		pwrctl->pscan_info =
-			(pno_scan_info_t*)rtw_zmalloc(sizeof(pno_scan_info_t));
-	}
-
-	if (pwrctl->pnlo_info == NULL ||
-		pwrctl->pscan_info == NULL ||
-		pwrctl->pno_ssid_list == NULL){
-		DBG_871X("%s, ERROR: alloc nlo_info, ssid_list, scan_info fail\n", __func__);
-		goto failing;
-	}
-
-	pwrctl->pno_in_resume = false;
-
-	pwrctl->pno_inited = true;
-	/* NLO Info */
-	ret = rtw_dev_nlo_info_set(pwrctl->pnlo_info, ssid, num,
-			pno_time, pno_repeat, pno_freq_expo_max);
-
-	/* SSID Info */
-	ret = rtw_dev_ssid_list_set(pwrctl->pno_ssid_list, ssid, num);
-
-	/* SCAN Info */
-	ret = rtw_dev_scan_info_set(padapter, ssid, pmlmeext->cur_channel,
-			pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
-
-	DBG_871X("+%s num: %d, pno_time: %d, pno_repeat:%d, pno_freq_expo_max:%d+\n",
-		 __func__, num, pno_time, pno_repeat, pno_freq_expo_max);
-
-	return 0;
-
-failing:
-	if (pwrctl->pnlo_info) {
-		rtw_mfree(pwrctl->pnlo_info, sizeof(pno_nlo_info_t));
-		pwrctl->pnlo_info = NULL;
-	}
-	if (pwrctl->pno_ssid_list) {
-		rtw_mfree(pwrctl->pno_ssid_list, sizeof(pno_ssid_list_t));
-		pwrctl->pno_ssid_list = NULL;
-	}
-	if (pwrctl->pscan_info) {
-		rtw_mfree(pwrctl->pscan_info, sizeof(pno_scan_info_t));
-		pwrctl->pscan_info = NULL;
-	}
-
-	return -1;
-}
-
-#ifdef CONFIG_PNO_SET_DEBUG
-void rtw_dev_pno_debug(struct net_device *net) {
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
-	int i = 0, j = 0;
-
-	DBG_871X("*******NLO_INFO********\n");
-	DBG_871X("ssid_num: %d\n", pwrctl->pnlo_info->ssid_num);
-	DBG_871X("fast_scan_iterations: %d\n",
-			pwrctl->pnlo_info->fast_scan_iterations);
-	DBG_871X("fast_scan_period: %d\n", pwrctl->pnlo_info->fast_scan_period);
-	DBG_871X("slow_scan_period: %d\n", pwrctl->pnlo_info->slow_scan_period);
-	DBG_871X("ssid_length: ");
-	for (i = 0 ; i < MAX_PNO_LIST_COUNT ; i++) {
-		printk("%d, ", pwrctl->pnlo_info->ssid_length[i]);
-	}
-	DBG_871X("\n");
-
-	DBG_871X("cipher_info: ");
-	for (i = 0 ; i < MAX_PNO_LIST_COUNT ; i++) {
-		DBG_871X("%d, ", pwrctl->pnlo_info->ssid_cipher_info[i]);
-	}
-	DBG_871X("\n");
-
-	DBG_871X("channel_info: ");
-	for (i = 0 ; i < MAX_PNO_LIST_COUNT ; i++) {
-		DBG_871X("%d, ", pwrctl->pnlo_info->ssid_channel_info[i]);
-	}
-	DBG_871X("\n");
-
-	DBG_871X("******SSID_LISD******\n");
-	for (i = 0 ; i < MAX_PNO_LIST_COUNT ; i++) {
-		DBG_871X("[%d]SSID: %s \n", i,
-			pwrctl->pno_ssid_list->node[i].SSID);
-	}
-
-	DBG_871X("******SCAN_INFO******\n");
-	DBG_871X("ch_num: %d\n", pwrctl->pscan_info->channel_num);
-	DBG_871X("orig_ch: %d\n", pwrctl->pscan_info->orig_ch);
-	DBG_871X("orig bw: %d\n", pwrctl->pscan_info->orig_bw);
-	DBG_871X("orig 40 offset: %d\n", pwrctl->pscan_info->orig_40_offset);
-	for(i = 0 ; i < MAX_SCAN_LIST_COUNT ; i++) {
-		DBG_871X("[%02d] avtive:%d, timeout:%d, tx_power:%d, ch:%02d\n",
-			i, pwrctl->pscan_info->ssid_channel_info[i].active,
-			pwrctl->pscan_info->ssid_channel_info[i].timeout,
-			pwrctl->pscan_info->ssid_channel_info[i].tx_power,
-			pwrctl->pscan_info->ssid_channel_info[i].channel);
-	}
-	DBG_871X("*****************\n");
-}
-#endif //CONFIG_PNO_SET_DEBUG
 #endif //CONFIG_PNO_SUPPORT
diff -Nurp linux/3rdparty/rtl8723bs.old/core/rtw_xmit.c linux/3rdparty/rtl8723bs/core/rtw_xmit.c
--- linux/3rdparty/rtl8723bs.old/core/rtw_xmit.c	2015-05-10 14:36:05.681668046 +0300
+++ linux/3rdparty/rtl8723bs/core/rtw_xmit.c	2015-05-07 17:46:55.000000000 +0300
@@ -27,7 +27,7 @@ static u8 RFC1042_OUI[P80211_OUI_LEN] =
 static void _init_txservq(struct tx_servq *ptxservq)
 {
 _func_enter_;
-	_rtw_init_listhead(&ptxservq->tx_pending);
+	INIT_LIST_HEAD(&ptxservq->tx_pending);
 	_rtw_init_queue(&ptxservq->sta_pending);
 	ptxservq->qcnt = 0;
 _func_exit_;		
@@ -50,8 +50,8 @@ _func_enter_;
 	_init_txservq(&psta_xmitpriv->bk_q);
 	_init_txservq(&psta_xmitpriv->vi_q);
 	_init_txservq(&psta_xmitpriv->vo_q);
-	_rtw_init_listhead(&psta_xmitpriv->legacy_dz);
-	_rtw_init_listhead(&psta_xmitpriv->apsd);
+	INIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);
+	INIT_LIST_HEAD(&psta_xmitpriv->apsd);
 	
 _func_exit_;	
 
@@ -66,7 +66,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	
 _func_enter_;   	
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc().
 	//memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
 	
 	spin_lock_init(&pxmitpriv->lock);
@@ -100,7 +100,7 @@ _func_enter_;
 	Please also apply  free_txobj to link_up all the xmit_frames...
 	*/
 
-	pxmitpriv->pallocated_frame_buf = rtw_zvmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+	pxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
 	
 	if (pxmitpriv->pallocated_frame_buf  == NULL){
 		pxmitpriv->pxmit_frame_buf =NULL;
@@ -116,7 +116,7 @@ _func_enter_;
 
 	for (i = 0; i < NR_XMITFRAME; i++)
 	{
-		_rtw_init_listhead(&(pxframe->list));
+		INIT_LIST_HEAD(&(pxframe->list));
 
 		pxframe->padapter = padapter;
 		pxframe->frame_tag = NULL_FRAMETAG;
@@ -126,7 +126,7 @@ _func_enter_;
 		pxframe->buf_addr = NULL;
 		pxframe->pxmitbuf = NULL;
  
-		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
+		list_add_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
 
 		pxframe++;
 	}
@@ -140,7 +140,7 @@ _func_enter_;
 	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
 	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
 
-	pxmitpriv->pallocated_xmitbuf = rtw_zvmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+	pxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
 	
 	if (pxmitpriv->pallocated_xmitbuf  == NULL){
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
@@ -156,7 +156,7 @@ _func_enter_;
 
 	for (i = 0; i < NR_XMITBUFF; i++)
 	{
-		_rtw_init_listhead(&pxmitbuf->list);
+		INIT_LIST_HEAD(&pxmitbuf->list);
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
@@ -178,7 +178,7 @@ _func_enter_;
 
 		pxmitbuf->flags = XMIT_VO_QUEUE;
 
-		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
+		list_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
 		#ifdef DBG_XMIT_BUF
 		pxmitbuf->no=i;
 		#endif
@@ -192,7 +192,7 @@ _func_enter_;
 	/* init xframe_ext queue,  the same count as extbuf  */
 	_rtw_init_queue(&pxmitpriv->free_xframe_ext_queue);
 	
-	pxmitpriv->xframe_ext_alloc_addr = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
+	pxmitpriv->xframe_ext_alloc_addr = vzalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
 	
 	if (pxmitpriv->xframe_ext_alloc_addr  == NULL){
 		pxmitpriv->xframe_ext = NULL;
@@ -204,7 +204,7 @@ _func_enter_;
 	pxframe = (struct xmit_frame*)pxmitpriv->xframe_ext;
 
 	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
-		_rtw_init_listhead(&(pxframe->list));
+		INIT_LIST_HEAD(&(pxframe->list));
 
 		pxframe->padapter = padapter;
 		pxframe->frame_tag = NULL_FRAMETAG;
@@ -216,7 +216,7 @@ _func_enter_;
 		
 		pxframe->ext_tag = 1;
  
-		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xframe_ext_queue.queue));
+		list_add_tail(&(pxframe->list), &(pxmitpriv->free_xframe_ext_queue.queue));
 
 		pxframe++;
 	}
@@ -225,7 +225,7 @@ _func_enter_;
 	// Init xmit extension buff
 	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
 
-	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
+	pxmitpriv->pallocated_xmit_extbuf = vzalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 	
 	if (pxmitpriv->pallocated_xmit_extbuf  == NULL){
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_extbuf fail!\n"));
@@ -239,7 +239,7 @@ _func_enter_;
 
 	for (i = 0; i < NR_XMIT_EXTBUFF; i++)
 	{
-		_rtw_init_listhead(&pxmitbuf->list);
+		INIT_LIST_HEAD(&pxmitbuf->list);
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
@@ -255,7 +255,7 @@ _func_enter_;
 		pxmitbuf->len = 0;
 		pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;
 
-		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));
+		list_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));
 		#ifdef DBG_XMIT_BUF_EXT
 		pxmitbuf->no=i;
 		#endif
@@ -268,7 +268,7 @@ _func_enter_;
 	for (i = 0; i<CMDBUF_MAX; i++) {
 		pxmitbuf = &pxmitpriv->pcmd_xmitbuf[i];
 		if (pxmitbuf) {
-			_rtw_init_listhead(&pxmitbuf->list);
+			INIT_LIST_HEAD(&pxmitbuf->list);
 
 			pxmitbuf->priv_data = NULL;
 			pxmitbuf->padapter = padapter;
@@ -337,12 +337,12 @@ void _rtw_free_xmit_priv (struct xmit_pr
 	}
 
 	if(pxmitpriv->pallocated_frame_buf) {
-		rtw_vmfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+		vfree(pxmitpriv->pallocated_frame_buf);
 	}
 	
 
 	if(pxmitpriv->pallocated_xmitbuf) {
-		rtw_vmfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+		vfree(pxmitpriv->pallocated_xmitbuf);
 	}
 
 	/* free xframe_ext queue,  the same count as extbuf  */
@@ -353,7 +353,7 @@ void _rtw_free_xmit_priv (struct xmit_pr
 		}
 	}
 	if (pxmitpriv->xframe_ext_alloc_addr)
-		rtw_vmfree(pxmitpriv->xframe_ext_alloc_addr, NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
+		vfree(pxmitpriv->xframe_ext_alloc_addr);
 
 	// free xmit extension buff
 	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
@@ -365,7 +365,7 @@ void _rtw_free_xmit_priv (struct xmit_pr
 	}
 
 	if(pxmitpriv->pallocated_xmit_extbuf) {
-		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
+		vfree(pxmitpriv->pallocated_xmit_extbuf);
 	}
 
 	for (i=0; i<CMDBUF_MAX; i++) {
@@ -618,11 +618,6 @@ static s32 update_attrib_sec_info(_adapt
 	{
 		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
 		
-#ifdef CONFIG_WAPI_SUPPORT
-		if(pattrib->ether_type == 0x88B4)
-			pattrib->encrypt=_NO_PRIVACY_;
-#endif
-
 		switch(psecuritypriv->dot11AuthAlgrthm)
 		{
 			case dot11AuthAlgrthm_Open:
@@ -691,13 +686,6 @@ static s32 update_attrib_sec_info(_adapt
 			
 			break;
 
-#ifdef CONFIG_WAPI_SUPPORT
-		case _SMS4_:
-			pattrib->iv_len = 18;
-			pattrib->icv_len = 16;
-			rtw_wapi_get_iv(padapter,pattrib->ra,pattrib->iv);			
-			break;
-#endif
 		default:
 			pattrib->iv_len = 0;
 			pattrib->icv_len = 0;
@@ -723,11 +711,6 @@ static s32 update_attrib_sec_info(_adapt
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=false\n"));
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if(pattrib->encrypt == _SMS4_)
-		pattrib->bswenc = false;
-#endif
-
 exit:
 
 	return res;
@@ -898,15 +881,11 @@ static s32 update_attrib(_adapter *padap
 	}
 
 	// If EAPOL , ARP , OR DHCP packet, driver must be in active mode.
-#ifdef CONFIG_WAPI_SUPPORT
-	if ( (pattrib->ether_type == 0x88B4) || (pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1) )
-#else //!CONFIG_WAPI_SUPPORT
 	if (pattrib->icmp_pkt==1)
 	{
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1);
 	}
 	else if(pattrib->dhcp_pkt==1)
-#endif
 	{
 		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_active);
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
@@ -1178,10 +1157,6 @@ _func_enter_;
 		case _AES_:
 			rtw_aes_encrypt(padapter, (u8 * )pxmitframe);
 			break;
-#ifdef CONFIG_WAPI_SUPPORT
-		case _SMS4_:
-			rtw_sms4_encrypt(padapter, (u8 * )pxmitframe);
-#endif
 		default:
 				break;
 		}
@@ -1385,70 +1360,10 @@ s32 rtw_txframes_pending(_adapter *padap
 {
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == false) || 
-			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == false) || 
-			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == false) ||
-			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == false));
-}
-
-s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
-{	
-	struct sta_info *psta;
-	struct tx_servq *ptxservq;
-	int priority = pattrib->priority;
-/*
-	if(pattrib->psta)
-	{
-		psta = pattrib->psta;
-	}
-	else
-	{
-		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
-		psta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
-	}	
-*/
-	psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-	if(pattrib->psta != psta)
-	{
-		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
-		return 0;
-	}
-
-	if(psta==NULL)
-	{
-		DBG_871X("%s, psta==NUL\n", __func__);
-		return 0;
-	}
-
-	if(!(psta->state &_FW_LINKED))
-	{
-		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
-		return 0;
-	}
-	
-	switch(priority) 
-	{
-			case 1:
-			case 2:
-				ptxservq = &(psta->sta_xmitpriv.bk_q);				
-				break;
-			case 4:
-			case 5:
-				ptxservq = &(psta->sta_xmitpriv.vi_q);				
-				break;
-			case 6:
-			case 7:
-				ptxservq = &(psta->sta_xmitpriv.vo_q);							
-				break;
-			case 0:
-			case 3:
-			default:
-				ptxservq = &(psta->sta_xmitpriv.be_q);							
-			break;
-	
-	}	
-
-	return ptxservq->qcnt;	
+	return ((!list_empty(&pxmitpriv->be_pending.queue)) ||
+			 (!list_empty(&pxmitpriv->bk_pending.queue)) ||
+			 (!list_empty(&pxmitpriv->vi_pending.queue)) ||
+			 (!list_empty(&pxmitpriv->vo_pending.queue)));
 }
 
 /*
@@ -1594,11 +1509,6 @@ _func_enter_;
 						else
 							AES_IV(pattrib->iv, psta->dot11txpn, 0);
 						break;
-#ifdef CONFIG_WAPI_SUPPORT
-					case _SMS4_:
-						rtw_wapi_get_iv(padapter,pattrib->ra,pattrib->iv);
-						break;
-#endif
 				}
 			}
 */
@@ -1683,7 +1593,6 @@ _func_exit_;
 	return res;
 }
 
-#ifdef CONFIG_IEEE80211W
 //broadcast or multicast management pkt use BIP, unicast management pkt use CCMP encryption
 s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe)
 {
@@ -1719,7 +1628,7 @@ _func_enter_;
 	if(BIP_AAD == NULL)
 		return _FAIL;
 			
-	_enter_critical_bh(&padapter->security_key_mutex, &irqL);
+	spin_lock_bh(&padapter->security_key_mutex);
 	
 	//only support station mode
 	if(!check_fwstate(pmlmepriv, WIFI_STATION_STATE) || !check_fwstate(pmlmepriv, _FW_LINKED))
@@ -1907,19 +1816,18 @@ _func_enter_;
 	}
 
 xmitframe_coalesce_success:
-	_exit_critical_bh(&padapter->security_key_mutex, &irqL);
-	rtw_mfree(BIP_AAD, ori_len);
+	spin_unlock_bh(&padapter->security_key_mutex);
+	kfree(BIP_AAD);
 _func_exit_;
 	return _SUCCESS;
 	
 xmitframe_coalesce_fail:
-	_exit_critical_bh(&padapter->security_key_mutex, &irqL);
-	rtw_mfree(BIP_AAD, ori_len);
+	spin_unlock_bh(&padapter->security_key_mutex);
+	kfree(BIP_AAD);
 _func_exit_;
 
 	return _FAIL;
 }
-#endif //CONFIG_IEEE80211W
 
 /* Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
  * IEEE LLC/SNAP header contains 8 octets
@@ -2103,9 +2011,9 @@ struct xmit_buf *rtw_alloc_xmitbuf_ext(s
 
 _func_enter_;
 
-	_enter_critical(&pfree_queue->lock, &irqL);
+	spin_lock_irqsave(&pfree_queue->lock, irqL);
 
-	if(_rtw_queue_empty(pfree_queue) == true) {
+	if(list_empty(&pfree_queue->queue)) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -2115,7 +2023,7 @@ _func_enter_;
 
 		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
 
-		rtw_list_delete(&(pxmitbuf->list));
+		list_del_init(&(pxmitbuf->list));
 	}
 
 	if (pxmitbuf !=  NULL)
@@ -2139,7 +2047,7 @@ _func_enter_;
 
 	}
 
-	_exit_critical(&pfree_queue->lock, &irqL);
+	spin_unlock_irqrestore(&pfree_queue->lock, irqL);
 
 _func_exit_;
 
@@ -2158,17 +2066,17 @@ _func_enter_;
 		return _FAIL;
 	}
 
-	_enter_critical(&pfree_queue->lock, &irqL);
+	spin_lock_irqsave(&pfree_queue->lock, irqL);
 
-	rtw_list_delete(&pxmitbuf->list);
+	list_del_init(&pxmitbuf->list);
 
-	rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_queue));
+	list_add_tail(&(pxmitbuf->list), get_list_head(pfree_queue));
 	pxmitpriv->free_xmit_extbuf_cnt++;
 	#ifdef DBG_XMIT_BUF_EXT
 	DBG_871X("DBG_XMIT_BUF_EXT FREE no=%d, free_xmit_extbuf_cnt=%d\n",pxmitbuf->no ,pxmitpriv->free_xmit_extbuf_cnt);
 	#endif
 
-	_exit_critical(&pfree_queue->lock, &irqL);
+	spin_unlock_irqrestore(&pfree_queue->lock, irqL);
 
 _func_exit_;
 
@@ -2186,9 +2094,9 @@ _func_enter_;
 
 	//DBG_871X("+rtw_alloc_xmitbuf\n");
 
-	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
 
-	if(_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
+	if(list_empty(&pfree_xmitbuf_queue->queue)) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -2198,7 +2106,7 @@ _func_enter_;
 
 		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
 
-		rtw_list_delete(&(pxmitbuf->list));
+		list_del_init(&(pxmitbuf->list));
 	}
 
 	if (pxmitbuf !=  NULL)
@@ -2228,7 +2136,7 @@ _func_enter_;
 	}
 	#endif
 
-	_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
 
 _func_exit_;
 
@@ -2261,18 +2169,18 @@ _func_enter_;
 	}
 	else
 	{
-		_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
+		spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
 
-		rtw_list_delete(&pxmitbuf->list);	
+		list_del_init(&pxmitbuf->list);	
 
-		rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+		list_add_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
 
 		pxmitpriv->free_xmitbuf_cnt++;
 		//DBG_871X("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
 		#ifdef DBG_XMIT_BUF
 		DBG_871X("DBG_XMIT_BUF FREE no=%d, free_xmitbuf_cnt=%d\n",pxmitbuf->no ,pxmitpriv->free_xmitbuf_cnt);
 		#endif
-		_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);
+		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
 	}
 
 _func_exit_;	 
@@ -2324,9 +2232,9 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 
 _func_enter_;
 
-	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_lock_bh(&pfree_xmit_queue->lock);
 
-	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
+	if (list_empty(&pfree_xmit_queue->queue)) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
 		pxframe =  NULL;
 	} else {
@@ -2336,12 +2244,12 @@ _func_enter_;
 
 		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
-		rtw_list_delete(&(pxframe->list));
+		list_del_init(&(pxframe->list));
 		pxmitpriv->free_xmitframe_cnt--;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
 	}
 
-	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_unlock_bh(&pfree_xmit_queue->lock);
 
 	rtw_init_xmitframe(pxframe);
 
@@ -2359,9 +2267,9 @@ struct xmit_frame *rtw_alloc_xmitframe_e
 
 _func_enter_;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	if (_rtw_queue_empty(queue) == true) {
+	if (list_empty(&queue->queue)) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe_ext:%d\n", pxmitpriv->free_xframe_ext_cnt));
 		pxframe =  NULL;
 	} else {
@@ -2369,12 +2277,12 @@ _func_enter_;
 		plist = get_next(phead);
 		pxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
-		rtw_list_delete(&(pxframe->list));
+		list_del_init(&(pxframe->list));
 		pxmitpriv->free_xframe_ext_cnt--;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe_ext():free_xmitframe_cnt=%d\n", pxmitpriv->free_xframe_ext_cnt));
 	}
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	rtw_init_xmitframe(pxframe);
 
@@ -2433,7 +2341,7 @@ _func_enter_;
 
 	if (pxmitframe->alloc_addr) {
 		DBG_871X("################## %s with alloc_addr ##################\n", __func__);
-		rtw_mfree(pxmitframe->alloc_addr, sizeof(struct xmit_frame) + 4);
+		kfree(pxmitframe->alloc_addr);
 		goto check_pkt_complete;
 	}
 
@@ -2444,10 +2352,10 @@ _func_enter_;
 	else
 	{}
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
-	rtw_list_delete(&pxmitframe->list);	
-	rtw_list_insert_tail(&pxmitframe->list, get_list_head(queue));
+	list_del_init(&pxmitframe->list);	
+	list_add_tail(&pxmitframe->list, get_list_head(queue));
 	if (pxmitframe->ext_tag == 0) {
 		pxmitpriv->free_xmitframe_cnt++;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
@@ -2457,7 +2365,7 @@ _func_enter_;
 	} else {
 	}
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 check_pkt_complete:
 
@@ -2479,12 +2387,12 @@ void rtw_free_xmitframe_queue(struct xmi
 
 _func_enter_;	
 
-	_enter_critical_bh(&(pframequeue->lock), &irqL);
+	spin_lock_bh(&(pframequeue->lock));
 
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 	
-	while (rtw_end_of_queue_search(phead, plist) == false)
+	while (phead != plist)
 	{
 			
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
@@ -2494,7 +2402,7 @@ _func_enter_;
 		rtw_free_xmitframe(pxmitpriv,pxmitframe);
 			
 	}
-	_exit_critical_bh(&(pframequeue->lock), &irqL);
+	spin_unlock_bh(&(pframequeue->lock));
 
 _func_exit_;
 }
@@ -2513,111 +2421,6 @@ s32 rtw_xmitframe_enqueue(_adapter *pada
 	return _SUCCESS;
 }
 
-static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, _queue *pframe_queue)
-{
-	_list	*xmitframe_plist, *xmitframe_phead;
-	struct	xmit_frame	*pxmitframe=NULL;
-
-	xmitframe_phead = get_list_head(pframe_queue);
-	xmitframe_plist = get_next(xmitframe_phead);
-
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
-	{
-		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
-
-		xmitframe_plist = get_next(xmitframe_plist);
-
-		rtw_list_delete(&pxmitframe->list);
-
-		ptxservq->qcnt--;
-
-		//rtw_list_insert_tail(&pxmitframe->list, &phwxmit->pending);
-
-		//ptxservq->qcnt--;
-
-		break;		
-
-		pxmitframe = NULL;
-
-	}
-
-	return pxmitframe;
-}
-
-struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry)
-{
-	_irqL irqL0;
-	_list *sta_plist, *sta_phead;
-	struct hw_xmit *phwxmit;
-	struct tx_servq *ptxservq = NULL;
-	_queue *pframe_queue = NULL;
-	struct xmit_frame *pxmitframe = NULL;
-	_adapter *padapter = pxmitpriv->adapter;
-	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	int i, inx[4];
-
-_func_enter_;
-
-	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
-
-	if(pregpriv->wifi_spec==1)
-	{
-		int j, tmp, acirp_cnt[4];
-
-		for(j=0; j<4; j++)
-			inx[j] = pxmitpriv->wmm_para_seq[j];
-	}
-
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
-
-	for(i = 0; i < entry; i++) 
-	{
-		phwxmit = phwxmit_i + inx[i];
-
-		//_enter_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
-		sta_phead = get_list_head(phwxmit->sta_queue);
-		sta_plist = get_next(sta_phead);
-
-		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false)
-		{
-
-			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
-
-			pframe_queue = &ptxservq->sta_pending;
-
-			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
-
-			if(pxmitframe)
-			{
-				phwxmit->accnt--;
-
-				//Remove sta node when there is no pending packets.
-				if(_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
-					rtw_list_delete(&ptxservq->tx_pending);
-
-				//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
-				goto exit;
-			}
-
-			sta_plist = get_next(sta_plist);
-
-		}
-
-		//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
-	}
-
-exit:
-
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
-
-_func_exit_;
-
-	return pxmitframe;
-}
-
 struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac)
 {
 	struct tx_servq *ptxservq=NULL;
@@ -2715,21 +2518,21 @@ _func_enter_;
 
 	ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
-	//_enter_critical(&pstapending->lock, &irqL0);
+	//spin_lock_irqsave(&pstapending->lock, irqL0);
 
-	if (rtw_is_list_empty(&ptxservq->tx_pending)) {
-		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));
+	if (list_empty(&ptxservq->tx_pending)) {
+		list_add_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));
 	}
 
-	//_enter_critical(&ptxservq->sta_pending.lock, &irqL1);
+	//spin_lock_irqsave(&ptxservq->sta_pending.lock, irqL1);
 
-	rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
+	list_add_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
 	ptxservq->qcnt++;
 	phwxmits[ac_index].accnt++;
 
-	//_exit_critical(&ptxservq->sta_pending.lock, &irqL1);
+	//spin_unlock_irqrestore(&ptxservq->sta_pending.lock, irqL1);
 
-	//_exit_critical(&pstapending->lock, &irqL0);
+	//spin_unlock_irqrestore(&pstapending->lock, irqL0);
 
 exit:
 
@@ -2815,7 +2618,7 @@ void rtw_free_hwxmits(_adapter *padapter
 
 	hwxmits = pxmitpriv->hwxmits;
 	if(hwxmits)
-		rtw_mfree((u8 *)hwxmits, (sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry));
+		kfree((u8 *)hwxmits);
 }
 
 void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry)
@@ -2825,7 +2628,7 @@ _func_enter_;
 	for(i = 0; i < entry; i++, phwxmit++)
 	{
 		//spin_lock_init(&phwxmit->xmit_lock);
-		//_rtw_init_listhead(&phwxmit->pending);		
+		//INIT_LIST_HEAD(&phwxmit->pending);		
 		//phwxmit->txcmdcnt = 0;
 		phwxmit->accnt = 0;
 	}
@@ -2894,9 +2697,8 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 {
 	static unsigned long start = 0;
 	static u32 drop_cnt = 0;
-#ifdef CONFIG_AP_MODE
 	_irqL irqL0;
-#endif
+
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct xmit_frame *pxmitframe = NULL;
 
@@ -2925,16 +2727,6 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 
 	res = update_attrib(padapter, *ppkt, &pxmitframe->attrib);
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if(pxmitframe->attrib.ether_type != 0x88B4)
-	{
-		if(rtw_wapi_drop_for_key_absent(padapter, pxmitframe->attrib.ra))
-		{
-			WAPI_TRACE(WAPI_RX,"drop for key absend when tx \n");
-			res = _FAIL;
-		}
-	}
-#endif
 	if (res == _FAIL) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: update attrib fail\n"));
 		#ifdef DBG_TX_DROP_FRAME
@@ -2945,20 +2737,16 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 	}
 	pxmitframe->pkt = *ppkt;
 
-	rtw_led_control(padapter, LED_CTL_TX);
-
 	do_queue_select(padapter, &pxmitframe->attrib);
 
-#ifdef CONFIG_AP_MODE
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
 	{
-		_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+		spin_unlock_bh(&pxmitpriv->lock);
 		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue);
 		return 1;		
 	}
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
-#endif
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	//pre_xmitframe
 	if (rtw_hal_xmit(padapter, pxmitframe) == false)
@@ -2983,9 +2771,6 @@ inline bool xmitframe_hiq_filter(struct
 
 		if (attrib->ether_type == 0x0806
 			|| attrib->ether_type == 0x888e
-			#ifdef CONFIG_WAPI_SUPPORT
-			|| attrib->ether_type == 0x88B4
-			#endif
 			|| attrib->dhcp_pkt
 		) {
 			DBG_871X(FUNC_ADPT_FMT" ether_type:0x%04x%s\n", FUNC_ADPT_ARG(xmitframe->padapter)
@@ -3005,8 +2790,6 @@ inline bool xmitframe_hiq_filter(struct
 	return allow;
 }
 
-#if defined(CONFIG_AP_MODE)
-
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
 	_irqL irqL;
@@ -3071,17 +2854,17 @@ sint xmitframe_enqueue_for_sleeping_sta(
 
 	if(bmcst)
 	{
-		_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+		spin_lock_bh(&psta->sleep_q.lock);
 	
 		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
 		{
 			//pattrib->qsel = 0x11;//HIQ
 			
-			rtw_list_delete(&pxmitframe->list);
+			list_del_init(&pxmitframe->list);
 			
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			//spin_lock_bh(&psta->sleep_q.lock);
 			
-			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+			list_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
 			
 			psta->sleepq_len++;
 
@@ -3099,7 +2882,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 				chk_bmc_sleepq_cmd(padapter);
 			}
 
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);				
+			//spin_unlock_bh(&psta->sleep_q.lock);
 			
 			ret = true;			
 
@@ -3107,14 +2890,14 @@ sint xmitframe_enqueue_for_sleeping_sta(
 			
 		}
 		
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
+		spin_unlock_bh(&psta->sleep_q.lock);
 		
 		return ret;
 		
 	}
 	
 
-	_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+	spin_lock_bh(&psta->sleep_q.lock);
 	
 	if(psta->state&WIFI_SLEEP_STATE)
 	{
@@ -3122,11 +2905,11 @@ sint xmitframe_enqueue_for_sleeping_sta(
 	
 		if(pstapriv->sta_dz_bitmap&BIT(psta->aid))	
 		{			
-			rtw_list_delete(&pxmitframe->list);
+			list_del_init(&pxmitframe->list);
 		
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			//spin_lock_bh(&psta->sleep_q.lock);
 			
-			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+			list_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
 			
 			psta->sleepq_len++;
 
@@ -3171,7 +2954,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 				}
 			}
 
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);			
+			//spin_unlock_bh(&psta->sleep_q.lock);
 
 			//if(psta->sleepq_len > (NR_XMITFRAME>>3))
 			//{
@@ -3185,7 +2968,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 
 	}
 
-	_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
+	spin_unlock_bh(&psta->sleep_q.lock);
 
 	return ret;
 	
@@ -3204,7 +2987,7 @@ static void dequeue_xmitframes_to_sleepi
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 	
-	while (rtw_end_of_queue_search(phead, plist) == false)
+	while (phead != plist)
 	{			
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
@@ -3246,7 +3029,7 @@ void stop_sta_xmit(_adapter *padapter, s
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 	
 			
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	psta->state |= WIFI_SLEEP_STATE;
 	
@@ -3255,26 +3038,26 @@ void stop_sta_xmit(_adapter *padapter, s
 	
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
 
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
 
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
 	
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
 
 	//for BC/MC Frames
 	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
 	
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_unlock_bh(&pxmitpriv->lock);
 }	
 
 void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
@@ -3290,19 +3073,19 @@ void wakeup_sta_to_xmit(_adapter *padapt
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 	
 
-	//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	//spin_lock_bh(&psta->sleep_q.lock);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+	while (xmitframe_phead != xmitframe_plist)
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 		xmitframe_plist = get_next(xmitframe_plist);
 
-		rtw_list_delete(&pxmitframe->list);
+		list_del_init(&pxmitframe->list);
 
 		switch(pxmitframe->attrib.priority)
 		{
@@ -3349,12 +3132,12 @@ void wakeup_sta_to_xmit(_adapter *padapt
 		pxmitframe->attrib.triggered = 1;
 
 /*
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_unlock_bh(&psta->sleep_q.lock);
 		if(rtw_hal_xmit(padapter, pxmitframe) == true)
 		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		}
-		_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_lock_bh(&psta->sleep_q.lock);
 */
 		rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
@@ -3394,13 +3177,13 @@ void wakeup_sta_to_xmit(_adapter *padapt
 		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 		xmitframe_plist = get_next(xmitframe_phead);
 
-		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+		while (xmitframe_phead != xmitframe_plist)
 		{
 			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 			xmitframe_plist = get_next(xmitframe_plist);
 
-			rtw_list_delete(&pxmitframe->list);
+			list_del_init(&pxmitframe->list);
 
 			psta_bmc->sleepq_len--;
 			if(psta_bmc->sleepq_len>0)
@@ -3411,12 +3194,12 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 			pxmitframe->attrib.triggered = 1;
 /*
-			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_unlock_bh(&psta_bmc->sleep_q.lock);
 			if(rtw_hal_xmit(padapter, pxmitframe) == true)
 			{
 				rtw_os_xmit_complete(padapter, pxmitframe);
 			}
-			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 */
 			rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
@@ -3439,8 +3222,8 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 _exit:
 
-	//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	//spin_unlock_bh(&psta_bmc->sleep_q.lock);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	if(update_mask)
 	{
@@ -3461,13 +3244,13 @@ void xmit_delivery_enabled_frames(_adapt
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
 
-	//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	//spin_lock_bh(&psta->sleep_q.lock);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+	while (xmitframe_phead != xmitframe_plist)
 	{			
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -3497,7 +3280,7 @@ void xmit_delivery_enabled_frames(_adapt
 		if(!wmmps_ac)
 			continue;
 
-		rtw_list_delete(&pxmitframe->list);
+		list_del_init(&pxmitframe->list);
 
 		psta->sleepq_len--;
 		psta->sleepq_ac_len--;
@@ -3529,14 +3312,12 @@ void xmit_delivery_enabled_frames(_adapt
 	
 	}	
 
-	//_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	//spin_unlock_bh(&psta->sleep_q.lock);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	return;
 }
 
-#endif
-
 void enqueue_pending_xmitbuf(
 	struct xmit_priv *pxmitpriv,
 	struct xmit_buf *pxmitbuf)
@@ -3547,10 +3328,10 @@ void enqueue_pending_xmitbuf(
 
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 
-	_enter_critical_bh(&pqueue->lock, &irql);
-	rtw_list_delete(&pxmitbuf->list);
-	rtw_list_insert_tail(&pxmitbuf->list, get_list_head(pqueue));
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_lock_bh(&pqueue->lock);
+	list_del_init(&pxmitbuf->list);
+	list_add_tail(&pxmitbuf->list, get_list_head(pqueue));
+	spin_unlock_bh(&pqueue->lock);
 
 	up(&(pri_adapter->xmitpriv.xmit_sema));
 }
@@ -3565,10 +3346,10 @@ void enqueue_pending_xmitbuf_to_head(
 
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 
-	_enter_critical_bh(&pqueue->lock, &irql);
-	rtw_list_delete(&pxmitbuf->list);
-	rtw_list_insert_head(&pxmitbuf->list, get_list_head(pqueue));
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_lock_bh(&pqueue->lock);
+	list_del_init(&pxmitbuf->list);
+	list_add(&pxmitbuf->list, get_list_head(pqueue));
+	spin_unlock_bh(&pqueue->lock);
 }
 
 struct xmit_buf* dequeue_pending_xmitbuf(
@@ -3582,19 +3363,19 @@ struct xmit_buf* dequeue_pending_xmitbuf
 	pxmitbuf = NULL;
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 
-	_enter_critical_bh(&pqueue->lock, &irql);
+	spin_lock_bh(&pqueue->lock);
 
-	if (_rtw_queue_empty(pqueue) == false)
+	if (!list_empty(&pqueue->queue))
 	{
 		_list *plist, *phead;
 
 		phead = get_list_head(pqueue);
 		plist = get_next(phead);
 		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
-		rtw_list_delete(&pxmitbuf->list);
+		list_del_init(&pxmitbuf->list);
 	}
 
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_unlock_bh(&pqueue->lock);
 
 	return pxmitbuf;
 }
@@ -3610,9 +3391,9 @@ struct xmit_buf* dequeue_pending_xmitbuf
 	pxmitbuf = NULL;
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 
-	_enter_critical_bh(&pqueue->lock, &irql);
+	spin_lock_bh(&pqueue->lock);
 
-	if (_rtw_queue_empty(pqueue) == false)
+	if (!list_empty(&pqueue->queue))
 	{
 		_list *plist, *phead;
 		u8 type;
@@ -3631,14 +3412,14 @@ struct xmit_buf* dequeue_pending_xmitbuf
 				(type == WIFI_DATA_NULL) ||
 				(type == WIFI_QOS_DATA_NULL))
 			{
-				rtw_list_delete(&pxmitbuf->list);
+				list_del_init(&pxmitbuf->list);
 				break;
 			}
 			pxmitbuf = NULL;
 		} while (1);
 	}
 
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_unlock_bh(&pqueue->lock);
 
 	return pxmitbuf;
 }
@@ -3652,12 +3433,12 @@ sint check_pending_xmitbuf(
 
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 
-	_enter_critical_bh(&pqueue->lock, &irql);
+	spin_lock_bh(&pqueue->lock);
 
-	if(_rtw_queue_empty(pqueue) == false)
+	if(!list_empty(&pqueue->queue))
 		ret = true;
 
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_unlock_bh(&pqueue->lock);
 
 	return ret;
 }
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalBtc8723b1Ant.c linux/3rdparty/rtl8723bs/hal/HalBtc8723b1Ant.c
--- linux/3rdparty/rtl8723bs.old/hal/HalBtc8723b1Ant.c	2015-05-10 14:36:05.684668079 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalBtc8723b1Ant.c	2015-05-07 17:46:55.000000000 +0300
@@ -3606,32 +3606,6 @@ EXhalbtc8723b1ant_BtInfoNotify(
 }
 
 void
-EXhalbtc8723b1ant_RfStatusNotify(
-	IN	PBTC_COEXIST			pBtCoexist,
-	IN	u1Byte					type
-	)
-{
-	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF Status notify\n"));
-
-	if(BTC_RF_ON == type)
-	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF is turned ON!!\n"));
-		pBtCoexist->bStopCoexDm = false;
-	}
-	else if(BTC_RF_OFF == type)
-	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF is turned OFF!!\n"));
-		
-		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
-		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, false, 0);
-		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, false, true);
-		
-		halbtc8723b1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, true);
-		pBtCoexist->bStopCoexDm = true;
-	}
-}
-
-void
 EXhalbtc8723b1ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
 	)
@@ -3681,19 +3655,6 @@ EXhalbtc8723b1ant_PnpNotify(
 }
 
 void
-EXhalbtc8723b1ant_CoexDmReset(
-	IN	PBTC_COEXIST			pBtCoexist
-	)
-{
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], *****************Coex DM Reset*****************\n"));
-
-	halbtc8723b1ant_InitHwConfig(pBtCoexist, false, false);
-	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
-	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x2, 0xfffff, 0x0);
-	halbtc8723b1ant_InitCoexDm(pBtCoexist);
-}
-
-void
 EXhalbtc8723b1ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
 	)
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalBtc8723b1Ant.h linux/3rdparty/rtl8723bs/hal/HalBtc8723b1Ant.h
--- linux/3rdparty/rtl8723bs.old/hal/HalBtc8723b1Ant.h	2015-05-10 14:36:05.684668079 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalBtc8723b1Ant.h	2015-05-07 17:46:55.000000000 +0300
@@ -213,11 +213,6 @@ EXhalbtc8723b1ant_BtInfoNotify(
 	IN	u1Byte			length
 	);
 void
-EXhalbtc8723b1ant_RfStatusNotify(
-	IN	PBTC_COEXIST			pBtCoexist,
-	IN	u1Byte					type
-	);
-void
 EXhalbtc8723b1ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
@@ -227,10 +222,6 @@ EXhalbtc8723b1ant_PnpNotify(
 	IN	u1Byte				pnpState
 	);
 void
-EXhalbtc8723b1ant_CoexDmReset(
-	IN	PBTC_COEXIST			pBtCoexist
-	);
-void
 EXhalbtc8723b1ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_btcoex.c linux/3rdparty/rtl8723bs/hal/hal_btcoex.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_btcoex.c	2015-05-10 14:36:05.687668113 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_btcoex.c	2015-05-07 17:46:55.000000000 +0300
@@ -108,7 +108,7 @@ static void DBG_BT_INFO_INIT(PBTCDBGINFO
 void DBG_BT_INFO(u8 *dbgmsg)
 {
 	PBTCDBGINFO pinfo;
-	u32 msglen, buflen;
+	u32 msglen;
 	u8 *pbuf;
 
 
@@ -218,7 +218,6 @@ static void halbtcoutsrc_LeaveLowPower(P
 {
 	PADAPTER padapter;
 	PHAL_DATA_TYPE pHalData;
-	struct pwrctrl_priv *pwrctrl;
 	s32 ready;
 	unsigned long stime;
 	unsigned long utime;
@@ -227,7 +226,6 @@ static void halbtcoutsrc_LeaveLowPower(P
 
 	padapter = pBtCoexist->Adapter;
 	pHalData = GET_HAL_DATA(padapter);
-	pwrctrl = adapter_to_pwrctl(padapter);
 	ready = _FAIL;
 #ifdef LPS_RPWM_WAIT_MS
 	timeout = LPS_RPWM_WAIT_MS;
@@ -373,7 +371,6 @@ static u32 halbtcoutsrc_GetWifiLinkStatu
 
 
 	padapter = pBtCoexist->Adapter;
-	retVal = 0;
 	portConnectedStatus = 0;
 	numOfConnectedPort = 0;
 
@@ -391,10 +388,6 @@ static u32 halbtcoutsrc_GetWifiLinkStatu
 
 static u32 halbtcoutsrc_GetBtPatchVer(PBTC_COEXIST pBtCoexist)
 {
-	u16 btRealFwVer = 0x0;
-	u8 btFwVer = 0x0;
-	u8 cnt = 0;
-
 	return pBtCoexist->btInfo.btRealFwVer;
 }
 
@@ -417,8 +410,6 @@ static u8 halbtcoutsrc_GetWifiScanAPNum(
 	struct mlme_ext_priv *pmlmeext;
 	static u8 scan_AP_num = 0;
 
-
-	pmlmepriv = &padapter->mlmepriv;
 	pmlmeext = &padapter->mlmeextpriv;
 
 	if (GLBtcWiFiInScanState == false) {
@@ -437,7 +428,6 @@ static u8 halbtcoutsrc_Get(void *pBtcCon
 	PADAPTER padapter;
 	PHAL_DATA_TYPE pHalData;
 	struct mlme_ext_priv *mlmeext;
-	u8 bSoftApExist, bVwifiExist;
 	u8 *pu8;
 	s32 *pS4Tmp;
 	u32 *pU4Tmp;
@@ -452,8 +442,6 @@ static u8 halbtcoutsrc_Get(void *pBtcCon
 	padapter = pBtCoexist->Adapter;
 	pHalData = GET_HAL_DATA(padapter);
 	mlmeext = &padapter->mlmeextpriv;
-	bSoftApExist = false;
-	bVwifiExist = false;
 	pu8 = (u8*)pOutBuf;
 	pS4Tmp = (s32*)pOutBuf;
 	pU4Tmp = (u32*)pOutBuf;
@@ -1011,7 +999,6 @@ static void halbtcoutsrc_DisplayDbgMsg(v
 static u8 EXhalbtcoutsrc_BindBtCoexWithAdapter(void *padapter)
 {
 	PBTC_COEXIST		pBtCoexist=&GLBtCoexist;
-	u1Byte	antNum=2, chipType;
 	
 	if(pBtCoexist->bBinded)
 		return false;
@@ -1307,20 +1294,6 @@ void EXhalbtcoutsrc_BtInfoNotify(PBTC_CO
 //	halbtcoutsrc_NormalLowPower(pBtCoexist);
 }
 
-void
-EXhalbtcoutsrc_RfStatusNotify(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	u1Byte 				type
-	)
-{
-	if(!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-	pBtCoexist->statistics.cntRfStatusNotify++;
-	
-	if(pBtCoexist->boardInfo.btdmAntNum == 1)
-		EXhalbtc8723b1ant_RfStatusNotify(pBtCoexist, type);
-}
-
 void EXhalbtcoutsrc_HaltNotify(PBTC_COEXIST pBtCoexist)
 {
 	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
@@ -1334,18 +1307,6 @@ void EXhalbtcoutsrc_HaltNotify(PBTC_COEX
 	pBtCoexist->bBinded = false;
 }
 
-static void EXhalbtcoutsrc_SwitchBtTRxMask(PBTC_COEXIST pBtCoexist)
-{
-	if (pBtCoexist->boardInfo.btdmAntNum == 2)
-	{
-		halbtcoutsrc_SetBtReg(pBtCoexist, 0, 0x3c, 0x01); //BT goto standby while GNT_BT 1-->0
-	}
-	else if (pBtCoexist->boardInfo.btdmAntNum == 1)
-	{
-		halbtcoutsrc_SetBtReg(pBtCoexist, 0, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0
-	}
-}
-
 void EXhalbtcoutsrc_PnpNotify(PBTC_COEXIST pBtCoexist, u8 pnpState)
 {
 	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
@@ -1362,27 +1323,6 @@ void EXhalbtcoutsrc_PnpNotify(PBTC_COEXI
 		EXhalbtc8723b2ant_PnpNotify(pBtCoexist,pnpState);
 }
 
-void EXhalbtcoutsrc_CoexDmSwitch(PBTC_COEXIST pBtCoexist)
-{
-	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-	pBtCoexist->statistics.cntCoexDmSwitch++;
-
-	halbtcoutsrc_LeaveLowPower(pBtCoexist);
-
-	if (pBtCoexist->boardInfo.btdmAntNum == 1)
-	{
-		pBtCoexist->bStopCoexDm = true;
-		EXhalbtc8723b1ant_CoexDmReset(pBtCoexist);
-		EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_DETECTED, 2);
-		EXhalbtc8723b2ant_InitHwConfig(pBtCoexist, false);
-		EXhalbtc8723b2ant_InitCoexDm(pBtCoexist);
-		pBtCoexist->bStopCoexDm = false;
-	}
-
-	halbtcoutsrc_NormalLowPower(pBtCoexist);
-}
-
 void EXhalbtcoutsrc_Periodical(PBTC_COEXIST pBtCoexist)
 {
 	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
@@ -1401,51 +1341,6 @@ void EXhalbtcoutsrc_Periodical(PBTC_COEX
 //	halbtcoutsrc_NormalLowPower(pBtCoexist);
 }
 
-void EXhalbtcoutsrc_DbgControl(PBTC_COEXIST pBtCoexist, u8 opCode, u8 opLen, u8 *pData)
-{
-	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-
-	pBtCoexist->statistics.cntDbgCtrl++;
-
-	// This function doesn't be called yet,
-	// default no need to leave low power to avoid deadlock
-//	halbtcoutsrc_LeaveLowPower(pBtCoexist);
-
-//	halbtcoutsrc_NormalLowPower(pBtCoexist);
-}
-
-void EXhalbtcoutsrc_UpdateMinBtRssi(s8 btRssi)
-{
-	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
-
-	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-
-	pBtCoexist->stackInfo.minBtRssi = btRssi;
-}
-
-void EXhalbtcoutsrc_SetHciVersion(u16 hciVersion)
-{
-	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
-
-	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-
-	pBtCoexist->stackInfo.hciVersion = hciVersion;
-}
-
-void EXhalbtcoutsrc_SetBtPatchVersion(u16 btHciVersion, u16 btPatchVersion)
-{
-	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
-
-	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
-		return;
-
-	pBtCoexist->btInfo.btRealFwVer = btPatchVersion;
-	pBtCoexist->btInfo.btHciVer = btHciVersion;
-}
-
 void EXhalbtcoutsrc_SetChipType(u8 chipType)
 {
 	GLBtCoexist.boardInfo.btChipType = BTC_CHIP_RTL8723B;
@@ -1546,15 +1441,6 @@ void hal_btcoex_SetChipType(PADAPTER pad
 	EXhalbtcoutsrc_SetChipType(chipType);
 }
 
-u8 hal_btcoex_GetChipType(PADAPTER padapter)
-{
-	PHAL_DATA_TYPE	pHalData;
-
-
-	pHalData = GET_HAL_DATA(padapter);
-	return pHalData->bt_coexist.btChipType;
-}
-
 void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum)
 {
 	PHAL_DATA_TYPE	pHalData;
@@ -1566,16 +1452,6 @@ void hal_btcoex_SetPgAntNum(PADAPTER pad
 	EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum);
 }
 
-u8 hal_btcoex_GetPgAntNum(PADAPTER padapter)
-{
-	PHAL_DATA_TYPE pHalData;
-
-
-	pHalData = GET_HAL_DATA(padapter);
-
-	return pHalData->bt_coexist.btTotalAntNum;
-}
-
 void hal_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath)
 {
 	EXhalbtcoutsrc_SetSingleAntPath(singleAntPath);
@@ -1666,11 +1542,6 @@ void hal_btcoex_HaltNotify(PADAPTER pada
 	EXhalbtcoutsrc_HaltNotify(&GLBtCoexist);
 }
 
-void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter)
-{
-	EXhalbtcoutsrc_SwitchBtTRxMask(&GLBtCoexist);
-}
-
 void hal_btcoex_Hanlder(PADAPTER padapter)
 {
 	EXhalbtcoutsrc_Periodical(&GLBtCoexist);
@@ -1681,27 +1552,11 @@ s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PAD
 	return (s32)GLBtCoexist.btInfo.bBtCtrlAggBufSize;
 }
 
-u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter)
-{
-	return (u32)GLBtCoexist.btInfo.aggBufSize;
-}
-
 void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual)
 {
 	GLBtCoexist.bManualControl = bmanual;
 }
 
-u8 hal_btcoex_1Ant(PADAPTER padapter)
-{
-	if (hal_btcoex_IsBtExist(padapter) == false)
-		return false;
-
-	if (GLBtCoexist.boardInfo.btdmAntNum == 1)
-		return true;
-
-	return false;
-}
-
 u8 hal_btcoex_IsBtControlLps(PADAPTER padapter)
 {
 	if (hal_btcoex_IsBtExist(padapter) == false)
@@ -1796,7 +1651,6 @@ u32 hal_btcoex_GetDBG(PADAPTER padapter,
 	if ((NULL == pStrBuf) || (0 == bufSize))
 		return 0;
 
-	count = 0;
 	pstr = pStrBuf;
 	leftSize = bufSize;
 //	DBG_871X(FUNC_ADPT_FMT ": bufsize=%d\n", FUNC_ADPT_ARG(padapter), bufSize);
@@ -1828,13 +1682,13 @@ u32 hal_btcoex_GetDBG(PADAPTER padapter,
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[0]=%d for INTF_INIT\n",
-		GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_INIT?1:0);
+		(GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_INIT)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[2]=%d for INTF_NOTIFY\n\n",
-		GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_NOTIFY?1:0);
+		(GLBtcDbgType[BTC_MSG_INTERFACE]&INTF_NOTIFY)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
@@ -1846,61 +1700,61 @@ u32 hal_btcoex_GetDBG(PADAPTER padapter,
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[0]=%d for BT_RSSI_STATE\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_RSSI_STATE?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_RSSI_STATE)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[1]=%d for WIFI_RSSI_STATE\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_WIFI_RSSI_STATE?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_WIFI_RSSI_STATE)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[2]=%d for BT_MONITOR\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_MONITOR?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_BT_MONITOR)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[3]=%d for TRACE\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[4]=%d for TRACE_FW\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[5]=%d for TRACE_FW_DETAIL\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_DETAIL?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_DETAIL)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[6]=%d for TRACE_FW_EXEC\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_EXEC?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_FW_EXEC)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[7]=%d for TRACE_SW\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[8]=%d for TRACE_SW_DETAIL\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_DETAIL?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_DETAIL)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
 	leftSize -= count;
 	count = rtw_sprintf(pstr, leftSize, "\tbit[9]=%d for TRACE_SW_EXEC\n",
-		GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_EXEC?1:0);
+		(GLBtcDbgType[BTC_MSG_ALGORITHM]&ALGO_TRACE_SW_EXEC)?1:0);
 	if ((count < 0) || (count >= leftSize))
 		goto exit;
 	pstr += count;
@@ -1912,22 +1766,3 @@ exit:
 
 	return count;
 }
-
-u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER padapter)
-{
-	if (!hal_btcoex_IsBtExist(padapter))
-		return false;
-
-	if (GLBtCoexist.btInfo.bIncreaseScanDevNum)
-		return true;
-
-	return false;
-}
-
-u8 hal_btcoex_IsBtLinkExist(PADAPTER padapter)
-{
-	if (GLBtCoexist.btLinkInfo.bBtLinkExist)
-		return true;
-
-	return false;
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalBtcOutSrc.h linux/3rdparty/rtl8723bs/hal/HalBtcOutSrc.h
--- linux/3rdparty/rtl8723bs.old/hal/HalBtcOutSrc.h	2015-05-10 14:36:05.687668113 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalBtcOutSrc.h	2015-05-07 17:46:55.000000000 +0300
@@ -659,11 +659,6 @@ EXhalbtcoutsrc_BtInfoNotify(
 	IN	u1Byte			length
 	);
 void
-EXhalbtcoutsrc_RfStatusNotify(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	u1Byte 				type
-	);
-void
 EXhalbtcoutsrc_HaltNotify(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -673,34 +668,10 @@ EXhalbtcoutsrc_PnpNotify(
 	IN	u1Byte			pnpState
 	);
 void
-EXhalbtcoutsrc_CoexDmSwitch(
-	IN	PBTC_COEXIST		pBtCoexist
-	);
-void
 EXhalbtcoutsrc_Periodical(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 void
-EXhalbtcoutsrc_DbgControl(
-	IN	PBTC_COEXIST			pBtCoexist,
-	IN	u1Byte				opCode,
-	IN	u1Byte				opLen,
-	IN	pu1Byte				pData
-	);
-void
-EXhalbtcoutsrc_SetHciVersion(
-	IN	u2Byte	hciVersion
-	);
-void
-EXhalbtcoutsrc_SetBtPatchVersion(
-	IN	u2Byte	btHciVersion,
-	IN	u2Byte	btPatchVersion
-	);
-void
-EXhalbtcoutsrc_UpdateMinBtRssi(
-	IN	s8	btRssi
-	);
-void
 EXhalbtcoutsrc_SetChipType(
 	IN	u1Byte		chipType
 	);
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_com.c linux/3rdparty/rtl8723bs/hal/hal_com.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_com.c	2015-05-10 14:36:05.688668124 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_com.c	2015-05-07 17:46:55.000000000 +0300
@@ -29,7 +29,7 @@ u8 rtw_hal_data_init(_adapter *padapter)
 	if(is_primary_adapter(padapter))	//if(padapter->isprimary)
 	{
 		padapter->hal_data_sz = sizeof(HAL_DATA_TYPE);
-		padapter->HalData = rtw_zvmalloc(padapter->hal_data_sz);
+		padapter->HalData = vzalloc(padapter->hal_data_sz);
 		if(padapter->HalData == NULL){
 			DBG_8192C("cant not alloc memory for HAL DATA \n");
 			return _FAIL;
@@ -47,7 +47,7 @@ void rtw_hal_data_deinit(_adapter *padap
 			#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
 			phy_free_filebuf(padapter);				
 			#endif		
-			rtw_vmfree(padapter->HalData, padapter->hal_data_sz);
+			vfree(padapter->HalData);
 			padapter->HalData = NULL;
 			padapter->hal_data_sz = 0;
 		}	
@@ -165,10 +165,8 @@ HAL_IsLegalChannel(
 	bool bLegalChannel = true;
 
 	if (Channel > 14) {
-		if(IsSupported5G(Adapter->registrypriv.wireless_mode) == false) {
-			bLegalChannel = false;
-			DBG_871X("Channel > 14 but wireless_mode do not support 5G\n");
-		}
+		bLegalChannel = false;
+		DBG_871X("Channel > 14 but wireless_mode do not support 5G\n");
 	} else if ((Channel <= 14) && (Channel >=1)){
 		if(IsSupported24G(Adapter->registrypriv.wireless_mode) == false) {
 			bLegalChannel = false;
@@ -577,20 +575,6 @@ void c2h_evt_clear(_adapter *adapter)
 	rtw_write8(adapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);
 }
 
-s32 c2h_evt_read(_adapter *adapter, u8 *buf)
-{
-	s32 ret = _FAIL;
-	struct c2h_evt_hdr *c2h_evt;
-	int i;
-	u8 trigger;
-
-	if (buf == NULL)
-		goto exit;
-
-exit:
-	return ret;
-}
-
 /* 
 * C2H event format:
 * Field    TRIGGER    CMD_LEN    CONTENT    CMD_SEQ    CMD_ID
@@ -725,14 +709,10 @@ _func_enter_;
 		break;
 	case HW_VAR_SEC_CFG:
 	{
-		#if defined(DYNAMIC_CAMID_ALLOC)
 		u16 reg_scr;
 
 		reg_scr = rtw_read16(adapter, REG_SECCFG);
 		rtw_write16(adapter, REG_SECCFG, reg_scr|SCR_CHK_KEYID|SCR_RxDecEnable|SCR_TxEncEnable);
-		#else
-		rtw_write8(adapter, REG_SECCFG, *((u8*)val));
-		#endif
 	}
 		break;
 	case HW_VAR_SEC_DK_CFG:
@@ -1019,10 +999,10 @@ void SetHalODMVar(
 				}
 				else{
 					DBG_8192C("### Clean STA_(%d) info ###\n",psta->mac_id);
-					//_enter_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+					//spin_lock_bh(&pHalData->odm_stainfo_lock);
 					ODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS,psta->mac_id,NULL);
 					
-					//_exit_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+					//spin_unlock_bh(&pHalData->odm_stainfo_lock);
 			            }
 			}
 			break;
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_com_phycfg.c linux/3rdparty/rtl8723bs/hal/hal_com_phycfg.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_com_phycfg.c	2015-05-10 14:36:05.690668146 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_com_phycfg.c	2015-05-07 17:46:55.000000000 +0300
@@ -22,50 +22,6 @@
 #include <drv_types.h>
 #include <hal_data.h>
 
-
-//
-//	Description:
-//		Map Tx power index into dBm according to 
-//		current HW model, for example, RF and PA, and
-//		current wireless mode.
-//	By Bruce, 2008-01-29.
-//
-s32
-phy_TxPwrIdxToDbm(
-	IN	PADAPTER		Adapter,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u8				TxPwrIdx
-	)
-{
-	s32				Offset = 0;
-	s32				PwrOutDbm = 0;
-	
-	//
-	// Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm.
-	// Note:
-	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.  
-	// By Bruce, 2008-01-29.
-	// 
-	switch(WirelessMode)
-	{
-	case WIRELESS_MODE_B:
-		Offset = -7;		
-		break;
-
-	case WIRELESS_MODE_G:
-	case WIRELESS_MODE_N_24G:
-		Offset = -8;
-		break;
-		
-	default: //for MacOSX compiler warning
-		break;		
-	}
-
-	PwrOutDbm = TxPwrIdx / 2 + Offset; // Discard the decimal part.
-
-	return PwrOutDbm;
-}
-
 u8
 PHY_GetTxPowerByRateBase(
 	IN	PADAPTER		Adapter,
@@ -272,7 +228,7 @@ phy_StoreTxPowerByRateBase(
 	IN	PADAPTER	pAdapter
 	)
 {
-	u8	path = 0, base = 0, index = 0;
+	u8	path, base;
 	
 	//DBG_871X( "===>%s\n", __FUNCTION__ );
 	
@@ -399,9 +355,8 @@ PHY_GetRateValuesOfTxPowerByRate(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA( pAdapter );
-	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
-	u8	 			index = 0, i = 0;
-	
+	u8 i = 0;
+
 	switch ( RegAddr )
 	{
 		case rTxAGC_A_Rate18_06:
@@ -875,7 +830,7 @@ PHY_InitTxPowerByRate(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	u8	band = 0, rfPath = 0, TxNum = 0, rate = 0, i = 0, j = 0;
+	u8	band, rfPath, TxNum, rate;
 
 	for ( band = BAND_ON_2_4G; band <= BAND_ON_5G; ++band )
 			for ( rfPath = 0; rfPath < TX_PWR_BY_RATE_NUM_RF; ++rfPath )
@@ -921,10 +876,8 @@ phy_ConvertTxPowerByRateInDbmToRelativeV
 	IN	PADAPTER	pAdapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA( pAdapter );
 	u8 			base = 0, i = 0, value = 0,
-				band = 0, path = 0, txNum = 0, index = 0, 
-				startIndex = 0, endIndex = 0;
+				band = 0, path = 0, txNum = 0;
 	u8			cckRates[4] = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M},
 				ofdmRates[8] = {MGN_6M, MGN_9M, MGN_12M, MGN_18M, MGN_24M, MGN_36M, MGN_48M, MGN_54M},
 				mcs0_7Rates[8] = {MGN_MCS0, MGN_MCS1, MGN_MCS2, MGN_MCS3, MGN_MCS4, MGN_MCS5, MGN_MCS6, MGN_MCS7},
@@ -1024,8 +977,6 @@ PHY_TxPowerByRateConfiguration(
 	IN  PADAPTER			pAdapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA( pAdapter);
-
 	phy_StoreTxPowerByRateBase( pAdapter );
 	phy_ConvertTxPowerByRateInDbmToRelativeValues( pAdapter );
 }
@@ -1166,7 +1117,6 @@ PHY_GetTxPowerIndexBase(
 	)
 {
 	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T			pDM_Odm = &pHalData->odmpriv;
 	u8					i = 0;	//default set to 1S
 	u8					txPower = 0;
 	u8					chnlIdx = (Channel-1);
@@ -1475,7 +1425,7 @@ PHY_GetTxPowerByRate(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA( pAdapter );
-	s8 			value = 0, limit = 0;
+	s8 			value = 0;
 	u8			rateIndex = PHY_GetRateIndexOfTxPowerByRate( Rate );
 
 	if ( ( pAdapter->registrypriv.RegEnableTxPowerByRate == 2 && pHalData->EEPROMRegulatory == 2 ) || 
@@ -1925,10 +1875,8 @@ PHY_ConvertTxPowerLimitToPowerIndex(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u8 				BW40PwrBasedBm2_4G = 0x2E, BW40PwrBasedBm5G = 0x2E;
+	u8 				BW40PwrBasedBm2_4G = 0x2E;
 	u8 				regulation, bw, channel, rateSection;	
-	u8 				baseIndex2_4G;
-	u8				baseIndex5G;
 	s8 				tempValue = 0, tempPwrLmt = 0;
 	u8 				rfPath = 0;
 
@@ -2121,11 +2069,7 @@ PHY_GetTxPowerIndex(
 	IN	u8					Channel
 	)
 {
-	u8	txPower = 0x3E;
-
-	txPower = PHY_GetTxPowerIndex_8723B(pAdapter, RFPath, Rate, BandWidth, Channel);
-
-	return txPower;
+	return PHY_GetTxPowerIndex_8723B(pAdapter, RFPath, Rate, BandWidth, Channel);
 }
 
 void
@@ -2340,7 +2284,7 @@ phy_ConfigMACWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->mac_reg = rtw_zvmalloc(rlen);
+				pHalData->mac_reg = vzalloc(rlen);
 				if(pHalData->mac_reg) {
 					memcpy(pHalData->mac_reg, pHalData->para_file_buf, rlen);
 					pHalData->mac_reg_len = rlen;
@@ -2439,7 +2383,7 @@ phy_ConfigBBWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pBuf = rtw_zvmalloc(rlen);
+				pBuf = vzalloc(rlen);
 				if(pBuf) {
 					memcpy(pBuf, pHalData->para_file_buf, rlen);
 					*pBufLen = rlen;
@@ -2888,7 +2832,7 @@ phy_ConfigBBWithPgParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->bb_phy_reg_pg = rtw_zvmalloc(rlen);
+				pHalData->bb_phy_reg_pg = vzalloc(rlen);
 				if(pHalData->bb_phy_reg_pg) {
 					memcpy(pHalData->bb_phy_reg_pg, pHalData->para_file_buf, rlen);
 					pHalData->bb_phy_reg_pg_len = rlen;
@@ -2968,7 +2912,7 @@ PHY_ConfigRFWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pBuf = rtw_zvmalloc(rlen);
+				pBuf = vzalloc(rlen);
 				if(pBuf) {
 					memcpy(pBuf, pHalData->para_file_buf, rlen);
 					*pBufLen = rlen;
@@ -3242,7 +3186,7 @@ PHY_ConfigRFWithTxPwrTrackParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->rf_tx_pwr_track = rtw_zvmalloc(rlen);
+				pHalData->rf_tx_pwr_track = vzalloc(rlen);
 				if(pHalData->rf_tx_pwr_track) {
 					memcpy(pHalData->rf_tx_pwr_track, pHalData->para_file_buf, rlen);
 					pHalData->rf_tx_pwr_track_len = rlen;
@@ -3591,7 +3535,7 @@ PHY_ConfigRFWithPowerLimitTableParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->rf_tx_pwr_lmt = rtw_zvmalloc(rlen);
+				pHalData->rf_tx_pwr_lmt = vzalloc(rlen);
 				if(pHalData->rf_tx_pwr_lmt) {
 					memcpy(pHalData->rf_tx_pwr_lmt, pHalData->para_file_buf, rlen);
 					pHalData->rf_tx_pwr_lmt_len = rlen;
@@ -3631,23 +3575,23 @@ void phy_free_filebuf(_adapter *padapter
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
 	
 	if(pHalData->mac_reg)
-		rtw_vmfree(pHalData->mac_reg, pHalData->mac_reg_len);
+		vfree(pHalData->mac_reg);
 	if(pHalData->bb_phy_reg)
-		rtw_vmfree(pHalData->bb_phy_reg, pHalData->bb_phy_reg_len);
+		vfree(pHalData->bb_phy_reg);
 	if(pHalData->bb_agc_tab)
-		rtw_vmfree(pHalData->bb_agc_tab, pHalData->bb_agc_tab_len);
+		vfree(pHalData->bb_agc_tab);
 	if(pHalData->bb_phy_reg_pg)
-		rtw_vmfree(pHalData->bb_phy_reg_pg, pHalData->bb_phy_reg_pg_len);
+		vfree(pHalData->bb_phy_reg_pg);
 	if(pHalData->bb_phy_reg_mp)
-		rtw_vmfree(pHalData->bb_phy_reg_mp, pHalData->bb_phy_reg_mp_len);
+		vfree(pHalData->bb_phy_reg_mp);
 	if(pHalData->rf_radio_a)
-		rtw_vmfree(pHalData->rf_radio_a, pHalData->rf_radio_a_len);
+		vfree(pHalData->rf_radio_a);
 	if(pHalData->rf_radio_b)
-		rtw_vmfree(pHalData->rf_radio_b, pHalData->rf_radio_b_len);
+		vfree(pHalData->rf_radio_b);
 	if(pHalData->rf_tx_pwr_track)
-		rtw_vmfree(pHalData->rf_tx_pwr_track, pHalData->rf_tx_pwr_track_len);
+		vfree(pHalData->rf_tx_pwr_track);
 	if(pHalData->rf_tx_pwr_lmt)
-		rtw_vmfree(pHalData->rf_tx_pwr_lmt, pHalData->rf_tx_pwr_lmt_len);	
+		vfree(pHalData->rf_tx_pwr_lmt);
 	
 }
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_BB.c linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_BB.c
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_BB.c	2015-05-10 14:36:05.690668146 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_BB.c	2015-05-07 17:46:55.000000000 +0300
@@ -313,12 +313,6 @@ ODM_ReadAndConfig_MP_8723B_AGC_TAB(
     }
 }
 
-u4Byte
-ODM_GetVersion_MP_8723B_AGC_TAB(void)
-{
-	   return 11;
-}
-
 /******************************************************************************
 *                           PHY_REG.TXT
 ******************************************************************************/
@@ -588,12 +582,6 @@ ODM_ReadAndConfig_MP_8723B_PHY_REG(
     }
 }
 
-u4Byte
-ODM_GetVersion_MP_8723B_PHY_REG(void)
-{
-	   return 11;
-}
-
 /******************************************************************************
 *                           PHY_REG_PG.TXT
 ******************************************************************************/
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_BB.h linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_BB.h
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_BB.h	2015-05-10 14:36:05.690668146 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_BB.h	2015-05-07 17:46:55.000000000 +0300
@@ -30,7 +30,6 @@ void
 ODM_ReadAndConfig_MP_8723B_AGC_TAB( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
-u4Byte ODM_GetVersion_MP_8723B_AGC_TAB(void);
 
 /******************************************************************************
 *                           PHY_REG.TXT
@@ -40,7 +39,6 @@ void
 ODM_ReadAndConfig_MP_8723B_PHY_REG( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
-u4Byte ODM_GetVersion_MP_8723B_PHY_REG(void);
 
 /******************************************************************************
 *                           PHY_REG_PG.TXT
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_MAC.c linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_MAC.c
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_MAC.c	2015-05-10 14:36:05.699668247 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_MAC.c	2015-05-07 17:46:55.000000000 +0300
@@ -284,9 +284,3 @@ ODM_ReadAndConfig_MP_8723B_MAC_REG(
         } 
     }
 }
-
-u4Byte
-ODM_GetVersion_MP_8723B_MAC_REG(void)
-{
-	   return 11;
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_MAC.h linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_MAC.h
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_MAC.h	2015-05-10 14:36:05.699668247 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_MAC.h	2015-05-07 17:46:55.000000000 +0300
@@ -30,6 +30,4 @@ void
 ODM_ReadAndConfig_MP_8723B_MAC_REG( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
-u4Byte ODM_GetVersion_MP_8723B_MAC_REG(void);
-
 #endif
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_RF.c linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_RF.c
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_RF.c	2015-05-10 14:36:05.700668257 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_RF.c	2015-05-07 17:46:55.000000000 +0300
@@ -306,34 +306,6 @@ ODM_ReadAndConfig_MP_8723B_RadioA(
     }
 }
 
-u4Byte
-ODM_GetVersion_MP_8723B_RadioA(void)
-{
-	   return 11;
-}
-
-/******************************************************************************
-*                           TxPowerTrack_AP.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_AP(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-}
-
-/******************************************************************************
-*                           TxPowerTrack_PCIE.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_PCIE(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-}
-
 /******************************************************************************
 *                           TxPowerTrack_SDIO.TXT
 ******************************************************************************/
@@ -394,17 +366,6 @@ ODM_ReadAndConfig_MP_8723B_TxPowerTrack_
 }
 
 /******************************************************************************
-*                           TxPowerTrack_USB.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_USB(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-}
-
-/******************************************************************************
 *                           TXPWR_LMT.TXT
 ******************************************************************************/
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_RF.h linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_RF.h
--- linux/3rdparty/rtl8723bs.old/hal/HalHWImg8723B_RF.h	2015-05-10 14:36:05.700668257 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalHWImg8723B_RF.h	2015-05-07 17:46:55.000000000 +0300
@@ -30,27 +30,6 @@ void
 ODM_ReadAndConfig_MP_8723B_RadioA( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
-u4Byte ODM_GetVersion_MP_8723B_RadioA(void);
-
-/******************************************************************************
-*                           TxPowerTrack_AP.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_AP( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-u4Byte ODM_GetVersion_MP_8723B_TxPowerTrack_AP(void);
-
-/******************************************************************************
-*                           TxPowerTrack_PCIE.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_PCIE( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-u4Byte ODM_GetVersion_MP_8723B_TxPowerTrack_PCIE(void);
 
 /******************************************************************************
 *                           TxPowerTrack_SDIO.TXT
@@ -63,16 +42,6 @@ ODM_ReadAndConfig_MP_8723B_TxPowerTrack_
 u4Byte ODM_GetVersion_MP_8723B_TxPowerTrack_SDIO(void);
 
 /******************************************************************************
-*                           TxPowerTrack_USB.TXT
-******************************************************************************/
-
-void
-ODM_ReadAndConfig_MP_8723B_TxPowerTrack_USB( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-u4Byte ODM_GetVersion_MP_8723B_TxPowerTrack_USB(void);
-
-/******************************************************************************
 *                           TXPWR_LMT.TXT
 ******************************************************************************/
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_intf.c linux/3rdparty/rtl8723bs/hal/hal_intf.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_intf.c	2015-05-10 14:36:05.700668257 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_intf.c	2015-05-07 17:46:55.000000000 +0300
@@ -69,29 +69,6 @@ void rtw_hal_dm_deinit(_adapter *padapte
 		if(padapter->HalFunc.dm_deinit)
 			padapter->HalFunc.dm_deinit(padapter);
 }
-void	rtw_hal_sw_led_init(_adapter *padapter)
-{
-	if(padapter->HalFunc.InitSwLeds)
-		padapter->HalFunc.InitSwLeds(padapter);
-}
-
-void rtw_hal_sw_led_deinit(_adapter *padapter)
-{
-	if(padapter->HalFunc.DeInitSwLeds)
-		padapter->HalFunc.DeInitSwLeds(padapter);
-}
-
-u32 rtw_hal_power_on(_adapter *padapter)
-{
-	if(padapter->HalFunc.hal_power_on)
-		return padapter->HalFunc.hal_power_on(padapter);
-	return _FAIL;
-}
-void rtw_hal_power_off(_adapter *padapter)
-{
-	if(padapter->HalFunc.hal_power_off)
-		padapter->HalFunc.hal_power_off(padapter);	
-}
 
 static void rtw_hal_init_opmode(_adapter *padapter) 
 {
@@ -136,8 +113,6 @@ uint	 rtw_hal_init(_adapter *padapter)
 		for (i = 0; i<dvobj->iface_nums; i++)
 			rtw_sec_restore_wep_key(dvobj->padapters[i]);
 
-		rtw_led_control(padapter, LED_CTL_POWER_ON);
-
 		init_hw_mlme_ext(padapter);
 		
 		rtw_bb_rf_gain_offset(padapter);
@@ -164,7 +139,6 @@ _func_enter_;
 	status = padapter->HalFunc.hal_deinit(padapter);
 
 	if(status == _SUCCESS){
-		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 		for (i = 0; i<dvobj->iface_nums; i++) {
 			padapter = dvobj->padapters[i];
 			padapter->hw_init_completed = false;
@@ -261,41 +235,6 @@ void rtw_hal_clear_interrupt(_adapter *p
 }
 #endif
 
-u32	rtw_hal_inirp_init(_adapter *padapter)
-{
-	u32 rst = _FAIL;
-	if(padapter->HalFunc.inirp_init)	
-		rst = padapter->HalFunc.inirp_init(padapter);	
-	else		
-		DBG_871X(" %s HalFunc.inirp_init is NULL!!!\n",__FUNCTION__);		
-	return rst;
-}
-	
-u32	rtw_hal_inirp_deinit(_adapter *padapter)
-{
-	
-	if(padapter->HalFunc.inirp_deinit)
-		return padapter->HalFunc.inirp_deinit(padapter);
-
-	return _FAIL;
-		
-}
-
-void	rtw_hal_irp_reset(_adapter *padapter)
-{
-	if(padapter->HalFunc.irp_reset)
-		padapter->HalFunc.irp_reset(padapter);
-	else 
-		DBG_871X("%s: HalFunc.rtw_hal_irp_reset is NULL!\n", __FUNCTION__);
-}
-
-u8	rtw_hal_intf_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id, u8* val)
-{	
-	if(padapter->HalFunc.interface_ps_func)	
-		return padapter->HalFunc.interface_ps_func(padapter,efunc_id,val);
-	return _FAIL;
-}
-
 s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
 	if(padapter->HalFunc.hal_xmitframe_enqueue)
@@ -325,7 +264,6 @@ s32	rtw_hal_mgnt_xmit(_adapter *padapter
 	//pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 	//memcpy(pmgntframe->attrib.ra, pwlanhdr->addr1, ETH_ALEN);
 
-#ifdef CONFIG_IEEE80211W
 	if(padapter->securitypriv.binstallBIPkey == true)
 	{
 		if(IS_MCAST(pmgntframe->attrib.ra))
@@ -340,8 +278,7 @@ s32	rtw_hal_mgnt_xmit(_adapter *padapter
 		}
 		rtw_mgmt_xmitframe_coalesce(padapter, pmgntframe->pkt, pmgntframe);
 	}
-#endif //CONFIG_IEEE80211W
-	
+
 	if(padapter->HalFunc.mgnt_xmit)
 		ret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);
 	return ret;
@@ -441,19 +378,6 @@ void	rtw_hal_write_rfreg(_adapter *padap
 		padapter->HalFunc.write_rfreg(padapter, eRFPath, RegAddr, BitMask, Data);	
 }
 
-s32	rtw_hal_interrupt_handler(_adapter *padapter)
-{
-	if(padapter->HalFunc.interrupt_handler)
-		return padapter->HalFunc.interrupt_handler(padapter);
-	return _FAIL;
-}
-
-void	rtw_hal_set_bwmode(_adapter *padapter, CHANNEL_WIDTH Bandwidth, u8 Offset)
-{
-	if(padapter->HalFunc.set_bwmode_handler)
-		padapter->HalFunc.set_bwmode_handler(padapter, Bandwidth, Offset);
-}
-
 void	rtw_hal_set_chan(_adapter *padapter, u8 channel)
 {
 	if(padapter->HalFunc.set_channel_handler)
@@ -466,18 +390,6 @@ void	rtw_hal_set_chnl_bw(_adapter *padap
 		padapter->HalFunc.set_chnl_bw_handler(padapter, channel, Bandwidth, Offset40, Offset80);
 }
 
-void	rtw_hal_set_tx_power_level(_adapter *padapter, u8 channel)
-{
-	if(padapter->HalFunc.set_tx_power_level_handler)
-		padapter->HalFunc.set_tx_power_level_handler(padapter, channel);
-}
-
-void	rtw_hal_get_tx_power_level(_adapter *padapter, s32 *powerlevel)
-{
-	if(padapter->HalFunc.get_tx_power_level_handler)
-		padapter->HalFunc.get_tx_power_level_handler(padapter, powerlevel);
-}
-
 void	rtw_hal_dm_watchdog(_adapter *padapter)
 {
 	if(padapter->HalFunc.hal_dm_watchdog)
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_phy.c linux/3rdparty/rtl8723bs/hal/hal_phy.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_phy.c	2015-05-10 14:36:05.700668257 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_phy.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,285 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#define _HAL_PHY_C_
-
-#include <drv_types.h>
-
-//================================================================================
-//	Constant.
-//================================================================================
-// 2008/11/20 MH For Debug only, RF
-static RF_SHADOW_T RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
-
-/**
-* Function:	PHY_CalculateBitShift
-*
-* OverView:	Get shifted position of the BitMask
-*
-* Input:
-*			u4Byte		BitMask,	
-*
-* Output:	none
-* Return:		u4Byte		Return the shift bit bit position of the mask
-*/
-u32
-PHY_CalculateBitShift(
-	u32 BitMask
-	)
-{
-	u32 i;
-
-	for(i=0; i<=31; i++)
-	{
-		if ( ((BitMask>>i) &  0x1 ) == 1)
-			break;
-	}
-
-	return (i);
-}
-
-
-//
-// ==> RF shadow Operation API Code Section!!!
-//
-/*-----------------------------------------------------------------------------
- * Function:	PHY_RFShadowRead
- *				PHY_RFShadowWrite
- *				PHY_RFShadowCompare
- *				PHY_RFShadowRecorver
- *				PHY_RFShadowCompareAll
- *				PHY_RFShadowRecorverAll
- *				PHY_RFShadowCompareFlagSet
- *				PHY_RFShadowRecorverFlagSet
- *
- * Overview:	When we set RF register, we must write shadow at first.
- *			When we are running, we must compare shadow abd locate error addr.
- *			Decide to recorver or not.
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- * When			Who		Remark
- * 11/20/2008 	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-u32
-PHY_RFShadowRead(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset)
-{
-	return	RF_Shadow[eRFPath][Offset].Value;
-
-}	/* PHY_RFShadowRead */
-
-
-void
-PHY_RFShadowWrite(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u32				Data)
-{
-	RF_Shadow[eRFPath][Offset].Value = (Data & bRFRegOffsetMask);
-	RF_Shadow[eRFPath][Offset].Driver_Write = true;
-
-}	/* PHY_RFShadowWrite */
-
-
-bool
-PHY_RFShadowCompare(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset)
-{
-	u32	reg;
-	// Check if we need to check the register
-	if (RF_Shadow[eRFPath][Offset].Compare == true)
-	{
-		reg = rtw_hal_read_rfreg(Adapter, eRFPath, Offset, bRFRegOffsetMask);
-		// Compare shadow and real rf register for 20bits!!
-		if (RF_Shadow[eRFPath][Offset].Value != reg)
-		{
-			// Locate error position.
-			RF_Shadow[eRFPath][Offset].ErrorOrNot = true;
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n",
-			//eRFPath, Offset, reg));
-		}
-		return RF_Shadow[eRFPath][Offset].ErrorOrNot ;
-	}
-	return false;
-}	/* PHY_RFShadowCompare */
-
-
-void
-PHY_RFShadowRecorver(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset)
-{
-	// Check if the address is error
-	if (RF_Shadow[eRFPath][Offset].ErrorOrNot == true)
-	{
-		// Check if we need to recorver the register.
-		if (RF_Shadow[eRFPath][Offset].Recorver == true)
-		{
-			rtw_hal_write_rfreg(Adapter, eRFPath, Offset, bRFRegOffsetMask,
-							RF_Shadow[eRFPath][Offset].Value);
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowRecorver RF-%d Addr%02lx=%05lx",
-			//eRFPath, Offset, RF_Shadow[eRFPath][Offset].Value));
-		}
-	}
-
-}	/* PHY_RFShadowRecorver */
-
-
-void
-PHY_RFShadowCompareAll(
-	IN	PADAPTER			Adapter)
-{
-	u8		eRFPath = 0 ;
-	u32		Offset = 0, maxReg= GET_RF6052_REAL_MAX_REG(Adapter);
-
-	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
-	{
-		for (Offset = 0; Offset < maxReg; Offset++)
-		{
-			PHY_RFShadowCompare(Adapter, eRFPath, Offset);
-		}
-	}
-
-}	/* PHY_RFShadowCompareAll */
-
-
-void
-PHY_RFShadowRecorverAll(
-	IN	PADAPTER			Adapter)
-{
-	u8		eRFPath =0;
-	u32		Offset = 0, maxReg= GET_RF6052_REAL_MAX_REG(Adapter);
-
-	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
-	{
-		for (Offset = 0; Offset < maxReg; Offset++)
-		{
-			PHY_RFShadowRecorver(Adapter, eRFPath, Offset);
-		}
-	}
-
-}	/* PHY_RFShadowRecorverAll */
-
-
-void
-PHY_RFShadowCompareFlagSet(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u8				Type)
-{
-	// Set True or False!!!
-	RF_Shadow[eRFPath][Offset].Compare = Type;
-
-}	/* PHY_RFShadowCompareFlagSet */
-
-
-void
-PHY_RFShadowRecorverFlagSet(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u8				Type)
-{
-	// Set True or False!!!
-	RF_Shadow[eRFPath][Offset].Recorver= Type;
-
-}	/* PHY_RFShadowRecorverFlagSet */
-
-
-void
-PHY_RFShadowCompareFlagSetAll(
-	IN	PADAPTER			Adapter)
-{
-	u8		eRFPath = 0;
-	u32		Offset = 0, maxReg= GET_RF6052_REAL_MAX_REG(Adapter);
-
-	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
-	{
-		for (Offset = 0; Offset < maxReg; Offset++)
-		{
-			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
-			if (Offset != 0x26 && Offset != 0x27)
-				PHY_RFShadowCompareFlagSet(Adapter, eRFPath, Offset, false);
-			else
-				PHY_RFShadowCompareFlagSet(Adapter, eRFPath, Offset, true);
-		}
-	}
-
-}	/* PHY_RFShadowCompareFlagSetAll */
-
-
-void
-PHY_RFShadowRecorverFlagSetAll(
-	IN	PADAPTER			Adapter)
-{
-	u8		eRFPath = 0;
-	u32		Offset = 0, maxReg= GET_RF6052_REAL_MAX_REG(Adapter);
-
-	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
-	{
-		for (Offset = 0; Offset < maxReg; Offset++)
-		{
-			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
-			if (Offset != 0x26 && Offset != 0x27)
-				PHY_RFShadowRecorverFlagSet(Adapter, eRFPath, Offset, false);
-			else
-				PHY_RFShadowRecorverFlagSet(Adapter, eRFPath, Offset, true);
-		}
-	}
-
-}	/* PHY_RFShadowCompareFlagSetAll */
-
-void
-PHY_RFShadowRefresh(
-	IN	PADAPTER			Adapter)
-{
-	u8		eRFPath = 0;
-	u32		Offset = 0, maxReg= GET_RF6052_REAL_MAX_REG(Adapter);
-
-	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
-	{
-		for (Offset = 0; Offset < maxReg; Offset++)
-		{
-			RF_Shadow[eRFPath][Offset].Value = 0;
-			RF_Shadow[eRFPath][Offset].Compare = false;
-			RF_Shadow[eRFPath][Offset].Recorver  = false;
-			RF_Shadow[eRFPath][Offset].ErrorOrNot = false;
-			RF_Shadow[eRFPath][Offset].Driver_Write = false;
-		}
-	}
-
-}	/* PHY_RFShadowRead */
-
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalPhyRf_8723B.c linux/3rdparty/rtl8723bs/hal/HalPhyRf_8723B.c
--- linux/3rdparty/rtl8723bs.old/hal/HalPhyRf_8723B.c	2015-05-10 14:36:05.702668280 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalPhyRf_8723B.c	2015-05-07 17:46:55.000000000 +0300
@@ -88,24 +88,24 @@ static void setIqkMatrix_8723B(
 		case ODM_RF_PATH_A:
 			//wirte new elements A, C, D to regC80 and regC94, element B is always 0
 			value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
 
 			value32 = (ele_C&0x000003C0)>>6;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
 
 			value32 = ((IqkResult_X * ele_D)>>7)&0x01;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT24, value32);			
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT24, value32);
 			break;
 		case ODM_RF_PATH_B:
 			//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
 			value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
 
 			value32 = (ele_C&0x000003C0)>>6;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskH4Bits, value32);	
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
 			
 			value32 = ((IqkResult_X * ele_D)>>7)&0x01;
-			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT28, value32);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT28, value32);
 			
 			break;			
 		default:
@@ -117,15 +117,15 @@ static void setIqkMatrix_8723B(
 		switch (RFPath)
 		{
 		case ODM_RF_PATH_A:
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);				
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
-			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT24, 0x00);			
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT24, 0x00);
 			break;
 
 		case ODM_RF_PATH_B:
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);										
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);	
-			ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT28, 0x00);				
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable_New[OFDM_index]);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
+			PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT28, 0x00);
 			break;			
 
 		default:
@@ -146,25 +146,25 @@ setCCKFilterCoefficient(
 {
 	if(!pDM_Odm->RFCalibrateInfo.bCCKinCH14)
 	{
-		ODM_Write1Byte(pDM_Odm, 0xa22, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][0]);
-		ODM_Write1Byte(pDM_Odm, 0xa23, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][1]);
-		ODM_Write1Byte(pDM_Odm, 0xa24, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][2]);
-		ODM_Write1Byte(pDM_Odm, 0xa25, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][3]);
-		ODM_Write1Byte(pDM_Odm, 0xa26, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][4]);
-		ODM_Write1Byte(pDM_Odm, 0xa27, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][5]);
-		ODM_Write1Byte(pDM_Odm, 0xa28, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][6]);
-		ODM_Write1Byte(pDM_Odm, 0xa29, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][7]);		
+		rtw_write8(pDM_Odm->Adapter, 0xa22, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][0]);
+		rtw_write8(pDM_Odm->Adapter, 0xa23, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][1]);
+		rtw_write8(pDM_Odm->Adapter, 0xa24, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][2]);
+		rtw_write8(pDM_Odm->Adapter, 0xa25, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][3]);
+		rtw_write8(pDM_Odm->Adapter, 0xa26, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][4]);
+		rtw_write8(pDM_Odm->Adapter, 0xa27, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][5]);
+		rtw_write8(pDM_Odm->Adapter, 0xa28, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][6]);
+		rtw_write8(pDM_Odm->Adapter, 0xa29, CCKSwingTable_Ch1_Ch13_New[CCKSwingIndex][7]);
 	}
 	else
 	{
-		ODM_Write1Byte(pDM_Odm, 0xa22, CCKSwingTable_Ch14_New[CCKSwingIndex][0]);
-		ODM_Write1Byte(pDM_Odm, 0xa23, CCKSwingTable_Ch14_New[CCKSwingIndex][1]);
-		ODM_Write1Byte(pDM_Odm, 0xa24, CCKSwingTable_Ch14_New[CCKSwingIndex][2]);
-		ODM_Write1Byte(pDM_Odm, 0xa25, CCKSwingTable_Ch14_New[CCKSwingIndex][3]);
-		ODM_Write1Byte(pDM_Odm, 0xa26, CCKSwingTable_Ch14_New[CCKSwingIndex][4]);
-		ODM_Write1Byte(pDM_Odm, 0xa27, CCKSwingTable_Ch14_New[CCKSwingIndex][5]);
-		ODM_Write1Byte(pDM_Odm, 0xa28, CCKSwingTable_Ch14_New[CCKSwingIndex][6]);
-		ODM_Write1Byte(pDM_Odm, 0xa29, CCKSwingTable_Ch14_New[CCKSwingIndex][7]);	
+		rtw_write8(pDM_Odm->Adapter, 0xa22, CCKSwingTable_Ch14_New[CCKSwingIndex][0]);
+		rtw_write8(pDM_Odm->Adapter, 0xa23, CCKSwingTable_Ch14_New[CCKSwingIndex][1]);
+		rtw_write8(pDM_Odm->Adapter, 0xa24, CCKSwingTable_Ch14_New[CCKSwingIndex][2]);
+		rtw_write8(pDM_Odm->Adapter, 0xa25, CCKSwingTable_Ch14_New[CCKSwingIndex][3]);
+		rtw_write8(pDM_Odm->Adapter, 0xa26, CCKSwingTable_Ch14_New[CCKSwingIndex][4]);
+		rtw_write8(pDM_Odm->Adapter, 0xa27, CCKSwingTable_Ch14_New[CCKSwingIndex][5]);
+		rtw_write8(pDM_Odm->Adapter, 0xa28, CCKSwingTable_Ch14_New[CCKSwingIndex][6]);
+		rtw_write8(pDM_Odm->Adapter, 0xa29, CCKSwingTable_Ch14_New[CCKSwingIndex][7]);
 	}		
 }
 
@@ -487,60 +487,60 @@ phy_PathA_IQK_8723B(
 	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
 
 	// Save RF Path 
-	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord);
+	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path A IQK!\n"));
 
 	//leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	//	enable path A PA in TXIQK mode
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0003f );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xc7f87 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0003f );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xc7f87 );
 	//	disable path B PA in TXIQK mode
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, bRFRegOffsetMask, 0x00020 );
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x40ec1 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, bRFRegOffsetMask, 0x00020 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x40ec1 );
 
 	//1 Tx IQK
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 	//path-A IQK setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A IQK setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-//	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x8214010a);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x821303ea);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x8214010a);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x821303ea);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 	//enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//Ant switch
 	if (configPathB || (RF_Path == 0))
 		// wifi switch to S1
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000000);
 	else
 		// wifi switch to S0
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path A LOK & IQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path A LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 	
 	// delay x ms
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME_8723B));
@@ -548,23 +548,23 @@ phy_PathA_IQK_8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
 	//leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
-	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xeac = 0x%x\n", regEAC));
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n", 
-	ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+	PHY_QueryBBReg(pDM_Odm->Adapter, 0xe90, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xe98, bMaskDWord)));
 
 
 	//Allen 20131125
@@ -601,61 +601,61 @@ phy_PathA_RxIQK8723B(
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path A Rx IQK!\n"));
 
 	// Save RF Path 
-	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord); 
+	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
 
 	//leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path A RX IQK:Get TXIMR setting\n"));
 	//1 Get TXIMR setting
 	//modify RXIQK mode table
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A Rx IQK modify RXIQK mode table!\n"));
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f);
 	//LNA2 off, PA on for Dcut
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);	
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	//path-A IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-
-//	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82130ff0);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);	
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+//	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82130ff0);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
 	//enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//Ant switch
 	if (configPathB || (RF_Path == 0))
 		// wifi switch to S1
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000000);
 	else
 		// wifi switch to S0
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path A LOK & IQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path A LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 	
 	// delay x ms
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME_8723B));
@@ -663,22 +663,22 @@ phy_PathA_RxIQK8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
 	//leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
-	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xeac = 0x%x\n", regEAC));	
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n", 
-		ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+		PHY_QueryBBReg(pDM_Odm->Adapter, 0xe90, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xe98, bMaskDWord)));
 
 	//Allen 20131125
 		tmp=(regE9C & 0x03FF0000)>>16;
@@ -698,8 +698,8 @@ phy_PathA_RxIQK8723B(
 
 
 	u4tmp = 0x80007C00 | (regE94&0x3FF0000)  | ((regE9C&0x3FF0000) >> 16);	
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, u4tmp);
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe40 = 0x%x u4tmp = 0x%x \n", ODM_GetBBReg(pDM_Odm, rTx_IQK, bMaskDWord), u4tmp));	
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, u4tmp);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe40 = 0x%x u4tmp = 0x%x \n", PHY_QueryBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord), u4tmp));
 	
 
 	//1 RX IQK
@@ -707,56 +707,56 @@ phy_PathA_RxIQK8723B(
 
 	//modify RXIQK mode table
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A Rx IQK modify RXIQK mode table 2!\n"));
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);			
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);				  
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f ); 
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f );
 	//LAN2 on, PA off for Dcut
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7d77 ); 
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);				   
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7d77 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);
 	
 	//PA, PAD setting
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0xf80 );  
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x55, bRFRegOffsetMask, 0x4021f ); 
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0xf80 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x55, bRFRegOffsetMask, 0x4021f );
 
 
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	//path-A IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-//	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x281604c2);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x2813001f);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x281604c2);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x2813001f);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a8d1);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a8d1);
 
 	//enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//Ant switch
 	if (configPathB || (RF_Path == 0))
 		// wifi switch to S1
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000000);
 	else
 		// wifi switch to S0
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path A LOK & IQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path A LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 	
 	// delay x ms
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME_88E));
@@ -764,26 +764,26 @@ phy_PathA_RxIQK8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regEA4= ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord);
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regEA4= PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("0xeac = 0x%x\n", regEAC));
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xea4 = 0x%x, 0xeac = 0x%x\n", regEA4, regEAC));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xea0(before IQK)= 0x%x, 0xea8(afer IQK) = 0x%x\n", 
-	ODM_GetBBReg(pDM_Odm, 0xea0, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xea8, bMaskDWord)));
+	PHY_QueryBBReg(pDM_Odm->Adapter, 0xea0, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xea8, bMaskDWord)));
 
 	//	PA/PAD controlled by 0x0
 	//leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0x780 );
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0x780 );
 
 	//Allen 20131125
 		tmp=(regEAC & 0x03FF0000)>>16;
@@ -819,57 +819,57 @@ phy_PathB_IQK_8723B(
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Path B IQK!\n"));
 
 	// Save RF Path
-	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord);
+	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
 
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	//	in TXIQK mode
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x20000 );
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0003f );
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xc7f87 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x20000 );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0003f );
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xc7f87 );
 	//	enable path B PA in TXIQK mode
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x20, 0x1);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30fc1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x20, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30fc1);
 
 
 
 	//1 Tx IQK
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 	//path-A IQK setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-B IQK setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	
-//	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82140114);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x821303ea);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	
+//	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140114);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x821303ea);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 	//enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//switch to path B
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path B LOK & IQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path B LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 	// delay x ms
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Delay %d ms for One shot, path B LOK & IQK.\n", IQK_DELAY_TIME_88E));
@@ -877,25 +877,25 @@ phy_PathB_IQK_8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
-//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0x948 = 0x%x\n", ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord)));
+//	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0x948 = 0x%x\n", PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord)));
 	
 	
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
-	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("0xeac = 0x%x\n", regEAC));
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n", 
-		ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+		PHY_QueryBBReg(pDM_Odm->Adapter, 0xe90, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xe98, bMaskDWord)));
 
 	//Allen 20131125
 	tmp=(regE9C & 0x03FF0000)>>16;
@@ -929,61 +929,61 @@ phy_PathB_RxIQK8723B(
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path B Rx IQK!\n"));
 
 	// Save RF Path
-	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord);
+	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	//switch to path B
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
 
 	//1 Get TXIMR setting
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path B RX IQK:Get TXIMR setting!\n"));
 	//modify RXIQK mode table
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A Rx IQK modify RXIQK mode table!\n"));
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7 );
 	//open PA S1 & SMIXER
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x20, 0x1 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30fcd );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x20, 0x1 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30fcd );
 	
 
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 
 	//path-B IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-
-//	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f );
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82130ff0);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28110000);	
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+//	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82160c1f );
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82130ff0);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
     //enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//switch to path B
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path B TXIQK @ RXIQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path B LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 	
 	// delay x ms
@@ -992,22 +992,22 @@ phy_PathB_RxIQK8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regE94 = ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord);
-	regE9C= ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord);
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("0xeac = 0x%x\n", regEAC));
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe94 = 0x%x, 0xe9c = 0x%x\n", regE94, regE9C));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe90(before IQK)= 0x%x, 0xe98(afer IQK) = 0x%x\n", 
-		ODM_GetBBReg(pDM_Odm, 0xe90, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xe98, bMaskDWord)));
+		PHY_QueryBBReg(pDM_Odm->Adapter, 0xe90, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xe98, bMaskDWord)));
 
 	//Allen 20131125
 		tmp=(regE9C & 0x03FF0000)>>16;
@@ -1029,8 +1029,8 @@ phy_PathB_RxIQK8723B(
 
 
 	u4tmp = 0x80007C00 | (regE94&0x3FF0000)  | ((regE9C&0x3FF0000) >> 16);	
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, u4tmp);
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe40 = 0x%x u4tmp = 0x%x \n", ODM_GetBBReg(pDM_Odm, rTx_IQK, bMaskDWord), u4tmp));	
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord, u4tmp);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xe40 = 0x%x u4tmp = 0x%x \n", PHY_QueryBBReg(pDM_Odm->Adapter, rTx_IQK, bMaskDWord), u4tmp));
 	
 
 	//1 RX IQK
@@ -1038,56 +1038,56 @@ phy_PathB_RxIQK8723B(
 
 	//modify RXIQK mode table
 	//<20121009, Kordan> RF Mode = 3
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);				   
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f); 
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7d77); 
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);	 
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7d77);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x0);
 
 	//open PA S1 & close SMIXER
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x20, 0x1); 
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30ebd);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x20, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x30ebd);
 
 	//PA, PAD setting
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0xf80);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x56, bRFRegOffsetMask, 0x51000); 
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xdf, bRFRegOffsetMask, 0xf80);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x56, bRFRegOffsetMask, 0x51000);
 
 
 
 	//IQK setting
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	//path-B IQK setting
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
-
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-//	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x281604c2);	
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x2813001f);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_B, bMaskDWord, 0x38008c1c);
+
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x281604c2);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_A, bMaskDWord, 0x2813001f);
+	PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_PI_B, bMaskDWord, 0x28110000);
 
 	//LO calibration setting
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("LO calibration setting!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x0046a8d1);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a8d1);
 
     //enter IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//switch to path B
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, 0x00000280);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, bRFRegOffsetMask, 0xeffe0);
 
 	//GNT_BT = 0
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00000800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00000800);
 
 	//One shot, path B LOK & IQK
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("One shot, path B LOK & IQK!\n"));
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(pDM_Odm->Adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 	
 	// delay x ms
 //	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME_88E));
@@ -1095,27 +1095,27 @@ phy_PathB_RxIQK8723B(
 	mdelay(IQK_DELAY_TIME_8723B);
 
 	//restore Ant Path
-	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord,Path_SEL_BB);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord,Path_SEL_BB);
 	//GNT_BT = 1
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, 0x00001800);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, 0x00001800);
 
     //leave IQK mode
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
 
 	// Check failed
-	regEAC = ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regEA4= ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord);;
+	regEAC = PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regEA4= PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);;
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("0xeac = 0x%x\n", regEAC));
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xea4 = 0x%x, 0xeac = 0x%x\n", regEA4, regEAC));
 	//monitor image power before & after IQK
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("0xea0(before IQK)= 0x%x, 0xea8(afer IQK) = 0x%x\n", 
-		ODM_GetBBReg(pDM_Odm, 0xea0, bMaskDWord), ODM_GetBBReg(pDM_Odm, 0xea8, bMaskDWord)));
+		PHY_QueryBBReg(pDM_Odm->Adapter, 0xea0, bMaskDWord), PHY_QueryBBReg(pDM_Odm->Adapter, 0xea8, bMaskDWord)));
 
 	//	PA/PAD controlled by 0x0
 	//leave IQK mode
-//	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x00000000);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0xdf, bRFRegOffsetMask, 0x180 );
+//	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, 0xffffff00, 0x00000000);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_B, 0xdf, bRFRegOffsetMask, 0x180 );
 
 
 
@@ -1165,16 +1165,16 @@ _PHY_PathAFillIQKMatrix8723B(
 
 	else if(bIQKOK)
 	{
-		Oldval_0 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+		Oldval_0 = (PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
 
 		X = result[final_candidate][0];
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00; 			
 		TX0_A = (X * Oldval_0) >> 8;
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("X = 0x%x, TX0_A = 0x%x, Oldval_0 0x%x\n", X, TX0_A, Oldval_0));
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
 
-		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
 	 
 		Y = result[final_candidate][1];
 		if ((Y & 0x00000200) != 0)
@@ -1183,17 +1183,17 @@ _PHY_PathAFillIQKMatrix8723B(
 		//2 Tx IQC
 		TX0_C = (Y * Oldval_0) >> 8;
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Y = 0x%x, TX = 0x%x\n", Y, TX0_C));
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][KEY] = rOFDM0_XCTxAFE;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XCTxAFE, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XCTxAFE, bMaskDWord);
 		
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][KEY] = rOFDM0_XATxIQImbalance;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XATxIQImbalance, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XATxIQImbalance, bMaskDWord);
 
-		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][KEY] = rOFDM0_ECCAThreshold;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskDWord);
 
 		if(bTxOnly)
 		{
@@ -1201,9 +1201,9 @@ _PHY_PathAFillIQKMatrix8723B(
 
 			// <20130226, Kordan> Saving RxIQC, otherwise not initialized.
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
-			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL] = 0xfffffff & ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, bMaskDWord);
+			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL] = 0xfffffff & PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_RxIQExtAnta, bMaskDWord);
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
-//			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XARxIQImbalance, bMaskDWord);
+//			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, bMaskDWord);
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = 0x40000100;
 			return;
 		}
@@ -1211,16 +1211,16 @@ _PHY_PathAFillIQKMatrix8723B(
 		reg = result[final_candidate][2];
 
 		//2 Rx IQC
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
 		reg = result[final_candidate][3] & 0x3F;
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
 		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
-		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XARxIQImbalance, bMaskDWord);
+		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, bMaskDWord);
 
 		reg = (result[final_candidate][3] >> 6) & 0xF;
-		ODM_SetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
 		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
-		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, bMaskDWord);
+		pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_RxIQExtAnta, bMaskDWord);
 		
 	}
 }
@@ -1248,7 +1248,7 @@ _PHY_PathBFillIQKMatrix8723B(
 
 	else if(bIQKOK)
 	{
-		Oldval_1 = (ODM_GetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+		Oldval_1 = (PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
 
 		X = result[final_candidate][4];
 		if ((X & 0x00000200) != 0)
@@ -1256,9 +1256,9 @@ _PHY_PathBFillIQKMatrix8723B(
 		TX1_A = (X * Oldval_1) >> 8;
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("X = 0x%x, TX1_A = 0x%x\n", X, TX1_A));
 
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
 		
-		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
 
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
@@ -1268,43 +1268,43 @@ _PHY_PathBFillIQKMatrix8723B(
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Y = 0x%x, TX1_C = 0x%x\n", Y, TX1_C));
 		
 		//2 Tx IQC		
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
 //		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC9C][KEY] = rOFDM0_XDTxAFE;
-//		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC9C][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskDWord);
+//		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC9C][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, bMaskDWord);
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][KEY] = rOFDM0_XCTxAFE;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XDTxAFE, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XDTxAFE, bMaskDWord);
 
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][KEY] = rOFDM0_XATxIQImbalance;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XBTxIQImbalance, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord);
 
-		ODM_SetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
 		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][KEY] = rOFDM0_ECCAThreshold;
-		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_ECCAThreshold, bMaskDWord);
+		pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_ECCAThreshold, bMaskDWord);
 		
 		if(bTxOnly) {
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("_PHY_PathBFillIQKMatrix8723B only Tx OK\n"));
 			
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
-//			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XARxIQImbalance, bMaskDWord); 		
+//			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XARxIQImbalance, bMaskDWord);
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = 0x40000100;	
 			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
-			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL] = 0x0fffffff & ODM_GetBBReg(pDM_Odm, rOFDM0_RxIQExtAnta, bMaskDWord);
+			pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL] = 0x0fffffff & PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_RxIQExtAnta, bMaskDWord);
 			return;
 		}
 
 		//2 Rx IQC
 		reg = result[final_candidate][6];
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
 		reg = result[final_candidate][7] & 0x3F;
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
 		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][KEY] = rOFDM0_XARxIQImbalance;
-		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = ODM_GetBBReg(pDM_Odm, rOFDM0_XBRxIQImbalance, bMaskDWord);
+		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL] = PHY_QueryBBReg(pDM_Odm->Adapter, rOFDM0_XBRxIQImbalance, bMaskDWord);
 
 		reg = (result[final_candidate][7] >> 6) & 0xF;
-//		ODM_SetBBReg(pDM_Odm, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+//		PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
 		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][KEY] = rOFDM0_RxIQExtAnta;
-		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL] = (reg << 28)|(ODM_GetBBReg(pDM_Odm,rOFDM0_RxIQExtAnta, bMaskDWord)& 0x0fffffff);		
+		pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL] = (reg << 28)|(PHY_QueryBBReg(pDM_Odm->Adapter,rOFDM0_RxIQExtAnta, bMaskDWord)& 0x0fffffff);
 	}
 }
 
@@ -1328,22 +1328,22 @@ ODM_SetIQCbyRFpath(
   	if(RFpath) //S1: RFpath = 0, S0:RFpath = 1
   	{
 	  //S0 TX IQC
-      ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][VAL]);
-  	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][VAL]);
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][VAL]);
+      PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC94][VAL]);
+  	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC80][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S0][IDX_0xC4C][VAL]);
       //S0 RX IQC
-  	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL]);
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL]);
+  	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xC14][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S0][IDX_0xCA0][VAL]);
     }
     else
     {
 	  //S1 TX IQC
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][VAL]);
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][VAL]);
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC94][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC80][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][KEY], bMaskDWord, pRFCalibrateInfo->TxIQC_8723B[PATH_S1][IDX_0xC4C][VAL]);
 	  //S1 RX IQC
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL]);
-	  ODM_SetBBReg(pDM_Odm, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xC14][VAL]);
+	  PHY_SetBBReg(pDM_Odm->Adapter, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][KEY], bMaskDWord, pRFCalibrateInfo->RxIQC_8723B[PATH_S1][IDX_0xCA0][VAL]);
     }
   }	
 }
@@ -1396,7 +1396,7 @@ _PHY_SaveADDARegisters8723B(
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Save ADDA parameters.\n"));
 	for( i = 0 ; i < RegisterNum ; i++){
-		ADDABackup[i] = ODM_GetBBReg(pDM_Odm, ADDAReg[i], bMaskDWord);
+		ADDABackup[i] = PHY_QueryBBReg(pDM_Odm->Adapter, ADDAReg[i], bMaskDWord);
 	}
 }
 
@@ -1414,9 +1414,9 @@ _PHY_SaveMACRegisters8723B(
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Save MAC parameters.\n"));
 	for( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		MACBackup[i] = ODM_Read1Byte(pDM_Odm, MACReg[i]);		
+		MACBackup[i] = rtw_read8(pDM_Odm->Adapter, MACReg[i]);
 	}
-	MACBackup[i] = ODM_Read4Byte(pDM_Odm, MACReg[i]);		
+	MACBackup[i] = rtw_read32(pDM_Odm->Adapter, MACReg[i]);
 
 }
 
@@ -1436,7 +1436,7 @@ _PHY_ReloadADDARegisters8723B(
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Reload ADDA power saving parameters !\n"));
 	for(i = 0 ; i < RegiesterNum; i++)
 	{
-		ODM_SetBBReg(pDM_Odm, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+		PHY_SetBBReg(pDM_Odm->Adapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
 	}
 }
 
@@ -1453,9 +1453,9 @@ _PHY_ReloadMACRegisters8723B(
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Reload MAC parameters !\n"));
 	for(i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)MACBackup[i]);
+		rtw_write8(pAdapter, MACReg[i], (u1Byte)MACBackup[i]);
 	}
-	ODM_Write4Byte(pDM_Odm, MACReg[i], MACBackup[i]);	
+	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);
 }
 
 
@@ -1477,14 +1477,14 @@ _PHY_PathADDAOn8723B(
 	pathOn = isPathAOn ? 0x01c00014 : 0x01c00014;
 	if(false == is2T){
 		pathOn = 0x01c00014;
-		ODM_SetBBReg(pDM_Odm, ADDAReg[0], bMaskDWord, 0x01c00014);
+		PHY_SetBBReg(pDM_Odm->Adapter, ADDAReg[0], bMaskDWord, 0x01c00014);
 	}
 	else{
-		ODM_SetBBReg(pDM_Odm,ADDAReg[0], bMaskDWord, pathOn);
+		PHY_SetBBReg(pDM_Odm->Adapter,ADDAReg[0], bMaskDWord, pathOn);
 	}
 	
 	for( i = 1 ; i < IQK_ADDA_REG_NUM ; i++){
-		ODM_SetBBReg(pDM_Odm,ADDAReg[i], bMaskDWord, pathOn);
+		PHY_SetBBReg(pDM_Odm->Adapter,ADDAReg[i], bMaskDWord, pathOn);
 	}
 	
 }
@@ -1502,12 +1502,12 @@ _PHY_MACSettingCalibration8723B(
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("MAC settings for Calibration.\n"));
 
-	ODM_Write1Byte(pDM_Odm, MACReg[i], 0x3F);
+	rtw_write8(pDM_Odm->Adapter, MACReg[i], 0x3F);
 
 	for(i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT3)));
+		rtw_write8(pDM_Odm->Adapter, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT3)));
 	}
-	ODM_Write1Byte(pDM_Odm, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT5))); 
+	rtw_write8(pDM_Odm->Adapter, MACReg[i], (u1Byte)(MACBackup[i]&(~BIT5))); 
 
 }
 
@@ -1642,8 +1642,8 @@ phy_IQCalibrate_8723B(
 
 	u4Byte			i;
 	u1Byte			PathAOK, PathBOK;
-	u1Byte			tmp0xc50 = (u1Byte)ODM_GetBBReg(pDM_Odm, 0xC50, bMaskByte0);
-	u1Byte			tmp0xc58 = (u1Byte)ODM_GetBBReg(pDM_Odm, 0xC58, bMaskByte0);	
+	u1Byte			tmp0xc50 = (u1Byte)PHY_QueryBBReg(pDM_Odm->Adapter, 0xC50, bMaskByte0);
+	u1Byte			tmp0xc58 = (u1Byte)PHY_QueryBBReg(pDM_Odm->Adapter, 0xC58, bMaskByte0);	
 	u4Byte			ADDA_REG[IQK_ADDA_REG_NUM] = {	
 						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,	
 						rRx_Wait_CCA,		rTx_CCK_RFON,
@@ -1677,7 +1677,7 @@ phy_IQCalibrate_8723B(
 
 	if(t==0)
 	{
-//		 bbvalue = ODM_GetBBReg(pDM_Odm, rFPGA0_RFMOD, bMaskDWord);
+//		 bbvalue = PHY_QueryBBReg(pDM_Odm->Adapter, rFPGA0_RFMOD, bMaskDWord);
 //			RT_DISP(FINIT, INIT_IQK, ("phy_IQCalibrate_8188E()==>0x%08x\n",bbvalue));
 
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("IQ Calibration for %s for %d times\n", (is2T ? "2T2R" : "1T1R"), t));
@@ -1694,41 +1694,41 @@ phy_IQCalibrate_8723B(
 //no serial mode
 
 	//save RF path for 8723B
-//	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord);
-//	Path_SEL_RF = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, 0xfffff);
+//	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
+//	Path_SEL_RF = PHY_QueryRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, 0xfffff);
 	
 	//MAC settings
 	_PHY_MACSettingCalibration8723B(pAdapter, IQK_MAC_REG, pDM_Odm->RFCalibrateInfo.IQK_MAC_backup);
 
 	//BB setting
-	//ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0x00); 	
-	ODM_SetBBReg(pDM_Odm, rCCK0_AFESetting, 0x0f000000, 0xf);	
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
+	//PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_RFMOD, BIT24, 0x00);
+	PHY_SetBBReg(pDM_Odm->Adapter, rCCK0_AFESetting, 0x0f000000, 0xf);
+	PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
 
 	
-//	ODM_SetBBReg(pDM_Odm, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
-//	ODM_SetBBReg(pDM_Odm, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);	
-//	ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
-//	ODM_SetBBReg(pDM_Odm, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);	
+//	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
+//	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
 	
 
 //RX IQ calibration setting for 8723B D cut large current issue when leaving IPS
 
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	 
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
-    ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000);
-    ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f);
-    ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7);
-    ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x20, 0x1); 
-    ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x60fbd); 
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1);
+    PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000);
+    PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f);
+    PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7fb7);
+    PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x20, 0x1);
+    PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x60fbd);
 /*
 //LOK RF setting
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x2, 0x1);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xef, 0x2, 0x1);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x56, bRFRegOffsetMask, 0x00032);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x76, bRFRegOffsetMask, 0x00032); 
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x2, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xef, 0x2, 0x1);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x56, bRFRegOffsetMask, 0x00032);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x76, bRFRegOffsetMask, 0x00032);
 */
 
 
@@ -1738,12 +1738,12 @@ phy_IQCalibrate_8723B(
 //		if(PathAOK == 0x03){
 		if(PathAOK == 0x01){
 			// Path A Tx IQK Success
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
-			pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_A] = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x8, bRFRegOffsetMask);
+			PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+			pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_A] = PHY_QueryRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x8, bRFRegOffsetMask);
 
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path A Tx IQK Success!!\n"));
-				result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-				result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][0] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][1] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
 	}
@@ -1753,10 +1753,10 @@ phy_IQCalibrate_8723B(
 		PathAOK = phy_PathA_RxIQK8723B(pAdapter, is2T, RF_Path);
 		if(PathAOK == 0x03){
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Path A Rx IQK Success!!\n"));
-//				result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-//				result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-				result[t][2] = (ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				result[t][3] = (ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+//				result[t][0] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+//				result[t][1] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][2] = (PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][3] = (PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
 		else
@@ -1778,12 +1778,12 @@ phy_IQCalibrate_8723B(
 //		if(PathBOK == 0x03){
 		if(PathBOK == 0x01){
 			// Path B Tx IQK Success
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
-			pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_B] = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x8, bRFRegOffsetMask);
+			PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0x000000);
+			pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_B] = PHY_QueryRFReg(pDM_Odm->Adapter, ODM_RF_PATH_B, 0x8, bRFRegOffsetMask);
 
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path B Tx IQK Success!!\n"));
-				result[t][4] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-				result[t][5] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][4] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
 	}
@@ -1793,10 +1793,10 @@ for(i = 0 ; i < retryCount ; i++){
 		PathBOK = phy_PathB_RxIQK8723B(pAdapter, is2T);
 		if(PathBOK == 0x03){
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Path B Rx IQK Success!!\n"));
-//				result[t][0] = (ODM_GetBBReg(pDM_Odm, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-//				result[t][1] = (ODM_GetBBReg(pDM_Odm, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-				result[t][6] = (ODM_GetBBReg(pDM_Odm, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				result[t][7] = (ODM_GetBBReg(pDM_Odm, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+//				result[t][0] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+//				result[t][1] = (PHY_QueryBBReg(pDM_Odm->Adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(pDM_Odm->Adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
 		else
@@ -1813,7 +1813,7 @@ for(i = 0 ; i < retryCount ; i++){
 
 	//Back to BB mode, load original value
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("IQK:Back to BB mode, load original value!\n"));
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0);
+	PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_IQK, bMaskH3Bytes, 0);
 
 	if(t!=0)
 	{
@@ -1826,21 +1826,21 @@ for(i = 0 ; i < retryCount ; i++){
 		_PHY_ReloadADDARegisters8723B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup, IQK_BB_REG_NUM);
 
 		//Reload RF path
-//		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, Path_SEL_BB);
-//		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF);
+//		PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, Path_SEL_BB);
+//		PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF);
 	
 		//Allen initial gain 0xc50
 		// Restore RX initial gain
-		ODM_SetBBReg(pDM_Odm, 0xc50, bMaskByte0, 0x50);
-		ODM_SetBBReg(pDM_Odm, 0xc50, bMaskByte0, tmp0xc50);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0xc50, bMaskByte0, 0x50);
+		PHY_SetBBReg(pDM_Odm->Adapter, 0xc50, bMaskByte0, tmp0xc50);
 		if(is2T){
-			ODM_SetBBReg(pDM_Odm, 0xc58, bMaskByte0, 0x50);
-			ODM_SetBBReg(pDM_Odm, 0xc58, bMaskByte0, tmp0xc58);
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xc58, bMaskByte0, 0x50);
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xc58, bMaskByte0, tmp0xc58);
 		}
 	
 		//load 0xe30 IQC default value
-		ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);		
-		ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);				
+		PHY_SetBBReg(pDM_Odm->Adapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		PHY_SetBBReg(pDM_Odm->Adapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 		
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("phy_IQCalibrate_8723B() <==\n"));
@@ -1859,12 +1859,12 @@ phy_LCCalibrate_8723B(
 	PADAPTER pAdapter = pDM_Odm->Adapter;
 
 	//Check continuous TX and Packet TX
-	tmpReg = ODM_Read1Byte(pDM_Odm, 0xd03);
+	tmpReg = rtw_read8(pDM_Odm->Adapter, 0xd03);
 
 	if((tmpReg&0x70) != 0)			//Deal with contisuous TX case
-		ODM_Write1Byte(pDM_Odm, 0xd03, tmpReg&0x8F);	//disable all continuous TX
+		rtw_write8(pDM_Odm->Adapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
 	else							// Deal with Packet TX case
-		ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF); 		// block all queues
+		rtw_write8(pDM_Odm->Adapter, REG_TXPAUSE, 0xFF); 		// block all queues
 
 	if((tmpReg&0x70) != 0)
 	{
@@ -1878,44 +1878,44 @@ phy_LCCalibrate_8723B(
 
 		//2. Set RF mode = standby mode
 		//Path-A
-		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bMask12Bits, (RF_Amode&0x8FFFF)|0x10000);
+		PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_AC, bMask12Bits, (RF_Amode&0x8FFFF)|0x10000);
 
 		//Path-B
 		if(is2T)
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_AC, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);			
+			PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_B, RF_AC, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);
 	}
 	
 	//3. Read RF reg18
 	LC_Cal = PHY_QueryRFReg(pAdapter, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits);
 
 	//4. Set LC calibration begin	bit15
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFBE0); // LDO ON
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal|0x08000);
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFBE0); // LDO ON
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal|0x08000);
 
 	mdelay(100);		
 
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFFE0); // LDO OFF
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xB0, bRFRegOffsetMask, 0xDFFE0); // LDO OFF
 
 	// Channel 10 LC calibration issue for 8723bs with 26M xtal
 	if(pDM_Odm->SupportInterface == ODM_ITRF_SDIO && pDM_Odm->PackageType >= 0x2)
 	{
-		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal);
+		PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal);
 	}
 
 	//Restore original situation
 	if((tmpReg&0x70) != 0)	//Deal with contisuous TX case 
 	{  
 		//Path-A
-		ODM_Write1Byte(pDM_Odm, 0xd03, tmpReg);
-		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bMask12Bits, RF_Amode);
+		rtw_write8(pDM_Odm->Adapter, 0xd03, tmpReg);
+		PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_AC, bMask12Bits, RF_Amode);
 		
 		//Path-B
 		if(is2T)
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_AC, bMask12Bits, RF_Bmode);
+			PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_B, RF_AC, bMask12Bits, RF_Bmode);
 	}
 	else // Deal with Packet TX case
 	{
-		ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x00); 
+		rtw_write8(pDM_Odm->Adapter, REG_TXPAUSE, 0x00); 
 	}
 }
 
@@ -1924,118 +1924,6 @@ phy_LCCalibrate_8723B(
 #define 	APK_CURVE_REG_NUM 4
 #define 	PATH_NUM		2
 
-static void	
-phy_APCalibrate_8723B(
-	IN	PADAPTER	pAdapter,
-	IN	s8		delta,
-	IN	bool 	is2T
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
-	u4Byte			regD[PATH_NUM];
-	u4Byte			tmpReg, index, offset,	apkbound;
-	u1Byte			path, i, pathbound = PATH_NUM;		
-	u4Byte			BB_backup[APK_BB_REG_NUM];
-	u4Byte			BB_REG[APK_BB_REG_NUM] = {	
-						rFPGA1_TxBlock, 	rOFDM0_TRxPathEnable, 
-						rFPGA0_RFMOD,	rOFDM0_TRMuxPar, 
-						rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW, 
-						rFPGA0_XA_RFInterfaceOE,	rFPGA0_XB_RFInterfaceOE };
-	u4Byte			BB_AP_MODE[APK_BB_REG_NUM] = {	
-						0x00000020, 0x00a05430, 0x02040000, 
-						0x000800e4, 0x00204000 };
-	u4Byte			BB_normal_AP_MODE[APK_BB_REG_NUM] = {	
-						0x00000020, 0x00a05430, 0x02040000, 
-						0x000800e4, 0x22204000 };						
-
-	u4Byte			AFE_backup[IQK_ADDA_REG_NUM];
-	u4Byte			AFE_REG[IQK_ADDA_REG_NUM] = {	
-						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,	
-						rRx_Wait_CCA,		rTx_CCK_RFON,
-						rTx_CCK_BBON,	rTx_OFDM_RFON,	
-						rTx_OFDM_BBON,	rTx_To_Rx,
-						rTx_To_Tx,		rRx_CCK,	
-						rRx_OFDM,		rRx_Wait_RIFS,
-						rRx_TO_Rx,		rStandby,	
-						rSleep, 			rPMPD_ANAEN };
-
-	u4Byte			MAC_backup[IQK_MAC_REG_NUM];
-	u4Byte			MAC_REG[IQK_MAC_REG_NUM] = {
-						REG_TXPAUSE,		REG_BCN_CTRL,	
-						REG_BCN_CTRL_1, REG_GPIO_MUXCFG};
-
-	u4Byte			APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
-					{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
-					};	
-
-	u4Byte			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	//path settings equal to path b settings
-					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
-					};
-	
-	u4Byte			APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
-					{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
-					};
-
-	u4Byte			APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	//path settings equal to path b settings
-					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
-					};
-
-	u4Byte			AFE_on_off[PATH_NUM] = {
-					0x04db25a4, 0x0b1b25a4};	//path A on path B off / path A off path B on
-
-	u4Byte			APK_offset[PATH_NUM] = {
-					rConfig_AntA, rConfig_AntB};
-
-	u4Byte			APK_normal_offset[PATH_NUM] = {
-					rConfig_Pmpd_AntA, rConfig_Pmpd_AntB};
-					
-	u4Byte			APK_value[PATH_NUM] = {
-					0x92fc0000, 0x12fc0000};					
-
-	u4Byte			APK_normal_value[PATH_NUM] = {
-					0x92680000, 0x12680000};					
-
-	s8			APK_delta_mapping[APK_BB_REG_NUM][13] = {
-					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},											
-					{-6, -4, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-					{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-					{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
-					};
-	
-	u4Byte			APK_normal_setting_value_1[13] = {
-					0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
-					0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
-					0x12680000, 0x00880000, 0x00880000
-					};
-
-	u4Byte			APK_normal_setting_value_2[16] = {
-					0x01c7021d, 0x01670183, 0x01000123, 0x00bf00e2, 0x008d00a3,
-					0x0068007b, 0x004d0059, 0x003a0042, 0x002b0031, 0x001f0025,
-					0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
-					0x00050006
-					};
-	
-	u4Byte			APK_result[PATH_NUM][APK_BB_REG_NUM];	//val_1_1a, val_1_2a, val_2a, val_3a, val_4a
-//	u4Byte			AP_curve[PATH_NUM][APK_CURVE_REG_NUM];
-
-	s4Byte			BB_offset, delta_V, delta_offset;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("==>phy_APCalibrate_8188E() delta %d\n", delta));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("AP Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
-	if(!is2T)
-		pathbound = 1;
-
-	//2 FOR NORMAL CHIP SETTINGS
-}
-
-
-
 #define 	DP_BB_REG_NUM		7
 #define 	DP_RF_REG_NUM		1
 #define 	DP_RETRY_LIMIT		10
@@ -2106,7 +1994,7 @@ PHY_IQCalibrate_8723B(
 		//#define PATH_S0	1 // RF_PATH_B
 		//#define PATH_S1	0 // RF_PATH_A
 
-		path = (ODM_GetBBReg(pDM_Odm,rS0S1_PathSwitch,bMaskByte0)==0x00) ? ODM_RF_PATH_A : ODM_RF_PATH_B;
+		path = (PHY_QueryBBReg(pDM_Odm->Adapter,rS0S1_PathSwitch,bMaskByte0)==0x00) ? ODM_RF_PATH_A : ODM_RF_PATH_B;
 
 		// Restore TX IQK
 		for (i = 0; i < 3; ++i) {
@@ -2118,7 +2006,7 @@ PHY_IQCalibrate_8723B(
 				break;
 			}
 			//RT_TRACE(_module_mp_, _drv_notice_,("Switch to S1 TxIQC(offset, data) = (0x%X, 0x%X)\n", offset, data));
-			ODM_SetBBReg(pDM_Odm,offset, bMaskDWord, data);
+			PHY_SetBBReg(pDM_Odm->Adapter,offset, bMaskDWord, data);
 		}
 
 		// Restore RX IQK
@@ -2131,15 +2019,15 @@ PHY_IQCalibrate_8723B(
 				break;
 			}
 			//RT_TRACE(_module_mp_, _drv_notice_,("Switch to S1 RxIQC (offset, data) = (0x%X, 0x%X)\n", offset, data));
-			ODM_SetBBReg(pDM_Odm,offset, bMaskDWord, data);
+			PHY_SetBBReg(pDM_Odm->Adapter,offset, bMaskDWord, data);
 		}
 
 		if (pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_A] ==0) {
 			DBG_871X("%s => Restore Path-A TxLOK result failed \n",__FUNCTION__);
 			bResult = FAIL;
 		} else {
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXM_IDAC, bRFRegOffsetMask, pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_A]);  
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_TXM_IDAC, bRFRegOffsetMask, pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_B]);  
+			PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXM_IDAC, bRFRegOffsetMask, pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_A]);
+			PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_B, RF_TXM_IDAC, bRFRegOffsetMask, pDM_Odm->RFCalibrateInfo.TxLOK[ODM_RF_PATH_B]);
 		}
 
 		if (bResult == SUCCESS)
@@ -2156,14 +2044,14 @@ PHY_IQCalibrate_8723B(
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("IQK:Start!!!\n"));
 
 	//save default GNT_BT
-	GNT_BT_default = ODM_GetBBReg(pDM_Odm, 0x764, bMaskDWord);
+	GNT_BT_default = PHY_QueryBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord);
 	// Save RF Path 
-//	Path_SEL_BB = ODM_GetBBReg(pDM_Odm, 0x948, bMaskDWord);
-//	Path_SEL_RF = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, 0xfffff);
+//	Path_SEL_BB = PHY_QueryBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord);
+//	Path_SEL_RF = PHY_QueryRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, 0xfffff);
 
     //set GNT_BT=0, pause BT traffic
-//	ODM_SetBBReg(pDM_Odm, 0x764, BIT12, 0x0);
-//	ODM_SetBBReg(pDM_Odm, 0x764, BIT11, 0x1);
+//	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT12, 0x0);
+//	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT11, 0x1);
 
 
 	for(i = 0; i < 8; i++)
@@ -2290,22 +2178,22 @@ PHY_IQCalibrate_8723B(
 	_PHY_SaveADDARegisters8723B(pAdapter, IQK_BB_REG_92C, pDM_Odm->RFCalibrateInfo.IQK_BB_backup_recover, 9);
 
 	//restore GNT_BT
-	ODM_SetBBReg(pDM_Odm, 0x764, bMaskDWord, GNT_BT_default);
+	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, bMaskDWord, GNT_BT_default);
 	// Restore RF Path
-//	ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, Path_SEL_BB);
-//	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF);
+//	PHY_SetBBReg(pDM_Odm->Adapter, 0x948, bMaskDWord, Path_SEL_BB);
+//	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xb0, 0xfffff, Path_SEL_RF);
 
 	//Resotr RX mode table parameter
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xe6177 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0xed, 0x20, 0x1 );
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x300bd );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_WE_LUT, 0x80000, 0x1 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x18000 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0001f );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xe6177 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0xed, 0x20, 0x1 );
+	PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, 0x43, bRFRegOffsetMask, 0x300bd );
 
 	//set GNT_BT= HW control
-//	ODM_SetBBReg(pDM_Odm, 0x764, BIT12, 0x0);
-//	ODM_SetBBReg(pDM_Odm, 0x764, BIT11, 0x0);
+//	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT12, 0x0);
+//	PHY_SetBBReg(pDM_Odm->Adapter, 0x764, BIT11, 0x0);
 
 	if (Is2ant) {
 		if (RF_Path == 0x0)	//S1
@@ -2367,59 +2255,3 @@ PHY_LCCalibrate_8723B(
 	ProgressingTime = jiffies_to_msecs(jiffies - StartTime);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("LCK ProgressingTime = %d\n", ProgressingTime));
 }
-
-void
-PHY_APCalibrate_8723B(
-	IN	PADAPTER	pAdapter,
-	IN	s8		delta	
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
-#if DISABLE_BB_RF
-	return;
-#endif
-
-	return;
-
-	if(!(pDM_Odm->SupportAbility & ODM_RF_CALIBRATION))
-	{
-		return;
-	}
-
-	if(pDM_Odm->RFCalibrateInfo.bAPKdone)
-		return;
-
-	// For 88C 1T1R
-	phy_APCalibrate_8723B(pAdapter, delta, false);
-}
-static void phy_SetRFPathSwitch_8723B(
-	IN	PADAPTER	pAdapter,
-	IN	bool 	bMain,
-	IN	bool 	is2T
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
-
-	if(bMain) // Left antenna	
-	{
-		ODM_SetBBReg(pDM_Odm, 0x92C, bMaskDWord, 0x1);		
-	}			
-	else
-	{
-		ODM_SetBBReg(pDM_Odm, 0x92C, bMaskDWord, 0x2);		
-	}		
-}
-void PHY_SetRFPathSwitch_8723B(
-	IN	PADAPTER	pAdapter,
-	IN	bool 	bMain
-	)
-{
-
-#if DISABLE_BB_RF
-	return;
-#endif
-
-		phy_SetRFPathSwitch_8723B(pAdapter, bMain, true);
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalPhyRf_8723B.h linux/3rdparty/rtl8723bs/hal/HalPhyRf_8723B.h
--- linux/3rdparty/rtl8723bs.old/hal/HalPhyRf_8723B.h	2015-05-10 14:36:05.702668280 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalPhyRf_8723B.h	2015-05-07 17:46:55.000000000 +0300
@@ -76,10 +76,6 @@ PHY_LCCalibrate_8723B(
 // AP calibrate
 //
 void	
-PHY_APCalibrate_8723B(		
-	IN	PADAPTER	pAdapter,
-							IN 	s8		delta);
-void	
 PHY_DigitalPredistortion_8723B(		IN	PADAPTER	pAdapter);
 
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/HalPhyRf.c linux/3rdparty/rtl8723bs/hal/HalPhyRf.c
--- linux/3rdparty/rtl8723bs.old/hal/HalPhyRf.c	2015-05-10 14:36:05.702668280 +0300
+++ linux/3rdparty/rtl8723bs/hal/HalPhyRf.c	2015-05-07 17:46:55.000000000 +0300
@@ -129,7 +129,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter
 		 \n pDM_Odm->BbSwingIdxCckBase: %d, pDM_Odm->BbSwingIdxOfdmBase[A]: %d, pDM_Odm->DefaultOfdmIndex: %d\n", 
 		pDM_Odm->BbSwingIdxCckBase, pDM_Odm->BbSwingIdxOfdmBase[ODM_RF_PATH_A], pDM_Odm->DefaultOfdmIndex));
 
-	ThermalValue = (u1Byte)ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
+	ThermalValue = (u1Byte)PHY_QueryRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, c.ThermalRegAddr, 0xfc00);	//0x42: RF Reg[15:10] 88E
 	if( ! pDM_Odm->RFCalibrateInfo.TxPowerTrackControl || pHalData->EEPROMThermalMeter == 0 || 
 		pHalData->EEPROMThermalMeter == 0xFF)
         return;
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_sdio.c linux/3rdparty/rtl8723bs/hal/hal_sdio.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_sdio.c	2015-05-10 14:36:05.703668291 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_sdio.c	2015-05-07 17:46:55.000000000 +0300
@@ -49,7 +49,7 @@ void rtw_hal_sdio_update_tx_freepage(_ad
 	u8	RequiredPublicFreePgNum = 0;
 	//_irqL irql;
 
-	//_enter_critical_bh(&pHalData->SdioTxFIFOFreePageLock, &irql);
+	//spin_lock_bh(&pHalData->SdioTxFIFOFreePageLock);
 
 	DedicatedPgNum = pHalData->SdioTxFIFOFreePage[PageIdx];
 	if (RequiredPageNum <= DedicatedPgNum) {
@@ -60,7 +60,7 @@ void rtw_hal_sdio_update_tx_freepage(_ad
 		pHalData->SdioTxFIFOFreePage[PUBLIC_QUEUE_IDX] -= RequiredPublicFreePgNum;
 	}
 
-	//_exit_critical_bh(&pHalData->SdioTxFIFOFreePageLock, &irql);
+	//spin_unlock_bh(&pHalData->SdioTxFIFOFreePageLock);
 }
 
 void rtw_hal_set_sdio_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ)
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/hal_sdio_led.c linux/3rdparty/rtl8723bs/hal/hal_sdio_led.c
--- linux/3rdparty/rtl8723bs.old/hal/hal_sdio_led.c	2015-05-10 14:36:05.704668302 +0300
+++ linux/3rdparty/rtl8723bs/hal/hal_sdio_led.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,2395 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#include <drv_types.h>
-
-//
-//	Description:
-//		Implementation of LED blinking behavior.
-//		It toggle off LED and schedule corresponding timer if necessary.
-//
-static void
-SwLedBlink(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter			*padapter = pLed->padapter;
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	// Determine if we shall change LED state again.
-	pLed->BlinkTimes--;
-	switch(pLed->CurrLedState)
-	{
-
-	case LED_BLINK_NORMAL:
-		if(pLed->BlinkTimes == 0)
-		{
-			bStopBlinking = true;
-		}
-		break;
-
-	case LED_BLINK_StartToBlink:
-		if( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
-		{
-			bStopBlinking = true;
-		}
-		if( check_fwstate(pmlmepriv, _FW_LINKED) &&
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) )
-		{
-			bStopBlinking = true;
-		}
-		else if(pLed->BlinkTimes == 0)
-		{
-			bStopBlinking = true;
-		}
-		break;
-
-	case LED_BLINK_WPS:
-		if( pLed->BlinkTimes == 0 )
-		{
-			bStopBlinking = true;
-		}
-		break;
-
-
-	default:
-		bStopBlinking = true;
-		break;
-
-	}
-
-	if(bStopBlinking)
-	{
-		if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-		{
-			SwLedOff(padapter, pLed);
-		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
-		{
-			SwLedOn(padapter, pLed);
-		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== false) &&  pLed->bLedOn == true)
-		{
-			SwLedOff(padapter, pLed);
-		}
-
-		pLed->BlinkTimes = 0;
-		pLed->bLedBlinkInProgress = false;
-	}
-	else
-	{
-		// Assign LED state to toggle.
-		if( pLed->BlinkingLedState == RTW_LED_ON )
-			pLed->BlinkingLedState = RTW_LED_OFF;
-		else
-			pLed->BlinkingLedState = RTW_LED_ON;
-
-		// Schedule a timer to toggle LED state.
-		switch( pLed->CurrLedState )
-		{
-		case LED_BLINK_NORMAL:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-			break;
-
-		case LED_BLINK_SLOWLY:
-		case LED_BLINK_StartToBlink:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-			break;
-
-		case LED_BLINK_WPS:
-			{
-				if( pLed->BlinkingLedState == RTW_LED_ON )
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
-				else
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
-			}
-			break;
-
-		default:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-			break;
-		}
-	}
-}
-
-static void
-SwLedBlink1(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter				*padapter = pLed->padapter;
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	struct led_priv		*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	PLED_SDIO 			pLed1 = &(ledpriv->SwLed1);
-	u8					bStopBlinking = false;
-	
-	if(pEEPROM->CustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-
-	if(pEEPROM->CustomerID == RT_CID_DEFAULT)
-	{
-		if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-		{
-			if(!pLed1->bSWLedCtrl)
-			{
-				SwLedOn(padapter, pLed1);
-				pLed1->bSWLedCtrl = true;
-			}
-			else if(!pLed1->bLedOn)
-				SwLedOn(padapter, pLed1);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
-		}
-		else
-		{
-			if(!pLed1->bSWLedCtrl)
-			{
-				SwLedOff(padapter, pLed1);
-				pLed1->bSWLedCtrl = true;
-			}
-			else if(pLed1->bLedOn)
-				SwLedOff(padapter, pLed1);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));
-		}
-	}
-
-	switch(pLed->CurrLedState)
-	{
-		case LED_BLINK_SLOWLY:
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			break;
-
-		case LED_BLINK_NORMAL:
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-			break;
-
-		case LED_BLINK_SCAN:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_TXRX:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->BlinkTimes = 0;
-				pLed->bLedBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			break;
-
-		case LED_BLINK_WPS_STOP:	//WPS success
-			if(pLed->BlinkingLedState == RTW_LED_ON)
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-				bStopBlinking = false;
-			}
-			else
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-			break;
-
-		default:
-			break;
-	}
-
-}
-
-static void
-SwLedBlink2(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter				*padapter = pLed->padapter;
-	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	u8					bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON)
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	switch(pLed->CurrLedState)
-	{
-		case LED_BLINK_SCAN:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
-
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_TXRX:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
-
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		default:
-			break;
-	}
-
-}
-
-static void
-SwLedBlink3(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter			*padapter = pLed->padapter;
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		if(pLed->CurrLedState != LED_BLINK_WPS_STOP)
-			SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	switch(pLed->CurrLedState)
-	{
-		case LED_BLINK_SCAN:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					if( !pLed->bLedOn )
-						SwLedOn(padapter, pLed);
-
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if( pLed->bLedOn )
-						SwLedOff(padapter, pLed);
-
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-				 	if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_TXRX:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-
-					if( !pLed->bLedOn )
-						SwLedOn(padapter, pLed);
-
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-
-					if( pLed->bLedOn )
-						SwLedOff(padapter, pLed);
-
-
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			break;
-
-		case LED_BLINK_WPS_STOP:	//WPS success
-			if(pLed->BlinkingLedState == RTW_LED_ON)
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-				bStopBlinking = false;
-			}
-			else
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on )
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-				}
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-			break;
-
-
-		default:
-			break;
-	}
-
-}
-
-
-static void
-SwLedBlink4(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter			*padapter = pLed->padapter;
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	PLED_SDIO 		pLed1 = &(ledpriv->SwLed1);
-	u8				bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	if(!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
-	{
-		pLed1->BlinkingLedState = RTW_LED_OFF;
-		pLed1->CurrLedState = RTW_LED_OFF;
-		SwLedOff(padapter, pLed1);
-	}
-
-	switch(pLed->CurrLedState)
-	{
-		case LED_BLINK_SLOWLY:
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			break;
-
-		case LED_BLINK_StartToBlink:
-			if( pLed->bLedOn )
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-			}
-			else
-			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-			}
-			break;
-
-		case LED_BLINK_SCAN:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = false;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					pLed->bLedNoLinkBlinkInProgress = false;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-				}
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_TXRX:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-				}
-				pLed->bLedBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-			}
-			else
-			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-			}
-			break;
-
-		case LED_BLINK_WPS_STOP:	//WPS authentication fail
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-			break;
-
-		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap
-			pLed->BlinkTimes--;
-			if(pLed->BlinkTimes == 0)
-			{
-				if(pLed->bLedOn)
-				{
-					pLed->BlinkTimes = 1;
-				}
-				else
-				{
-					bStopBlinking = true;
-				}
-			}
-
-			if(bStopBlinking)
-			{
-				pLed->BlinkTimes = 10;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-			}
-			else
-			{
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-			}
-			break;
-
-		default:
-			break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
-
-
-}
-
-static void
-SwLedBlink5(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter			*padapter = pLed->padapter;
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	switch(pLed->CurrLedState)
-	{
-		case LED_BLINK_SCAN:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if(pLed->bLedOn)
-						SwLedOff(padapter, pLed);
-				}
-				else
-				{		pLed->CurrLedState = RTW_LED_ON;
-						pLed->BlinkingLedState = RTW_LED_ON;
-						if(!pLed->bLedOn)
-							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-
-		case LED_BLINK_TXRX:
-			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
-			{
-				bStopBlinking = true;
-			}
-
-			if(bStopBlinking)
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if(pLed->bLedOn)
-						SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					if(!pLed->bLedOn)
-						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-
-				pLed->bLedBlinkInProgress = false;
-			}
-			else
-			{
-				if( adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on && adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS)
-				{
-					SwLedOff(padapter, pLed);
-				}
-				else
-				{
-					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
-					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-				}
-			}
-			break;
-
-		default:
-			break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
-
-
-}
-
-static void
-SwLedBlink6(
-	PLED_SDIO			pLed
-	)
-{
-	_adapter			*padapter = pLed->padapter;
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = false;
-
-	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
-	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
-	}
-	else
-	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("<==== blink6\n"));
-}
-
-//
-//	Description:
-//		Handler function of LED Blinking.
-//		We dispatch acture LED blink action according to LedStrategy.
-//
-void BlinkHandler(PLED_SDIO	pLed)
-{
-	_adapter		*padapter = pLed->padapter;
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-
-	//DBG_871X("%s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
-
-	if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))	
-	{
-		//DBG_871X("%s bSurpriseRemoved:%d, bDriverStopped:%d\n", __FUNCTION__, padapter->bSurpriseRemoved, padapter->bDriverStopped);
-		return;
-	}
-
-	switch(ledpriv->LedStrategy)
-	{
-		case SW_LED_MODE0:
-			SwLedBlink(pLed);
-			break;
-		
-		case SW_LED_MODE1:
-			SwLedBlink1(pLed);
-			break;
-		
-		case SW_LED_MODE2:
-			SwLedBlink2(pLed);
-			break;
-			
-		case SW_LED_MODE3:
-			SwLedBlink3(pLed);
-			break;
-
-		case SW_LED_MODE4:
-			SwLedBlink4(pLed);
-			break;			
-
-		case SW_LED_MODE5:
-			SwLedBlink5(pLed);
-			break;
-
-		case SW_LED_MODE6:
-			SwLedBlink6(pLed);
-			break;
-
-		default:
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("BlinkWorkItemCallback 0x%x \n", pHalData->LedStrategy));
-			//SwLedBlink(pLed);
-			break;
-	}
-}
-
-//
-//	Description:
-//		Callback function of LED BlinkTimer, 
-//		it just schedules to corresponding BlinkWorkItem/led_blink_hdl
-//
-void BlinkTimerCallback(void *data)
-{
-	PLED_SDIO	 pLed = (PLED_SDIO)data;
-	_adapter		*padapter = pLed->padapter;
-
-	//DBG_871X("%s\n", __FUNCTION__);
-
-	if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))	
-	{
-		//DBG_871X("%s bSurpriseRemoved:%d, bDriverStopped:%d\n", __FUNCTION__, padapter->bSurpriseRemoved, padapter->bDriverStopped);
-		return;
-	}
-
-	_set_workitem(&(pLed->BlinkWorkItem));
-}
-
-//
-//	Description:
-//		Callback function of LED BlinkWorkItem.
-//		We dispatch acture LED blink action according to LedStrategy.
-//
-void BlinkWorkItemCallback(_workitem *work)
-{
-	PLED_SDIO	 pLed = container_of(work, LED_SDIO, BlinkWorkItem);
-	BlinkHandler(pLed);
-}
-
-static void
-SwLedControlMode0(
-	_adapter		*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	PLED_SDIO	pLed = &(ledpriv->SwLed1);
-
-	// Decide led state
-	switch(LedAction)
-	{
-	case LED_CTL_TX:
-	case LED_CTL_RX:
-		if( pLed->bLedBlinkInProgress == false )
-		{
-			pLed->bLedBlinkInProgress = true;
-
-			pLed->CurrLedState = LED_BLINK_NORMAL;
-			pLed->BlinkTimes = 2;
-
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-		}
-		break;
-
-	case LED_CTL_START_TO_LINK:
-		if( pLed->bLedBlinkInProgress == false )
-		{
-			pLed->bLedBlinkInProgress = true;
-
-			pLed->CurrLedState = LED_BLINK_StartToBlink;
-			pLed->BlinkTimes = 24;
-
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-		}
-		else
-		{
-			pLed->CurrLedState = LED_BLINK_StartToBlink;
-		}
-		break;
-
-	case LED_CTL_LINK:
-		pLed->CurrLedState = RTW_LED_ON;
-		if( pLed->bLedBlinkInProgress == false )
-		{
-			pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), 0);
-		}
-		break;
-
-	case LED_CTL_NO_LINK:
-		pLed->CurrLedState = RTW_LED_OFF;
-		if( pLed->bLedBlinkInProgress == false )
-		{
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			_set_timer(&(pLed->BlinkTimer), 0);
-		}
-		break;
-
-	case LED_CTL_POWER_OFF:
-		pLed->CurrLedState = RTW_LED_OFF;
-		if(pLed->bLedBlinkInProgress)
-		{
-			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = false;
-		}
-		SwLedOff(padapter, pLed);
-		break;
-
-	case LED_CTL_START_WPS:
-		if( pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
-		{
-			pLed->bLedBlinkInProgress = true;
-
-			pLed->CurrLedState = LED_BLINK_WPS;
-			pLed->BlinkTimes = 20;
-
-			if( pLed->bLedOn )
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
-			}
-			else
-			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
-			}
-		}
-		break;
-
-	case LED_CTL_STOP_WPS:
-		if(pLed->bLedBlinkInProgress)
-		{
-			pLed->CurrLedState = RTW_LED_OFF;
-			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = false;
-		}
-		break;
-
-
-	default:
-		break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-
-}
-
- //ALPHA, added by chiyoko, 20090106
-static void
-SwLedControlMode1(
-	_adapter		*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv		*ledpriv = &(padapter->ledpriv);
-	PLED_SDIO			pLed = &(ledpriv->SwLed0);
-	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	
-	if(pEEPROM->CustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
-
-	switch(LedAction)
-	{
-		case LED_CTL_POWER_ON:
-		case LED_CTL_START_TO_LINK:
-		case LED_CTL_NO_LINK:
-			if( pLed->bLedNoLinkBlinkInProgress == false )
-			{
-				if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-				if( pLed->bLedLinkBlinkInProgress == true )
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedLinkBlinkInProgress = false;
-				}
-	 			if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-	 			}
-
-				pLed->bLedNoLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_LINK:
-			if( pLed->bLedLinkBlinkInProgress == false )
-			{
-				if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-				if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-	 			}
-				pLed->bLedLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_NORMAL;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_SITE_SURVEY:
-			 if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
-			 	;
-			 else if(pLed->bLedScanBlinkInProgress ==false)
-			 {
-			 	if(IS_LED_WPS_BLINKING(pLed))
-					return;
-
-	  			if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if( pLed->bLedLinkBlinkInProgress == true )
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = false;
-				}
-	 			if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SCAN;
-				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-
-			 }
-			break;
-
-		case LED_CTL_TX:
-		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==false)
-			{
-				if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-				if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if( pLed->bLedLinkBlinkInProgress == true )
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedLinkBlinkInProgress = false;
-				}
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_TXRX;
-				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
-			 if(pLed->bLedWPSBlinkInProgress ==false)
-			 {
-				if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if( pLed->bLedLinkBlinkInProgress == true )
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = false;
-				}
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				if(pLed->bLedScanBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
-				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			 }
-			break;
-
-
-		case LED_CTL_STOP_WPS:
-			if(pLed->bLedNoLinkBlinkInProgress == true)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
-			}
-			if( pLed->bLedLinkBlinkInProgress == true )
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				 pLed->bLedLinkBlinkInProgress = false;
-			}
-			if(pLed->bLedBlinkInProgress ==true)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if(pLed->bLedScanBlinkInProgress ==true)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-			}
-			else
-			{
-				pLed->bLedWPSBlinkInProgress = true;
-			}
-
-			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if(pLed->bLedOn)
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-			}
-			else
-			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-			break;
-
-		case LED_CTL_STOP_WPS_FAIL:
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			break;
-
-		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			if( pLed->bLedNoLinkBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
-			}
-			if( pLed->bLedLinkBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = false;
-			}
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedWPSBlinkInProgress )
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-
-			SwLedOff(padapter, pLed);
-			break;
-
-		default:
-			break;
-
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-}
-
- //Arcadyan/Sitecom , added by chiyoko, 20090216
-static void
-SwLedControlMode2(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	PLED_SDIO 		pLed = &(ledpriv->SwLed0);
-
-	switch(LedAction)
-	{
-		case LED_CTL_SITE_SURVEY:
-			 if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
-			 	;
-			 else if(pLed->bLedScanBlinkInProgress ==false)
-			 {
-			 	if(IS_LED_WPS_BLINKING(pLed))
-					return;
-
-	 			if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SCAN;
-				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			 }
-			break;
-
-		case LED_CTL_TX:
-		case LED_CTL_RX:
-	 		if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
-	  		{
-	  		  	if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_TXRX;
-				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_LINK:
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-
-			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
-
-		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==false)
-			{
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				if(pLed->bLedScanBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
-				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = RTW_LED_ON;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			 }
-			break;
-
-		case LED_CTL_STOP_WPS:
-			pLed->bLedWPSBlinkInProgress = false;
-			if(adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on)
-			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-			else
-			{
-				pLed->CurrLedState = RTW_LED_ON;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
-				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-			}
-			break;
-
-		case LED_CTL_STOP_WPS_FAIL:
-			pLed->bLedWPSBlinkInProgress = false;
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			_set_timer(&(pLed->BlinkTimer), 0);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-			break;
-
-		case LED_CTL_START_TO_LINK:
-		case LED_CTL_NO_LINK:
-			if(!IS_LED_BLINKING(pLed))
-			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-			break;
-
-		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			if( pLed->bLedWPSBlinkInProgress )
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			SwLedOff(padapter, pLed);
-			break;
-
-		default:
-			break;
-
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-}
-
-  //COREGA, added by chiyoko, 20090316
- static void
- SwLedControlMode3(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	PLED_SDIO		pLed = &(ledpriv->SwLed0);
-
-	switch(LedAction)
-	{
-		case LED_CTL_SITE_SURVEY:
-			if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
-				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
-			{
-				if(IS_LED_WPS_BLINKING(pLed))
-					return;
-
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SCAN;
-				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_TX:
-		case LED_CTL_RX:
-	 		if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
-	  		{
-	  		  	if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_TXRX;
-				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_LINK:
-			if(IS_LED_WPS_BLINKING(pLed))
-				return;
-
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-
-			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
-
-		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==false)
-			{
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				if(pLed->bLedScanBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
-				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_STOP_WPS:
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-			else
-			{
-				pLed->bLedWPSBlinkInProgress = true;
-			}
-
-			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if(pLed->bLedOn)
-			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-			}
-			else
-			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-
-			break;
-
-		case LED_CTL_STOP_WPS_FAIL:
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
-
-		case LED_CTL_START_TO_LINK:
-		case LED_CTL_NO_LINK:
-			if(!IS_LED_BLINKING(pLed))
-			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-			break;
-
-		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			if( pLed->bLedWPSBlinkInProgress )
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			SwLedOff(padapter, pLed);
-			break;
-
-		default:
-			break;
-
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-}
-
-
- //Edimax-Belkin, added by chiyoko, 20090413
-static void
-SwLedControlMode4(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	PLED_SDIO		pLed = &(ledpriv->SwLed0);
-	PLED_SDIO		pLed1 = &(ledpriv->SwLed1);
-
-	switch(LedAction)
-	{
-		case LED_CTL_START_TO_LINK:
-			if(pLed1->bLedWPSBlinkInProgress)
-			{
-				pLed1->bLedWPSBlinkInProgress = false;
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-				pLed1->CurrLedState = RTW_LED_OFF;
-
-				if(pLed1->bLedOn)
-					_set_timer(&(pLed->BlinkTimer), 0);
-			}
-
-			if( pLed->bLedStartToLinkBlinkInProgress == false )
-			{
-				if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-	 			if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-	 			}
-	 			if(pLed->bLedNoLinkBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-	 			}
-
-				pLed->bLedStartToLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_StartToBlink;
-				if( pLed->bLedOn )
-				{
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-				}
-				else
-				{
-					pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-				}
-			}
-			break;
-
-		case LED_CTL_LINK:
-		case LED_CTL_NO_LINK:
-			//LED1 settings
-			if(LedAction == LED_CTL_LINK)
-			{
-				if(pLed1->bLedWPSBlinkInProgress)
-				{
-					pLed1->bLedWPSBlinkInProgress = false;
-					_cancel_timer_ex(&(pLed1->BlinkTimer));
-
-					pLed1->BlinkingLedState = RTW_LED_OFF;
-					pLed1->CurrLedState = RTW_LED_OFF;
-
-					if(pLed1->bLedOn)
-						_set_timer(&(pLed->BlinkTimer), 0);
-				}
-			}
-
-			if( pLed->bLedNoLinkBlinkInProgress == false )
-			{
-				if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-	 			if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-	 			}
-
-				pLed->bLedNoLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
-				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
-			{
-				if(IS_LED_WPS_BLINKING(pLed))
-					return;
-
-				if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SCAN;
-				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_TX:
-		case LED_CTL_RX:
-	 		if(pLed->bLedBlinkInProgress ==false)
-	  		{
-	  		  	if(pLed->CurrLedState == LED_BLINK_SCAN || IS_LED_WPS_BLINKING(pLed))
-				{
-					return;
-				}
-	  		  	if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_TXRX;
-				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
-			if(pLed1->bLedWPSBlinkInProgress)
-			{
-				pLed1->bLedWPSBlinkInProgress = false;
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-				pLed1->CurrLedState = RTW_LED_OFF;
-
-				if(pLed1->bLedOn)
-					_set_timer(&(pLed->BlinkTimer), 0);
-			}
-
-			if(pLed->bLedWPSBlinkInProgress ==false)
-			{
-				if(pLed->bLedNoLinkBlinkInProgress == true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
-				}
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				if(pLed->bLedScanBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
-				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
-				{
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
-				}
-				else
-				{
-					pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-				}
-			}
-			break;
-
-		case LED_CTL_STOP_WPS:	//WPS connect success
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-
-			break;
-
-		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-
-			//LED1 settings
-			if(pLed1->bLedWPSBlinkInProgress)
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-			else
-				pLed1->bLedWPSBlinkInProgress = true;
-
-			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
-			if( pLed1->bLedOn )
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed1->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-
-			break;
-
-		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap
-			if(pLed->bLedWPSBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-
-			//LED1 settings
-			if(pLed1->bLedWPSBlinkInProgress)
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-			else
-				pLed1->bLedWPSBlinkInProgress = true;
-
-			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
-			pLed1->BlinkTimes = 10;
-			if( pLed1->bLedOn )
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-			else
-				pLed1->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-
-			break;
-
-		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-
-			if( pLed->bLedNoLinkBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
-			}
-			if( pLed->bLedLinkBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = false;
-			}
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-			if( pLed->bLedWPSBlinkInProgress )
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
-			}
-			if( pLed->bLedScanBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
-			}
-			if( pLed->bLedStartToLinkBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedStartToLinkBlinkInProgress = false;
-			}
-
-			if( pLed1->bLedWPSBlinkInProgress )
-			{
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-				pLed1->bLedWPSBlinkInProgress = false;
-			}
-
-			pLed1->BlinkingLedState = LED_UNKNOWN;
-			SwLedOff(padapter, pLed);
-			SwLedOff(padapter, pLed1);
-			break;
-
-		default:
-			break;
-
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-}
-
-
-
- //Sercomm-Belkin, added by chiyoko, 20090415
-static void
-SwLedControlMode5(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	PLED_SDIO		pLed = &(ledpriv->SwLed0);
-
-	if(pEEPROM->CustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
-
-	switch(LedAction)
-	{
-		case LED_CTL_POWER_ON:
-		case LED_CTL_NO_LINK:
-		case LED_CTL_LINK: 	//solid blue
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
-
-			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
-
-		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
-				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
-			{
-				if(pLed->bLedBlinkInProgress ==true)
-				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
-				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SCAN;
-				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_TX:
-		case LED_CTL_RX:
-	 		if(pLed->bLedBlinkInProgress ==false)
-	  		{
-	  		  	if(pLed->CurrLedState == LED_BLINK_SCAN)
-				{
-					return;
-				}
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_TXRX;
-				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
-			}
-			break;
-
-		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-
-			if( pLed->bLedBlinkInProgress)
-			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
-			}
-
-			SwLedOff(padapter, pLed);
-			break;
-
-		default:
-			break;
-
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-}
-
- //WNC-Corega, added by chiyoko, 20090902
-static void
-SwLedControlMode6(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	PLED_SDIO pLed0 = &(ledpriv->SwLed0);
-
-	switch(LedAction)
-	{
-		case LED_CTL_POWER_ON:
-		case LED_CTL_LINK:
-		case LED_CTL_NO_LINK:
-			_cancel_timer_ex(&(pLed0->BlinkTimer));
-			pLed0->CurrLedState = RTW_LED_ON;
-			pLed0->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed0->BlinkTimer), 0);
-			break;
-
-		case LED_CTL_POWER_OFF:
-			SwLedOff(padapter, pLed0);
-			break;
-
-		default:
-			break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("ledcontrol 6 Led %d\n", pLed0->CurrLedState));
-}
-
-void
-LedControlSDIO(
-	_adapter				*padapter,
-	LED_CTL_MODE		LedAction
-	)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-
-       if( (padapter->bSurpriseRemoved == true) ||(padapter->hw_init_completed == false) )
-       {
-             return;
-       }
-
-	if( ledpriv->bRegUseLed == false)
-		return;
-
-	//if(priv->bInHctTest)
-	//	return;
-
-	if( (adapter_to_pwrctl(padapter)->rf_pwrstate != rf_on &&
-		adapter_to_pwrctl(padapter)->rfoff_reason > RF_CHANGE_BY_PS) &&
-		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX ||
-		 LedAction == LED_CTL_SITE_SURVEY ||
-		 LedAction == LED_CTL_LINK ||
-		 LedAction == LED_CTL_NO_LINK ||
-		 LedAction == LED_CTL_POWER_ON) )
-	{
-		return;
-	}
-
-	switch(ledpriv->LedStrategy)
-	{
-		case SW_LED_MODE0:
-			SwLedControlMode0(padapter, LedAction);
-			break;
-
-		case SW_LED_MODE1:
-			SwLedControlMode1(padapter, LedAction);
-			break;
-		case SW_LED_MODE2:
-			SwLedControlMode2(padapter, LedAction);
-                	break;
-
-		case SW_LED_MODE3:
-			SwLedControlMode3(padapter, LedAction);
-			break;
-
-		case SW_LED_MODE4:
-			SwLedControlMode4(padapter, LedAction);
-			break;
-
-		case SW_LED_MODE5:
-			SwLedControlMode5(padapter, LedAction);
-			break;
-
-		case SW_LED_MODE6:
-			SwLedControlMode6(padapter, LedAction);
-			break;
-
-		default:
-			break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
-}
-
-//
-//	Description:
-//		Reset status of LED_871x object.
-//
-void ResetLedStatus(PLED_SDIO pLed) {
-
-	pLed->CurrLedState = RTW_LED_OFF; // Current LED state.
-	pLed->bLedOn = false; // true if LED is ON, false if LED is OFF.
-
-	pLed->bLedBlinkInProgress = false; // true if it is blinking, false o.w..
-	pLed->bLedWPSBlinkInProgress = false;
-	
-	pLed->BlinkTimes = 0; // Number of times to toggle led state for blinking.
-	pLed->BlinkingLedState = LED_UNKNOWN; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
-
-	pLed->bLedNoLinkBlinkInProgress = false;
-	pLed->bLedLinkBlinkInProgress = false;
-	pLed->bLedStartToLinkBlinkInProgress = false;
-	pLed->bLedScanBlinkInProgress = false;
-}
-
- //
-//	Description:
-//		Initialize an LED_871x object.
-//
-void
-InitLed(
-	_adapter			*padapter,
-	PLED_SDIO		pLed,
-	LED_PIN			LedPin
-	)
-{
-	pLed->padapter = padapter;
-	pLed->LedPin = LedPin;
-
-	ResetLedStatus(pLed);
-
-	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
-
-	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
-}
-
-
-//
-//	Description:
-//		DeInitialize an LED_871x object.
-//
-void
-DeInitLed(
-	PLED_SDIO		pLed
-	)
-{
-	_cancel_workitem_sync(&(pLed->BlinkWorkItem));
-	_cancel_timer_ex(&(pLed->BlinkTimer));
-	ResetLedStatus(pLed);
-}
-
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_AntDiv.c linux/3rdparty/rtl8723bs/hal/odm_AntDiv.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_AntDiv.c	2015-05-10 14:36:05.704668302 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_AntDiv.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,79 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-//============================================================
-// include files
-//============================================================
-
-#include "odm_precomp.h"
-
-//======================================================
-// when antenna test utility is on or some testing need to disable antenna diversity
-// call this function to disable all ODM related mechanisms which will switch antenna.
-//======================================================
-void
-ODM_StopAntennaSwitchDm(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-	// disable ODM antenna diversity
-	pDM_Odm->SupportAbility &= ~ODM_BB_ANT_DIV;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("STOP Antenna Diversity \n"));
-}
-
-void
-ODM_SetAntConfig(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
-	)
-{
-	if(antSetting == 0)		// ant A
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
-	else if(antSetting == 1)
-		ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
-}
-
-//======================================================
-
-
-void
-ODM_SwAntDivRestAfterLink(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
-	u4Byte             i;
-
-	pDM_Odm->RSSI_test = false;
-	pDM_SWAT_Table->try_flag = 0xff;
-	pDM_SWAT_Table->RSSI_Trying = 0;
-	pDM_SWAT_Table->Double_chk_flag= 0;
-	
-	pDM_FatTable->RxIdleAnt=MAIN_ANT;
-	
-	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		pDM_FatTable->MainAnt_Sum[i] = 0;
-		pDM_FatTable->AuxAnt_Sum[i] = 0;
-		pDM_FatTable->MainAnt_Cnt[i] = 0;
-		pDM_FatTable->AuxAnt_Cnt[i] = 0;
-	}
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_AntDiv.h linux/3rdparty/rtl8723bs/hal/odm_AntDiv.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_AntDiv.h	2015-05-10 14:36:05.704668302 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_AntDiv.h	2015-05-07 17:46:55.000000000 +0300
@@ -40,14 +40,4 @@
 #define CANCEL_ANTDIV_TIMMER 1
 #define RELEASE_ANTDIV_TIMMER 2
 
-void
-ODM_StopAntennaSwitchDm(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-void
-ODM_SetAntConfig(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
-	);
-
 #endif //#ifndef	__ODMANTDIV_H__
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm.c linux/3rdparty/rtl8723bs/hal/odm.c
--- linux/3rdparty/rtl8723bs.old/hal/odm.c	2015-05-10 14:36:05.705668313 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm.c	2015-05-07 17:46:55.000000000 +0300
@@ -336,15 +336,6 @@ odm_CmnInfoInit_Debug(
 	);
 
 void
-odm_CmnInfoHook_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-void
-odm_CmnInfoUpdate_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-void
 odm_BasicDbgMessage
 (
 	IN		PDM_ODM_T		pDM_Odm
@@ -363,20 +354,10 @@ odm_BasicDbgMessage
 //END---------BB POWER SAVE-----------------------//
 
 void
-odm_RefreshRateAdaptiveMaskMP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-void
 odm_RefreshRateAdaptiveMaskCE(
 	IN		PDM_ODM_T		pDM_Odm
 	);
 
-void
-odm_RefreshRateAdaptiveMaskAPADSL(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
 //Remove by YuChen
 
 void
@@ -384,21 +365,10 @@ odm_RSSIMonitorInit(
 	IN	PDM_ODM_T	pDM_Odm
 	);
 
-void
-odm_RSSIMonitorCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
 void 
 odm_RSSIMonitorCheckCE(
 	IN		PDM_ODM_T		pDM_Odm
 	);
-void 
-odm_RSSIMonitorCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
 
 void
 odm_RSSIMonitorCheck(
@@ -410,17 +380,6 @@ odm_SwAntDetectInit(
 	IN 		PDM_ODM_T 		pDM_Odm
 	);
 
-void
-odm_AntennaDiversityInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-void
-odm_AntennaDiversity(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
 void odm_SwAntDivChkAntSwitchCallback(void *FunctionContext);
 
 
@@ -431,11 +390,6 @@ odm_GlobalAdapterCheck(
 	);
 
 void
-odm_RefreshBasicRateMask(
-	IN		PDM_ODM_T		pDM_Odm	
-	);
-
-void
 odm_RefreshRateAdaptiveMask(
 	IN		PDM_ODM_T		pDM_Odm
 	);
@@ -446,11 +400,6 @@ ODM_TXPowerTrackingCheck(
 	);
 
 void
-odm_TXPowerTrackingCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-void
 odm_RateAdaptiveMaskInit(
 	IN	PDM_ODM_T	pDM_Odm
 	);
@@ -467,12 +416,6 @@ odm_TXPowerTrackingInit(
 	);
 
 void
-odm_TXPowerTrackingCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-
-void
 odm_TXPowerTrackingCheckCE(
 	IN	PDM_ODM_T	pDM_Odm
 	);
@@ -536,7 +479,6 @@ ODM_DMInit(
 	ODM_EdcaTurboInit(pDM_Odm);
 	odm_RSSIMonitorInit(pDM_Odm);
 	odm_TXPowerTrackingInit(pDM_Odm);
-	odm_AntennaDiversityInit(pDM_Odm);
 
 	ODM_ClearTxPowerTrackingState(pDM_Odm);
 
@@ -549,13 +491,6 @@ ODM_DMInit(
 	odm_SwAntDetectInit(pDM_Odm);
 }
 
-void
-ODM_DMReset(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-}
-
 //
 // 2011/09/20 MH This is the entry pointer for all team to execute HW out source DM.
 // You can not add any dummy function here, be care, you can only use DM structure
@@ -605,11 +540,9 @@ ODM_DMWatchdog(
 
 	
 	odm_RefreshRateAdaptiveMask(pDM_Odm);
-	odm_RefreshBasicRateMask(pDM_Odm);
 	odm_EdcaTurboCheck(pDM_Odm);
 	odm_PathDiversity(pDM_Odm);
 	ODM_CfoTracking(pDM_Odm);
-	odm_AntennaDiversity(pDM_Odm);
 
 	ODM_TXPowerTrackingCheck(pDM_Odm);
 
@@ -1035,8 +968,8 @@ odm_CommonInfoSelfInit(
 	)
 {
 	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
-	pDM_Odm->bCckHighPower = (bool) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));		
-	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
+	pDM_Odm->bCckHighPower = (bool) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));
+	pDM_Odm->RFPathRxEnable = (u1Byte) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
 
 	ODM_InitDebugSetting(pDM_Odm);
 
@@ -1099,36 +1032,6 @@ odm_CmnInfoInit_Debug(
 }
 
 void
-odm_CmnInfoHook_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoHook_Debug==>\n"));	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumTxBytesUnicast=%llu\n",*(pDM_Odm->pNumTxBytesUnicast)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumRxBytesUnicast=%llu\n",*(pDM_Odm->pNumRxBytesUnicast)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pWirelessMode=0x%x\n",*(pDM_Odm->pWirelessMode)) );	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecChOffset=%d\n",*(pDM_Odm->pSecChOffset)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecurity=%d\n",*(pDM_Odm->pSecurity)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pBandWidth=%d\n",*(pDM_Odm->pBandWidth)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pChannel=%d\n",*(pDM_Odm->pChannel)) );
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbScanInProcess=%d\n",*(pDM_Odm->pbScanInProcess)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbPowerSaving=%d\n",*(pDM_Odm->pbPowerSaving)) );
-}
-
-void
-odm_CmnInfoUpdate_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoUpdate_Debug==>\n"));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Direct=%d\n",pDM_Odm->bWIFI_Direct) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Display=%d\n",pDM_Odm->bWIFI_Display) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked=%d\n",pDM_Odm->bLinked) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI_Min=%d\n",pDM_Odm->RSSI_Min) );
-}
-
-void
 odm_BasicDbgMessage
 (
 	IN		PDM_ODM_T		pDM_Odm
@@ -1387,13 +1290,6 @@ u4Byte ODM_Get_Rate_Bitmap(
 	
 }	
 
-void
-odm_RefreshBasicRateMask(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-}
-
 /*-----------------------------------------------------------------------------
  * Function:	odm_RefreshRateAdaptiveMask()
  *
@@ -1426,14 +1322,6 @@ odm_RefreshRateAdaptiveMask(
 }
 
 void
-odm_RefreshRateAdaptiveMaskMP(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-}
-
-
-void
 odm_RefreshRateAdaptiveMaskCE(
 	IN		PDM_ODM_T		pDM_Odm	
 	)
@@ -1475,13 +1363,6 @@ odm_RefreshRateAdaptiveMaskCE(
 	}			
 }
 
-void
-odm_RefreshRateAdaptiveMaskAPADSL(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-}
-
 // Return Value: bool
 // - true: RATRState is changed.
 bool 
@@ -1576,14 +1457,6 @@ odm_RSSIMonitorCheck(
 
 }	// odm_RSSIMonitorCheck
 
-
-void
-odm_RSSIMonitorCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-}
-
 static void
 FindMinimumRSSI(
 IN	PADAPTER	pAdapter
@@ -1697,38 +1570,6 @@ odm_RSSIMonitorCheckCE(
 	//ODM_CmnInfoUpdate(&pHalData->odmpriv ,ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM);
 }
 
-void
-odm_RSSIMonitorCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-}
-
-
-
-void
-ODM_InitAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-}
-
-void
-ODM_CancelAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-}
-
-
-void
-ODM_ReleaseAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-}
-
-
 //3============================================================
 //3 Tx Power Tracking
 //3============================================================
@@ -1842,7 +1683,7 @@ odm_TXPowerTrackingCheckCE(
 	if(!pDM_Odm->RFCalibrateInfo.TM_Trigger)		//at least delay 1 sec
 	{
 		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
-		ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);
+		PHY_SetRFReg(pDM_Odm->Adapter, ODM_RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);
 
 		//DBG_871X("Trigger Thermal Meter!!\n");
 		
@@ -1857,526 +1698,17 @@ odm_TXPowerTrackingCheckCE(
 	}
 }
 
-void
-odm_TXPowerTrackingCheckMP(
-	IN		PDM_ODM_T		pDM_Odm 
-	)
-{
-}
-
-
-void
-odm_TXPowerTrackingCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-}
-
 //3============================================================
 //3 SW Antenna Diversity
 //3============================================================
 void
-odm_AntennaDiversityInit(
-	IN 		PDM_ODM_T		pDM_Odm 
-)
-{
-	if(*(pDM_Odm->mp_mode) == true)
-		return;
-}
-
-void
-odm_AntennaDiversity(
-	IN 		PDM_ODM_T		pDM_Odm 
-)
-{
-	if(*(pDM_Odm->mp_mode) == true)
-		return;
-}
-
-
-void
 odm_SwAntDetectInit(
 	IN		PDM_ODM_T		pDM_Odm
 	)
 {
 	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ODM_Read4Byte(pDM_Odm, rDPDT_control);
+	pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = rtw_read32(pDM_Odm->Adapter, rDPDT_control);
 	pDM_SWAT_Table->PreAntenna = MAIN_ANT;
 	pDM_SWAT_Table->CurAntenna = MAIN_ANT;
 	pDM_SWAT_Table->SWAS_NoLink_State = 0;
 }
-
-//============================================================
-//EDCA Turbo
-//============================================================
-
-// need to ODM CE Platform
-//move to here for ANT detection mechanism using
-
-u4Byte
-GetPSDData(
-	IN PDM_ODM_T	pDM_Odm,
-	unsigned int 	point,
-	u1Byte initial_gain_psd)
-{
-	//unsigned int	val, rfval;
-	//int	psd_report;
-	u4Byte	psd_report;
-	
-	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	//Debug Message
-	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
-	//DbgPrint("Reg908 = 0x%x\n",val);
-	//val = PHY_QueryBBReg(Adapter,0xDF4, bMaskDWord);
-	//rfval = PHY_QueryRFReg(Adapter, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
-	//DbgPrint("RegDF4 = 0x%x, RFReg00 = 0x%x\n",val, rfval);
-	//DbgPrint("PHYTXON = %x, OFDMCCA_PP = %x, CCKCCA_PP = %x, RFReg00 = %x\n",
-		//(val&BIT25)>>25, (val&BIT14)>>14, (val&BIT15)>>15, rfval);
-
-	//Set DCO frequency index, offset=(40MHz/SamplePts)*point
-	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
-
-	//Start PSD calculation, Reg808[22]=0->1
-	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);
-	//Need to wait for HW PSD report
-	udelay(1000);
-	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
-	//Read PSD report, Reg8B4[15:0]
-	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
-	
-	psd_report = (u4Byte) (ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
-
-	return psd_report;
-	
-}
-
-u4Byte 
-ConvertTo_dB(
-	u4Byte 	Value)
-{
-	u1Byte i;
-	u1Byte j;
-	u4Byte dB;
-
-	Value = Value & 0xFFFF;
-	
-	for (i=0;i<8;i++)
-	{
-		if (Value <= dB_Invert_Table[i][11])
-		{
-			break;
-		}
-	}
-
-	if (i >= 8)
-	{
-		return (96);	// maximum 96 dB
-	}
-
-	for (j=0;j<12;j++)
-	{
-		if (Value <= dB_Invert_Table[i][j])
-		{
-			break;
-		}
-	}
-
-	dB = i*12 + j + 1;
-
-	return (dB);
-}
-
-//
-// Description:
-//	Set Single/Dual Antenna default setting for products that do not do detection in advance.
-//
-// Added by Joseph, 2012.03.22
-//
-void
-ODM_SingleDualAntennaDefaultSetting(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-	u1Byte btAntNum = 2;
-
-	btAntNum = hal_btcoex_GetPgAntNum(pAdapter);
-
-	// Set default antenna A and B status
-	if(btAntNum == 2)
-	{
-		pDM_SWAT_Table->ANTA_ON=true;
-		pDM_SWAT_Table->ANTB_ON=true;
-		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Dual antenna\n"));
-	}
-	else if(btAntNum == 1)
-	{// Set antenna A as default
-		pDM_SWAT_Table->ANTA_ON=true;
-		pDM_SWAT_Table->ANTB_ON=false;
-		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Single antenna\n"));
-	}
-	else
-	{
-		//RT_ASSERT(false, ("Incorrect antenna number!!\n"));
-	}
-}
-
-
-
-//2 8723A ANT DETECT
-//
-// Description:
-//	Implement IQK single tone for RF DPK loopback and BB PSD scanning. 
-//	This function is cooperated with BB team Neil. 
-//
-// Added by Roger, 2011.12.15
-//
-bool
-ODM_SingleDualAntennaDetection(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			mode
-	)
-{
-	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	u4Byte		CurrentChannel,RfLoopReg;
-	u1Byte		n;
-	u4Byte		Reg88c, Regc08, Reg874, Regc50, Reg948=0, Regb2c=0, Reg92c=0, AFE_rRx_Wait_CCA=0;
-	u1Byte		initial_gain = 0x5a;
-	u4Byte		PSD_report_tmp;
-	u4Byte		AntA_report = 0x0, AntB_report = 0x0,AntO_report=0x0;
-	bool		bResult = true;
-	u4Byte		AFE_Backup[16];
-	u4Byte		AFE_REG_8723A[16] = {
-					rRx_Wait_CCA, 	rTx_CCK_RFON, 
-					rTx_CCK_BBON, 	rTx_OFDM_RFON,
-					rTx_OFDM_BBON, 	rTx_To_Rx,
-					rTx_To_Tx, 		rRx_CCK, 
-					rRx_OFDM, 		rRx_Wait_RIFS, 
-					rRx_TO_Rx,		rStandby,
-					rSleep,			rPMPD_ANAEN, 	
-					rFPGA0_XCD_SwitchControl, rBlue_Tooth};
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection()============> \n"));	
-
-	
-	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
-	if(!IS_ANT_DETECT_SUPPORT_SINGLE_TONE(pAdapter))
-		return bResult;
-
-	//1 Backup Current RF/BB Settings	
-	
-	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
-	RfLoopReg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
-
-	Reg92c = ODM_GetBBReg(pDM_Odm, 0x92c, bMaskDWord);
-	Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
-	Regb2c = ODM_GetBBReg(pDM_Odm, AGC_table_select, bMaskDWord);
-	ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x1);
-	ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, 0xff, 0x77);
-	ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0x3ff, 0x000);
-	ODM_SetBBReg(pDM_Odm, AGC_table_select, BIT31, 0x0);
-
-	udelay(10);
-	
-	//Store A Path Register 88c, c08, 874, c50
-	Reg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);
-	Regc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);
-	Reg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);
-	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);	
-	
-	// Store AFE Registers
-	AFE_rRx_Wait_CCA = ODM_GetBBReg(pDM_Odm, rRx_Wait_CCA,bMaskDWord);
-	
-	//Set PSD 128 pts
-	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pts
-	
-	// To SET CH1 to do
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x7401);     //Channel 1
-	
-	// AFE all on step
-	ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x01c00016);
-
-	// 3 wire Disable
-	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);
-	
-	//BB IQK Setting
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-
-	//IQK setting tone@ 4.34Mhz
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);	
-
-	//Page B init
-	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);
-	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);	
-
-	//IQK Single tone start
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
-	
-	udelay(10000);
-
-	// PSD report of antenna A
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp >AntA_report)
-			AntA_report=PSD_report_tmp;
-	}
-
-	 // change to Antenna B
-	ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x2);
-
-	udelay(10);	
-
-	// PSD report of antenna B
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp > AntB_report)
-			AntB_report=PSD_report_tmp;
-	}
-
-	// change to open case
-	ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x0);
-
-	udelay(10);	
-	
-	// PSD report of open case
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp > AntO_report)
-			AntO_report=PSD_report_tmp;
-	}
-
-	//Close IQK Single Tone function
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
-
-	// external DPDT
-	ODM_SetBBReg(pDM_Odm, rDPDT_control, bMaskDWord, Reg92c);
-
-	//internal S0/S1
-	ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
-	ODM_SetBBReg(pDM_Odm, AGC_table_select, bMaskDWord, Regb2c);
-
-	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,CurrentChannel);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask,RfLoopReg);
-
-	//Reload AFE Registers
-	ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, AFE_rRx_Wait_CCA);
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
-	
-	//2 Test Ant B based on Ant A is ON
-	if(mode==ANTTESTB)
-	{
-		if(AntA_report >=100 && AntA_report <= 116)
-		{
-			if(AntB_report >= (AntA_report+4) && AntB_report > 116)
-			{
-				pDM_SWAT_Table->ANTB_ON=false;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
-			}	
-			else if(AntB_report >=100 && AntB_report <= 116)
-			{
-				pDM_SWAT_Table->ANTB_ON=true;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
-			}
-			else
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-				pDM_SWAT_Table->ANTB_ON=false; // Set Antenna B off as default 
-				bResult = false;
-			}
-		}
-		else
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-			pDM_SWAT_Table->ANTB_ON=false; // Set Antenna B off as default 
-			bResult = false;
-		}
-	}	
-	//2 Test Ant A and B based on DPDT Open
-	else if(mode==ANTTESTALL)
-	{
-		if((AntA_report >= 100) && (AntB_report >= 100) && (AntA_report <= 120) && (AntB_report <= 120))
-		{
-			if((AntA_report - AntB_report < 2) || (AntB_report - AntA_report < 2))
-			{
-				pDM_SWAT_Table->ANTA_ON=true;
-				pDM_SWAT_Table->ANTB_ON=true;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));
-			}
-			else if(((AntA_report - AntB_report >= 2) && (AntA_report - AntB_report <= 4)) || 
-				((AntB_report - AntA_report >= 2) && (AntB_report - AntA_report <= 4)))
-			{
-				pDM_SWAT_Table->ANTA_ON=false;
-				pDM_SWAT_Table->ANTB_ON=false;
-				bResult = false;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-			}
-			else
-			{
-				pDM_SWAT_Table->ANTA_ON = true;
-				pDM_SWAT_Table->ANTB_ON=false;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
-			}
-			
-			pDM_Odm->AntDetectedInfo.bAntDetected= true;
-			pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
-			pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
-			pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
-			
-		}
-		else
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return false!!\n"));
-			bResult = false;
-		}
-	}
-
-	return bResult;
-
-}
-
-static void
-odm_Set_RA_DM_ARFB_by_Noisy(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	//DbgPrint("DM_ARFB ====> \n");
-	if (pDM_Odm->bNoisyState){
-		ODM_Write4Byte(pDM_Odm,0x430,0x00000000);
-		ODM_Write4Byte(pDM_Odm,0x434,0x05040200);
-		//DbgPrint("DM_ARFB ====> Noisy State\n");
-	}
-	else{
-		ODM_Write4Byte(pDM_Odm,0x430,0x02010000);
-		ODM_Write4Byte(pDM_Odm,0x434,0x07050403);
-		//DbgPrint("DM_ARFB ====> Clean State\n");
-	}
-	
-}
-
-void
-ODM_UpdateNoisyState(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN 	bool 	bNoisyStateFromC2H
-	)
-{
-	//DbgPrint("Get C2H Command! NoisyState=0x%x\n ", bNoisyStateFromC2H);
-	pDM_Odm->bNoisyState = bNoisyStateFromC2H;
-	odm_Set_RA_DM_ARFB_by_Noisy(pDM_Odm);
-};
-
-u4Byte
-Set_RA_DM_Ratrbitmap_by_Noisy(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u4Byte			ratr_bitmap,
-	IN	u1Byte			rssi_level
-)
-{
-	u4Byte ret_bitmap = ratr_bitmap;
-	switch (WirelessMode)
-	{
-		case WIRELESS_MODE_AC_24G :
-		case WIRELESS_MODE_AC_5G :
-		case WIRELESS_MODE_AC_ONLY:
-			if (pDM_Odm->bNoisyState){ // in Noisy State
-				if (rssi_level==1)
-					ret_bitmap&=0xfe3f0e08;
-				else if (rssi_level==2)
-					ret_bitmap&=0xff3f8f8c;
-				else if (rssi_level==3)
-					ret_bitmap&=0xffffffcc ;
-				else
-					ret_bitmap&=0xffffffff ;
-			}
-			else{                                   // in SNR State
-				if (rssi_level==1){
-					ret_bitmap&=0xfc3e0c08;
-				}
-				else if (rssi_level==2){
-					ret_bitmap&=0xfe3f0e08;
-				}
-				else if (rssi_level==3){
-					ret_bitmap&=0xffbfefcc;
-				}
-				else{
-					ret_bitmap&=0x0fffffff;
-				}
-			}
-			break;
-		case WIRELESS_MODE_B:
-		case WIRELESS_MODE_A:
-		case WIRELESS_MODE_G:
-		case WIRELESS_MODE_N_24G:
-		case WIRELESS_MODE_N_5G:
-			if (pDM_Odm->bNoisyState){
-				if (rssi_level==1)
-					ret_bitmap&=0x0f0e0c08;
-				else if (rssi_level==2)
-					ret_bitmap&=0x0f8f0e0c;
-				else if (rssi_level==3)
-					ret_bitmap&=0x0fefefcc ;
-				else
-					ret_bitmap&=0xffffffff ;
-			}
-			else{
-				if (rssi_level==1){
-					ret_bitmap&=0x0f8f0e08;
-				}
-				else if (rssi_level==2){
-					ret_bitmap&=0x0fcf8f8c;
-				}
-				else if (rssi_level==3){
-					ret_bitmap&=0x0fffffcc;
-				}
-				else{
-					ret_bitmap&=0x0fffffff;
-				}
-			}
-			break;
-		default:
-			break;
-	}
-	//DbgPrint("DM_RAMask ====> rssi_LV = %d, BITMAP = %x \n", rssi_level, ret_bitmap);
-	return ret_bitmap;
-
-}
-
-
-
-void
-ODM_UpdateInitRate(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		Rate
-	)
-{
-	u1Byte			p = 0;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Get C2H Command! Rate=0x%x\n", Rate));
-	
-	pDM_Odm->TxRate = Rate;
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_CfoTracking.c linux/3rdparty/rtl8723bs/hal/odm_CfoTracking.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_CfoTracking.c	2015-05-10 14:36:05.705668313 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_CfoTracking.c	2015-05-07 17:46:55.000000000 +0300
@@ -41,7 +41,7 @@ odm_SetCrystalCap(
 
 	// 0x2C[23:18] = 0x2C[17:12] = CrystalCap
 	CrystalCap = CrystalCap & 0x3F;
-	ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x00FFF000, (CrystalCap | (CrystalCap << 6)));	
+	PHY_SetBBReg(pDM_Odm->Adapter, REG_MAC_PHY_CTRL, 0x00FFF000, (CrystalCap | (CrystalCap << 6)));
 
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("odm_SetCrystalCap(): CrystalCap = 0x%x\n", CrystalCap));
 }
@@ -76,7 +76,7 @@ odm_SetATCStatus(
 	if(pCfoTrack->bATCStatus == ATCStatus)
 		return;
 	
-	ODM_SetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm), ATCStatus);
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm), ATCStatus);
 	pCfoTrack->bATCStatus = ATCStatus;
 }
 
@@ -88,7 +88,7 @@ odm_GetATCStatus(
 	bool						ATCStatus;
 	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	ATCStatus = (bool)ODM_GetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm));
+	ATCStatus = (bool)PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm));
 	return ATCStatus;
 }
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DIG.c linux/3rdparty/rtl8723bs/hal/odm_DIG.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_DIG.c	2015-05-10 14:36:05.706668324 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DIG.c	2015-05-07 17:46:55.000000000 +0300
@@ -27,52 +27,6 @@
 
 
 void
-ODM_ChangeDynamicInitGainThresh(
-	IN	void *		pDM_VOID,
-	IN	u4Byte		DM_Type,
-	IN	u4Byte		DM_Value
-	)
-{
-	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
-
-	if (DM_Type == DIG_TYPE_THRESH_HIGH)
-	{
-		pDM_DigTable->RssiHighThresh = DM_Value;		
-	}
-	else if (DM_Type == DIG_TYPE_THRESH_LOW)
-	{
-		pDM_DigTable->RssiLowThresh = DM_Value;
-	}
-	else if (DM_Type == DIG_TYPE_ENABLE)
-	{
-		pDM_DigTable->Dig_Enable_Flag	= true;
-	}	
-	else if (DM_Type == DIG_TYPE_DISABLE)
-	{
-		pDM_DigTable->Dig_Enable_Flag = false;
-	}	
-	else if (DM_Type == DIG_TYPE_BACKOFF)
-	{
-		if(DM_Value > 30)
-			DM_Value = 30;
-		pDM_DigTable->BackoffVal = (u1Byte)DM_Value;
-	}
-	else if(DM_Type == DIG_TYPE_RX_GAIN_MIN)
-	{
-		if(DM_Value == 0)
-			DM_Value = 0x1;
-		pDM_DigTable->rx_gain_range_min = (u1Byte)DM_Value;
-	}
-	else if(DM_Type == DIG_TYPE_RX_GAIN_MAX)
-	{
-		if(DM_Value > 0x50)
-			DM_Value = 0x50;
-		pDM_DigTable->rx_gain_range_max = (u1Byte)DM_Value;
-	}
-}	// DM_ChangeDynamicInitGainThresh //
-
-void
 odm_NHMCounterStatisticsInit(
 	IN		void *			pDM_VOID
 	)
@@ -80,15 +34,15 @@ odm_NHMCounterStatisticsInit(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
 	//PHY parameters initialize for n series
-	ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0x2710);	//0x894[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
-	//ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0x4e20);	//0x894[31:16]=0x4e20	Time duration for NHM unit: 4us, 0x4e20=80ms
-	ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);	//0x890[31:16]=0xffff	th_9, th_10
-	//ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff5c);	//0x898=0xffffff5c 		th_3, th_2, th_1, th_0
-	ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff52);	//0x898=0xffffff52 		th_3, th_2, th_1, th_0
-	ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);	//0x89c=0xffffffff		th_7, th_6, th_5, th_4
-	ODM_SetBBReg(pDM_Odm, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		//0xe28[7:0]=0xff		th_8
-	ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 0x7);	//0x890[9:8]=3			enable CCX
-	ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);		//0xc0c[7]=1			max power among all RX ants				
+	rtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TIMER_11N+2, 0x2710);	//0x894[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+	//rtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TIMER_11N+2, 0x4e20);	//0x894[31:16]=0x4e20	Time duration for NHM unit: 4us, 0x4e20=80ms
+	rtw_write16(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);	//0x890[31:16]=0xffff	th_9, th_10
+	//rtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff5c);	//0x898=0xffffff5c 		th_3, th_2, th_1, th_0
+	rtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff52);	//0x898=0xffffff52 		th_3, th_2, th_1, th_0
+	rtw_write32(pDM_Odm->Adapter, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);	//0x89c=0xffffffff		th_7, th_6, th_5, th_4
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		//0xe28[7:0]=0xff		th_8
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 0x7);	//0x890[9:8]=3			enable CCX
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);		//0xc0c[7]=1			max power among all RX ants
 }
 
 void
@@ -113,7 +67,7 @@ odm_GetNHMCounterStatistics(
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	u4Byte		value32 = 0;
 
-	value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11N, bMaskDWord);
+	value32 = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_NHM_CNT_11N, bMaskDWord);
 
 	pDM_Odm->NHM_cnt_0 = (u1Byte)(value32 & bMaskByte0);
 }
@@ -125,8 +79,8 @@ odm_NHMCounterStatisticsReset(
 {
 	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
 
-	ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
-	ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
 }
 
 void
@@ -170,8 +124,6 @@ odm_NHMBB(
 			//Enable EDCCA since it is possible running Adaptivity testing
 			//test_status = 1;
             		pDM_Odm->adaptivity_flag = true;
-            		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	//don't ignore EDCCA	 reg520[15]=0
-			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);	//reg524[11]=1	
 			pDM_Odm->tolerance_cnt = 0;
             	}
 		else
@@ -184,8 +136,6 @@ odm_NHMBB(
 			if(pDM_Odm->tolerance_cnt > 3)
 			{
 				//test_status = 3;
-				ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	//ignore EDCCA	reg520[15]=1
-            			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);		//reg524[11]=0
             			pDM_Odm->adaptivity_flag = false;
 			}
 		}
@@ -195,8 +145,6 @@ odm_NHMBB(
 		if(pDM_Odm->adaptivity_flag == true && pDM_Odm->NHM_cnt_0 <= 200)
 		{
 			//test_status = 2;
-			ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	//don't ignore EDCCA	 reg520[15]=0
-			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);	//reg524[11]=1	
 			pDM_Odm->tolerance_cnt = 0;
 		}
 		else
@@ -209,8 +157,6 @@ odm_NHMBB(
 			if(pDM_Odm->tolerance_cnt >3)
 			{
 				//test_status = 4;
-				ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	//ignore EDCCA	reg520[15]=1
-            			ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);		//reg524[11]=0
             			pDM_Odm->adaptivity_flag = false;
 			}
 		}
@@ -241,8 +187,8 @@ odm_SearchPwdBLowerBound(
 		if(TH_L2H_dmc > 10) 	
 			TH_L2H_dmc = 10;
 	TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
-	ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
-	ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
+	PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+	PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
 
 	mdelay(5);
 		
@@ -250,7 +196,7 @@ odm_SearchPwdBLowerBound(
 			{
 			for(cnt=0; cnt<20; cnt ++)
 				{
-				value32 = ODM_GetBBReg(pDM_Odm,ODM_REG_RPT_11N, bMaskDWord);
+				value32 = PHY_QueryBBReg(pDM_Odm->Adapter,ODM_REG_RPT_11N, bMaskDWord);
 			
 				if (value32 & BIT30)
 					pDM_Odm->txEdcca1 = pDM_Odm->txEdcca1 + 1;
@@ -268,8 +214,8 @@ odm_SearchPwdBLowerBound(
 						if(TH_L2H_dmc > 10)
 							TH_L2H_dmc = 10;
 					TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
-					ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
-					ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
+					PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+					PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
 
 					pDM_Odm->TxHangFlg = true;
 					pDM_Odm->txEdcca1 = 0;
@@ -332,7 +278,7 @@ odm_AdaptivityInit(
 	pDM_Odm->Adaptivity_IGI_upper = 0;
 	odm_NHMBBInit(pDM_Odm);
 
-	ODM_SetBBReg(pDM_Odm, REG_RD_CTRL, BIT11, 1); // stop counting if EDCCA is asserted
+	PHY_SetBBReg(pDM_Odm->Adapter, REG_RD_CTRL, BIT11, 1); // stop counting if EDCCA is asserted
 }
 
 
@@ -369,14 +315,14 @@ odm_Adaptivity(
 	//Search pwdB lower bound
 	if(pDM_Odm->TxHangFlg == true)
 	{
-		ODM_SetBBReg(pDM_Odm,ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
+		PHY_SetBBReg(pDM_Odm->Adapter,ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
 		odm_SearchPwdBLowerBound(pDM_Odm, pDM_Odm->IGI_target );
 	}
 		
 	if((!pDM_Odm->bLinked)||(*pDM_Odm->pChannel > 149)) // Band4 doesn't need adaptivity
 	{
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
+		PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
+		PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
 		return;
 	}
 
@@ -418,8 +364,8 @@ odm_Adaptivity(
 	}
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
 		IGI, TH_L2H_dmc, TH_H2L_dmc));
-	ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
-	ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
+	PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
+	PHY_SetBBReg(pDM_Odm->Adapter,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
 }
 
 void
@@ -454,10 +400,10 @@ ODM_Write_DIG(
 		}
 
 		//1 Set IGI value
-		ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+		PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
 
 		if(pDM_Odm->RFType > ODM_1T1R)
-			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+			PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
 
 		pDM_DigTable->CurIGValue = CurrentIGI;
 	}
@@ -582,7 +528,7 @@ odm_DIGInit(
 
 	pDM_DigTable->bStopDIG = false;
 	pDM_DigTable->bPSDInProgress = false;
-	pDM_DigTable->CurIGValue = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm));
+	pDM_DigTable->CurIGValue = (u1Byte) PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm));
 	pDM_DigTable->RssiLowThresh 	= DM_DIG_THRESH_LOW;
 	pDM_DigTable->RssiHighThresh 	= DM_DIG_THRESH_HIGH;
 	pDM_DigTable->FALowThresh	= DMfalseALARM_THRESH_LOW;
@@ -925,14 +871,6 @@ odm_DIGbyRSSI_LPS(
 	ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
 }
 
-void
-odm_DigForBtHsMode(
-	IN		void *		pDM_VOID
-	)
-{
-}
-
-
 //3============================================================
 //3 FASLE ALARM CHECK
 //3============================================================
@@ -950,22 +888,22 @@ odm_FalseAlarmCounterStatistics(
 		return;
 
 	//hold ofdm counter
-	ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); //hold page C counter
-	ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); //hold page D counter
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); //hold page C counter
+	PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); //hold page D counter
 
-	ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
+	ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
 	FalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);
 	FalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);		
 
-	ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);
+	ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);
 	FalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff); 
 	FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
 
-	ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);
+	ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);
 	FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
 	FalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
 
-	ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);
+	ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);
 	FalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);
 
 	FalseAlmCnt->Cnt_Ofdm_fail = 	FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +
@@ -974,16 +912,16 @@ odm_FalseAlarmCounterStatistics(
 
 	{
 		//hold cck counter
-		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT12, 1); 
-		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT14, 1); 
+		PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_RST_11N, BIT12, 1);
+		PHY_SetBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_RST_11N, BIT14, 1);
 	
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
+		ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
 		FalseAlmCnt->Cnt_Cck_fail = ret_value;
 
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);
+		ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);
 		FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
 
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);
+		ret_value = PHY_QueryBBReg(pDM_Odm->Adapter, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);
 		FalseAlmCnt->Cnt_CCK_CCA = ((ret_value&0xFF)<<8) |((ret_value&0xFF00)>>8);
 	}
 
@@ -1115,82 +1053,11 @@ odm_ForbiddenIGICheck(
 
 }
 
-void
-odm_InbandNoiseCalculate (	
-	IN		void *		pDM_VOID
-	)
-{
-	return;
-}
-
 //3============================================================
 //3 CCK Packet Detect Threshold
 //3============================================================
 
 void
-odm_PauseCCKPacketDetection(
-	IN		void *					pDM_VOID,
-	IN		ODM_Pause_CCKPD_TYPE	PauseType,
-	IN		u1Byte					CCKPDThreshold
-)
-{
-	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
-	static	bool		bPaused = false;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection()=========>\n"));
-
-	if(!bPaused && (!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD) || !(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Return: SupportAbility ODM_BB_CCK_PD or ODM_BB_FA_CNT is disabled\n"));
-		return;
-	}
-
-	switch(PauseType)
-	{
-		//1 Pause CCK Packet Detection Threshold
-		case ODM_PAUSE_CCKPD:
-			//2 Disable DIG
-			ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility & (~ODM_BB_CCK_PD));
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Pause CCK packet detection threshold !!\n"));
-
-			//2 Backup CCK Packet Detection Threshold value
-			if(!bPaused)
-			{
-				pDM_DigTable->CCKPDBackup = pDM_DigTable->CurCCK_CCAThres;
-				bPaused = true;
-			}
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Backup CCK packet detection tgreshold  = %d\n", pDM_DigTable->CCKPDBackup));
-
-			//2 Write new CCK Packet Detection Threshold value
-			ODM_Write_CCK_CCA_Thres(pDM_Odm, CCKPDThreshold);
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Write new CCK packet detection tgreshold = %d\n", CCKPDThreshold));
-			break;
-			
-		//1 Resume CCK Packet Detection Threshold
-		case ODM_RESUME_CCKPD:
-			if(bPaused)
-			{
-				//2 Write backup CCK Packet Detection Threshold value
-				ODM_Write_CCK_CCA_Thres(pDM_Odm, pDM_DigTable->CCKPDBackup);
-				bPaused = false;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Write original CCK packet detection tgreshold = %d\n", pDM_DigTable->CCKPDBackup));
-
-				//2 Enable CCK Packet Detection Threshold
-				ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility | ODM_BB_CCK_PD);		
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Resume CCK packet detection threshold  !!\n"));
-			}
-			break;
-			
-		default:
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Wrong  type !!\n"));
-			break;
-	}	
-	return;
-}
-
-
-void
 odm_CCKPacketDetectionThresh(
 	IN		void *		pDM_VOID
 	)
@@ -1249,7 +1116,7 @@ ODM_Write_CCK_CCA_Thres(
 
 	if(pDM_DigTable->CurCCK_CCAThres!=CurCCK_CCAThres)		//modify by Guo.Mingzhi 2012-01-03
 	{
-		ODM_Write1Byte(pDM_Odm, ODM_REG(CCK_CCA,pDM_Odm), CurCCK_CCAThres);
+		rtw_write8(pDM_Odm->Adapter, ODM_REG(CCK_CCA,pDM_Odm), CurCCK_CCAThres);
 	}
 	pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
 	pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DIG.h linux/3rdparty/rtl8723bs/hal/odm_DIG.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_DIG.h	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DIG.h	2015-05-07 17:46:55.000000000 +0300
@@ -189,13 +189,6 @@ typedef enum tag_DIG_Connect_Definition
 #define 		RSSI_OFFSET_DIG				0x05
 
 void
-ODM_ChangeDynamicInitGainThresh(
-	IN		void *					pDM_VOID,
-	IN		u4Byte  					DM_Type,
-	IN		u4Byte 					DM_Value
-	);
-
-void
 odm_NHMCounterStatisticsInit(
 	IN		void *					pDM_VOID
 	);
@@ -271,11 +264,6 @@ odm_DIGbyRSSI_LPS(
 	);
 
 void
-odm_DigForBtHsMode(
-	IN		void *					pDM_VOID
-	);
-
-void
 odm_FalseAlarmCounterStatistics(
 	IN		void *					pDM_VOID
 	);
@@ -297,24 +285,12 @@ odm_ForbiddenIGICheck(
 	IN		u1Byte					CurrentIGI
 	);
 
-void
-odm_InbandNoiseCalculate (	
-	IN		void *					pDM_VOID
-	);
-
 bool 
 odm_DigAbort(
 	IN		void *					pDM_VOID
 	);
 
 void
-odm_PauseCCKPacketDetection(
-	IN		void *					pDM_VOID,
-	IN		ODM_Pause_CCKPD_TYPE	PauseType,
-	IN		u1Byte					CCKPDThreshold
-	);
-
-void
 odm_CCKPacketDetectionThresh(
 	IN		void *					pDM_VOID
 	);
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DynamicBBPowerSaving.c linux/3rdparty/rtl8723bs/hal/odm_DynamicBBPowerSaving.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_DynamicBBPowerSaving.c	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DynamicBBPowerSaving.c	2015-05-07 17:46:55.000000000 +0300
@@ -40,61 +40,6 @@ odm_DynamicBBPowerSavingInit(
 	pDM_PSTable->initialize = 0;
 }
 
-
-void
-odm_1R_CCA(
-	IN		void *					pDM_VOID
-	)
-{
-	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
-
-	if(pDM_Odm->RSSI_Min!= 0xFF)
-	{
-		 
-		if(pDM_PSTable->PreCCAState == CCA_2R)
-		{
-			if(pDM_Odm->RSSI_Min >= 35)
-				pDM_PSTable->CurCCAState = CCA_1R;
-			else
-				pDM_PSTable->CurCCAState = CCA_2R;
-			
-		}
-		else{
-			if(pDM_Odm->RSSI_Min <= 30)
-				pDM_PSTable->CurCCAState = CCA_2R;
-			else
-				pDM_PSTable->CurCCAState = CCA_1R;
-		}
-	}
-	else{
-		pDM_PSTable->CurCCAState=CCA_MAX;
-	}
-	
-	if(pDM_PSTable->PreCCAState != pDM_PSTable->CurCCAState)
-	{
-		if(pDM_PSTable->CurCCAState == CCA_1R)
-		{
-			if(  pDM_Odm->RFType ==ODM_2T2R )
-			{
-				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x13);
-				//PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);
-			}
-			else
-			{
-				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x23);
-				//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
-			}
-		}
-		else
-		{
-			ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x33);
-			//PHY_SetBBReg(pAdapter,0xe70, bMaskByte3, 0x63);
-		}
-		pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
-	}
-}
-
 void
 ODM_RF_Saving(
 	IN		void *					pDM_VOID,
@@ -112,10 +57,10 @@ ODM_RF_Saving(
 	}
 	if(pDM_PSTable->initialize == 0){
 		
-		pDM_PSTable->Reg874 = (ODM_GetBBReg(pDM_Odm, 0x874, bMaskDWord)&0x1CC000)>>14;
-		pDM_PSTable->RegC70 = (ODM_GetBBReg(pDM_Odm, 0xc70, bMaskDWord)&BIT3)>>3;
-		pDM_PSTable->Reg85C = (ODM_GetBBReg(pDM_Odm, 0x85c, bMaskDWord)&0xFF000000)>>24;
-		pDM_PSTable->RegA74 = (ODM_GetBBReg(pDM_Odm, 0xa74, bMaskDWord)&0xF000)>>12;
+		pDM_PSTable->Reg874 = (PHY_QueryBBReg(pDM_Odm->Adapter, 0x874, bMaskDWord)&0x1CC000)>>14;
+		pDM_PSTable->RegC70 = (PHY_QueryBBReg(pDM_Odm->Adapter, 0xc70, bMaskDWord)&BIT3)>>3;
+		pDM_PSTable->Reg85C = (PHY_QueryBBReg(pDM_Odm->Adapter, 0x85c, bMaskDWord)&0xFF000000)>>24;
+		pDM_PSTable->RegA74 = (PHY_QueryBBReg(pDM_Odm->Adapter, 0xa74, bMaskDWord)&0xF000)>>12;
 		//Reg818 = PHY_QueryBBReg(pAdapter, 0x818, bMaskDWord);
 		pDM_PSTable->initialize = 1;
 	}
@@ -150,21 +95,21 @@ ODM_RF_Saving(
 	{
 		if(pDM_PSTable->CurRFState == RF_Save)
 		{
-			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1C0000, 0x2); //Reg874[20:18]=3'b010
-			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, 0); //RegC70[3]=1'b0
-			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, 0x63); //Reg85C[31:24]=0x63
-			ODM_SetBBReg(pDM_Odm, 0x874, 0xC000, 0x2); //Reg874[15:14]=2'b10
-			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, 0x3); //RegA75[7:4]=0x3
-			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0); //Reg818[28]=1'b0
-			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x1); //Reg818[28]=1'b1
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x874  , 0x1C0000, 0x2); //Reg874[20:18]=3'b010
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xc70, BIT3, 0); //RegC70[3]=1'b0
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x85c, 0xFF000000, 0x63); //Reg85C[31:24]=0x63
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x874, 0xC000, 0x2); //Reg874[15:14]=2'b10
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xa74, 0xF000, 0x3); //RegA75[7:4]=0x3
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x818, BIT28, 0x0); //Reg818[28]=1'b0
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x818, BIT28, 0x1); //Reg818[28]=1'b1
 		}
 		else
 		{
-			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1CC000, pDM_PSTable->Reg874); 
-			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, pDM_PSTable->RegC70); 
-			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);
-			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, pDM_PSTable->RegA74); 
-			ODM_SetBBReg(pDM_Odm,0x818, BIT28, 0x0);  
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x874  , 0x1CC000, pDM_PSTable->Reg874);
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xc70, BIT3, pDM_PSTable->RegC70);
+			PHY_SetBBReg(pDM_Odm->Adapter, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);
+			PHY_SetBBReg(pDM_Odm->Adapter, 0xa74, 0xF000, pDM_PSTable->RegA74);
+			PHY_SetBBReg(pDM_Odm->Adapter,0x818, BIT28, 0x0);
 		}
 		pDM_PSTable->PreRFState =pDM_PSTable->CurRFState;
 	}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DynamicBBPowerSaving.h linux/3rdparty/rtl8723bs/hal/odm_DynamicBBPowerSaving.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_DynamicBBPowerSaving.h	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DynamicBBPowerSaving.h	2015-05-07 17:46:55.000000000 +0300
@@ -48,9 +48,4 @@ odm_DynamicBBPowerSavingInit(
 	IN		void *					pDM_VOID
 	);
 
-void
-odm_1R_CCA(
-	IN		void *					pDM_VOID
-	);
-
 #endif
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DynamicTxPower.c linux/3rdparty/rtl8723bs/hal/odm_DynamicTxPower.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_DynamicTxPower.c	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DynamicTxPower.c	2015-05-07 17:46:55.000000000 +0300
@@ -39,50 +39,3 @@ odm_DynamicTxPowerInit(
 	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
 	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;	
 }
-
-void
-odm_DynamicTxPowerSavePowerIndex(
-	IN		void *					pDM_VOID	
-	)
-{	
-	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	u1Byte		index;
-	u4Byte		Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-	
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	for(index = 0; index< 6; index++)
-		pdmpriv->PowerIndex_backup[index] = rtw_read8(Adapter, Power_Index_REG[index]);
-}
-
-void
-odm_DynamicTxPowerRestorePowerIndex(
-	IN		void *					pDM_VOID
-	)
-{
-	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	u1Byte			index;
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	for(index = 0; index< 6; index++)
-		rtw_write8(Adapter, Power_Index_REG[index], pdmpriv->PowerIndex_backup[index]);
-}
-
-void
-odm_DynamicTxPowerWritePowerIndex(
-	IN		void *					pDM_VOID, 
-	IN 	u1Byte		Value)
-{
-	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
-	u1Byte			index;
-	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-	
-	for(index = 0; index< 6; index++)
-		//PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], Value);
-		ODM_Write1Byte(pDM_Odm, Power_Index_REG[index], Value);
-
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_DynamicTxPower.h linux/3rdparty/rtl8723bs/hal/odm_DynamicTxPower.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_DynamicTxPower.h	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_DynamicTxPower.h	2015-05-07 17:46:55.000000000 +0300
@@ -42,19 +42,4 @@ odm_DynamicTxPowerInit(
 	IN		void *					pDM_VOID
 	);
 
-void
-odm_DynamicTxPowerRestorePowerIndex(
-	IN		void *					pDM_VOID
-	);
-
-void
-odm_DynamicTxPowerSavePowerIndex(
-	IN		void *					pDM_VOID
-	);
-
-void
-odm_DynamicTxPowerWritePowerIndex(
-	IN		void *					pDM_VOID, 
-	IN 	u1Byte		Value);
-
 #endif
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_EdcaTurboCheck.c linux/3rdparty/rtl8723bs/hal/odm_EdcaTurboCheck.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_EdcaTurboCheck.c	2015-05-10 14:36:05.707668335 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_EdcaTurboCheck.c	2015-05-07 17:46:55.000000000 +0300
@@ -34,10 +34,10 @@ ODM_EdcaTurboInit(
 	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = false;
 	Adapter->recvpriv.bIsAnyNonBEPkts =false;
 
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VO PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VO_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VI PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VI_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BK PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BK_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VO PARAM: 0x%x\n",rtw_read32(pDM_Odm->Adapter,ODM_EDCA_VO_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VI PARAM: 0x%x\n",rtw_read32(pDM_Odm->Adapter,ODM_EDCA_VI_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",rtw_read32(pDM_Odm->Adapter,ODM_EDCA_BE_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BK PARAM: 0x%x\n",rtw_read32(pDM_Odm->Adapter,ODM_EDCA_BK_PARAM)));
 
 	
 }	// ODM_InitEdcaTurbo
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm.h linux/3rdparty/rtl8723bs/hal/odm.h
--- linux/3rdparty/rtl8723bs.old/hal/odm.h	2015-05-10 14:36:05.708668346 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm.h	2015-05-07 17:46:55.000000000 +0300
@@ -1515,9 +1515,6 @@ ODM_SetAntenna(
 
 //Remove BB power saving by Yuchen
 
-#define SwAntDivRestAfterLink	ODM_SwAntDivRestAfterLink
-void ODM_SwAntDivRestAfterLink(	IN	PDM_ODM_T	pDM_Odm);
-
 #define dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
 void	
 ODM_TXPowerTrackingCheck(
@@ -1539,14 +1536,6 @@ void ODM_SwAntDivChkPerPktRssi(
 	IN PODM_PHY_INFO_T pPhyInfo
 	);
 
-u4Byte ConvertTo_dB(u4Byte Value);
-
-u4Byte
-GetPSDData(
-	PDM_ODM_T	pDM_Odm,
-	unsigned int 	point,
-	u1Byte initial_gain_psd);
-
 u4Byte ODM_Get_Rate_Bitmap(
 	IN	PDM_ODM_T	pDM_Odm,
 	IN	u4Byte		macid,
@@ -1572,11 +1561,6 @@ ODM_DMInit(
 );
 
 void
-ODM_DMReset(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-void
 ODM_DMWatchdog(
 	IN		PDM_ODM_T			pDM_Odm			// For common use in the future
 	);
@@ -1634,56 +1618,6 @@ ODM_AntselStatistics_88C(
 );
 
 void
-ODM_SingleDualAntennaDefaultSetting(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-bool
-ODM_SingleDualAntennaDetection(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			mode
-	);
-
-void
-ODM_UpdateNoisyState(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN 	bool 	bNoisyStateFromC2H
-);
-
-u4Byte
-Set_RA_DM_Ratrbitmap_by_Noisy(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u4Byte			ratr_bitmap,
-	IN	u1Byte			rssi_level
-);
-
-void
-ODM_UpdateInitRate(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		Rate
-	);
-
-void
-ODM_InitializeTimer(
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	PRT_TIMER 			pTimer, 
-	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
-	IN	void *				pContext,
-	IN	const char*			szID
-);
-
-void
-ODM_CancelAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-);
-
-void
-ODM_ReleaseAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-);
-
-void
 ODM_DynamicARFBSelect(
 	IN		PDM_ODM_T		pDM_Odm,
 	IN 		u1Byte			rate,
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_HWConfig.c linux/3rdparty/rtl8723bs/hal/odm_HWConfig.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_HWConfig.c	2015-05-10 14:36:05.708668346 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_HWConfig.c	2015-05-07 17:46:55.000000000 +0300
@@ -339,14 +339,6 @@ odm_RxPhyStatus92CSeries_Parsing(
 		//isCCKrate, pPhyInfo->RxPWDBAll, pPhyStaRpt->cck_agc_rpt_ofdm_cfosho_a);
 }
 
-void
-odm_Init_RSSIForDM(
-	IN OUT	PDM_ODM_T	pDM_Odm
-	)
-{
-
-}
-
 static void
 odm_Process_RSSIForDM(	
 	IN OUT	PDM_ODM_T					pDM_Odm,
@@ -563,22 +555,6 @@ ODM_PhyStatusQuery(
 
 	ODM_PhyStatusQuery_92CSeries(pDM_Odm,pPhyInfo,pPhyStatus,pPktinfo);
 }
-	
-// For future use.
-void
-ODM_MacStatusQuery(
-	IN OUT	PDM_ODM_T					pDM_Odm,
-	IN 		pu1Byte						pMacStatus,
-	IN		u1Byte						MacID,	
-	IN		bool						bPacketMatchBSSID,
-	IN		bool						bPacketToSelf,
-	IN		bool						bPacketBeacon
-	)
-{
-	// 2011/10/19 Driver team will handle in the future.
-	
-}
-
 
 //
 // If you want to add a new IC, Please follow below template and generate a new one.
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_HWConfig.h linux/3rdparty/rtl8723bs/hal/odm_HWConfig.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_HWConfig.h	2015-05-10 14:36:05.709668358 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_HWConfig.h	2015-05-07 17:46:55.000000000 +0300
@@ -137,11 +137,6 @@ typedef struct _Phy_Status_Rpt_8812
 
 
 void
-odm_Init_RSSIForDM(
-	IN OUT	PDM_ODM_T	pDM_Odm
-	);
-
-void
 ODM_PhyStatusQuery(
 	IN OUT	PDM_ODM_T					pDM_Odm,
 	OUT		PODM_PHY_INFO_T			pPhyInfo,
@@ -149,15 +144,6 @@ ODM_PhyStatusQuery(
 	IN		PODM_PACKET_INFO_T			pPktinfo
 	);
 
-void
-ODM_MacStatusQuery(
-	IN OUT	PDM_ODM_T					pDM_Odm,
-	IN 		pu1Byte						pMacStatus,
-	IN		u1Byte						MacID,	
-	IN		bool						bPacketMatchBSSID,
-	IN		bool						bPacketToSelf,
-	IN		bool						bPacketBeacon
-	);
 HAL_STATUS
 ODM_ConfigRFWithTxPwrTrackHeaderFile(
 	IN 	PDM_ODM_T	        	pDM_Odm
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_interface.c linux/3rdparty/rtl8723bs/hal/odm_interface.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_interface.c	2015-05-10 14:36:05.709668358 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_interface.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,268 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-//============================================================
-// include files
-//============================================================
-
-
-#include "odm_precomp.h"
-
-//
-// ODM IO Relative API.
-//
-
-u1Byte
-ODM_Read1Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return rtw_read8(Adapter,RegAddr);
-}
-
-
-u2Byte
-ODM_Read2Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return rtw_read16(Adapter,RegAddr);
-}
-
-
-u4Byte
-ODM_Read4Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return rtw_read32(Adapter,RegAddr);
-}
-
-
-void
-ODM_Write1Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u1Byte			Data
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	rtw_write8(Adapter,RegAddr, Data);
-}
-
-
-void
-ODM_Write2Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u2Byte			Data
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	rtw_write16(Adapter,RegAddr, Data);
-}
-
-
-void
-ODM_Write4Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u4Byte			Data
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	rtw_write32(Adapter,RegAddr, Data);
-}
-
-
-void
-ODM_SetMACReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask,
-	IN	u4Byte		Data
-	)
-{
-}
-
-
-u4Byte 
-ODM_GetMACReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask
-	)
-{
-	return PHY_QueryBBReg(pDM_Odm->Adapter, RegAddr, BitMask);
-}
-
-
-void
-ODM_SetBBReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask,
-	IN	u4Byte		Data
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	PHY_SetBBReg(Adapter, RegAddr, BitMask, Data);
-}
-
-
-u4Byte 
-ODM_GetBBReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return PHY_QueryBBReg(Adapter, RegAddr, BitMask);
-}
-
-
-void
-ODM_SetRFReg(	
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	ODM_RF_RADIO_PATH_E	eRFPath,
-	IN	u4Byte				RegAddr,
-	IN	u4Byte				BitMask,
-	IN	u4Byte				Data
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data);
-}
-
-
-u4Byte 
-ODM_GetRFReg(	
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	ODM_RF_RADIO_PATH_E	eRFPath,
-	IN	u4Byte				RegAddr,
-	IN	u4Byte				BitMask
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask);
-}
-
-//
-// ODM Memory relative API.
-//
-void
-ODM_AllocateMemory(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	OUT	void *		*pPtr,
-	IN	u4Byte		length
-	)
-{
-	*pPtr = rtw_zvmalloc(length);
-}
-
-// length could be ignored, used to detect memory leakage.
-void
-ODM_FreeMemory(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	OUT	void *		pPtr,
-	IN	u4Byte		length
-	)
-{
-	rtw_vmfree(pPtr, length);
-}
-
-//
-// ODM Timer relative API.
-//
-void
-ODM_SetTimer(	
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER 		pTimer, 
-	IN	u4Byte 			msDelay
-	)
-{
-	_set_timer(pTimer,msDelay ); //ms
-}
-
-void
-ODM_InitializeTimer(
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	PRT_TIMER 			pTimer, 
-	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
-	IN	void *				pContext,
-	IN	const char*			szID
-	)
-{
-	PADAPTER Adapter = pDM_Odm->Adapter;
-	_init_timer(pTimer,Adapter->pnetdev,CallBackFunc,pDM_Odm);
-}
-
-
-void
-ODM_CancelTimer(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER		pTimer
-	)
-{
-	_cancel_timer_ex(pTimer);
-}
-
-
-void
-ODM_ReleaseTimer(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER		pTimer
-	)
-{
-}
-
-
-//
-// ODM FW relative API.
-//
-void
-ODM_FillH2CCmd(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u1Byte 			ElementID,
-	IN	u4Byte 			CmdLen,
-	IN	pu1Byte			pCmdBuffer
-)
-{
-	PADAPTER 		Adapter = pDM_Odm->Adapter;
-
-		switch(ElementID)
-		{
-			case ODM_H2C_RSSI_REPORT:
-				FillH2CCmd8723B(Adapter, H2C_8723B_RSSI_SETTING, CmdLen, pCmdBuffer);
-				break;
-			case ODM_H2C_WIFI_CALIBRATION:
-				FillH2CCmd8723B(Adapter, H2C_8723B_BT_WLAN_CALIBRATION, CmdLen, pCmdBuffer);
-			   	break;
-			default:
-				break;			   
-		}
-}
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_interface.h linux/3rdparty/rtl8723bs/hal/odm_interface.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_interface.h	2015-05-10 14:36:05.709668358 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_interface.h	2015-05-07 17:46:55.000000000 +0300
@@ -68,169 +68,4 @@ typedef enum _ODM_H2C_CMD
 }ODM_H2C_CMD;
 
 
-//
-// 2012/02/17 MH For non-MP compile pass only. Linux does not support workitem.
-// Suggest HW team to use thread instead of workitem. Windows also support the feature.
-//
-typedef  void *PRT_WORK_ITEM ;
-typedef  void RT_WORKITEM_HANDLE,*PRT_WORKITEM_HANDLE;
-typedef void (*RT_WORKITEM_CALL_BACK)(void * pContext);
-
-//
-// =========== Extern Variable ??? It should be forbidden.
-//
-
-
-//
-// =========== EXtern Function Prototype
-//
-
-
-u1Byte
-ODM_Read1Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	);
-
-u2Byte
-ODM_Read2Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	);
-
-u4Byte
-ODM_Read4Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr
-	);
-
-void
-ODM_Write1Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u1Byte			Data
-	);
-
-void
-ODM_Write2Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u2Byte			Data
-	);
-
-void
-ODM_Write4Byte(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			RegAddr,
-	IN	u4Byte			Data
-	);
-
-void
-ODM_SetMACReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask,
-	IN	u4Byte		Data
-	);
-
-u4Byte 
-ODM_GetMACReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask
-	);
-
-void
-ODM_SetBBReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask,
-	IN	u4Byte		Data
-	);
-
-u4Byte 
-ODM_GetBBReg(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		RegAddr,
-	IN	u4Byte		BitMask
-	);
-
-void
-ODM_SetRFReg(	
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	ODM_RF_RADIO_PATH_E	eRFPath,
-	IN	u4Byte				RegAddr,
-	IN	u4Byte				BitMask,
-	IN	u4Byte				Data
-	);
-
-u4Byte 
-ODM_GetRFReg(	
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	ODM_RF_RADIO_PATH_E	eRFPath,
-	IN	u4Byte				RegAddr,
-	IN	u4Byte				BitMask
-	);
-
-
-//
-// Memory Relative Function.
-//
-void
-ODM_AllocateMemory(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	OUT	void *		*pPtr,
-	IN	u4Byte		length
-	);
-void
-ODM_FreeMemory(	
-	IN 	PDM_ODM_T	pDM_Odm,
-	OUT	void *		pPtr,
-	IN	u4Byte		length
-	);
-
-//
-// ODM Timer relative API.
-//
-void
-ODM_SetTimer(	
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER 		pTimer, 
-	IN	u4Byte 			msDelay
-	);
-
-void
-ODM_InitializeTimer(
-	IN 	PDM_ODM_T			pDM_Odm,
-	IN	PRT_TIMER 			pTimer, 
-	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
-	IN	void *				pContext,
-	IN	const char*			szID
-	);
-
-void
-ODM_CancelTimer(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER		pTimer
-	);
-
-void
-ODM_ReleaseTimer(
-	IN 	PDM_ODM_T		pDM_Odm,
-	IN	PRT_TIMER		pTimer
-	);
-
-
-//
-// ODM FW relative API.
-//
-void
-ODM_FillH2CCmd(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u1Byte 	ElementID,
-	IN	u4Byte 	CmdLen,
-	IN	pu1Byte	pCmdBuffer
-);
-
 #endif	// __ODM_INTERFACE_H__
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_NoiseMonitor.c linux/3rdparty/rtl8723bs/hal/odm_NoiseMonitor.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_NoiseMonitor.c	2015-05-10 14:36:05.709668358 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_NoiseMonitor.c	2015-05-07 17:46:55.000000000 +0300
@@ -79,18 +79,18 @@ static s16 odm_InbandNoise_Monitor_NSeri
 	{
 		
 		//Stop updating idle time pwer report (for driver read)
-		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 1);	
+		PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_TxGainStage, BIT25, 1);
 		
 		//Read Noise Floor Report
-		tmp4b = ODM_GetBBReg(pDM_Odm, 0x8f8,bMaskDWord );
+		tmp4b = PHY_QueryBBReg(pDM_Odm->Adapter, 0x8f8,bMaskDWord );
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("Noise Floor Report (0x8f8) = 0x%08x\n", tmp4b));
 		
-		//ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, TestInitialGain);
+		//PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XAAGCCore1, bMaskByte0, TestInitialGain);
 		//if(max_rf_path == 2)
-		//	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, TestInitialGain);
+		//	PHY_SetBBReg(pDM_Odm->Adapter, rOFDM0_XBAGCCore1, bMaskByte0, TestInitialGain);
 		
 		//update idle time pwer report per 5us
-		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 0);
+		PHY_SetBBReg(pDM_Odm->Adapter, rFPGA0_TxGainStage, BIT25, 0);
 		
 		noise_data.value[ODM_RF_PATH_A] = (u1Byte)(tmp4b&0xff);		
 		noise_data.value[ODM_RF_PATH_B]  = (u1Byte)((tmp4b&0xff00)>>8);
@@ -142,14 +142,14 @@ static s16 odm_InbandNoise_Monitor_NSeri
 			break;
 		}
 	}
-	reg_c50 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XAAGCCore1,bMaskByte0);
+	reg_c50 = (s4Byte)PHY_QueryBBReg(pDM_Odm->Adapter,rOFDM0_XAAGCCore1,bMaskByte0);
 	reg_c50 &= ~BIT7;
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XAAGCCore1, reg_c50, reg_c50));
 	pDM_Odm->noise_level.noise[ODM_RF_PATH_A] = -110 + reg_c50 + noise_data.sum[ODM_RF_PATH_A];
 	pDM_Odm->noise_level.noise_all += pDM_Odm->noise_level.noise[ODM_RF_PATH_A];
 		
 	if(max_rf_path == 2){
-		reg_c58 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XBAGCCore1,bMaskByte0);
+		reg_c58 = (s4Byte)PHY_QueryBBReg(pDM_Odm->Adapter,rOFDM0_XBAGCCore1,bMaskByte0);
 		reg_c58 &= ~BIT7;
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XBAGCCore1, reg_c58, reg_c58));
 		pDM_Odm->noise_level.noise[ODM_RF_PATH_B] = -110 + reg_c58 + noise_data.sum[ODM_RF_PATH_B];
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_precomp.h linux/3rdparty/rtl8723bs/hal/odm_precomp.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_precomp.h	2015-05-10 14:36:05.710668369 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_precomp.h	2015-05-07 17:46:55.000000000 +0300
@@ -27,7 +27,6 @@
 
 //2 Config Flags and Structs - defined by each ODM Type
 
-	//#include <drv_conf.h>
 	//#include <basic_types.h>
 	//#include <osdep_service.h>
 	//#include <drv_types.h>
@@ -42,7 +41,6 @@
 #include "odm.h"
 #include "odm_HWConfig.h"
 #include "odm_debug.h"
-#include "odm_RegDefine11AC.h"
 #include "odm_RegDefine11N.h"
 #include "odm_AntDiv.h"
 #include "odm_EdcaTurboCheck.h"
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_RegConfig8723B.c linux/3rdparty/rtl8723bs/hal/odm_RegConfig8723B.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_RegConfig8723B.c	2015-05-10 14:36:05.710668369 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_RegConfig8723B.c	2015-05-07 17:46:55.000000000 +0300
@@ -35,7 +35,7 @@ odm_ConfigRFReg_8723B(
 	}
 	else
 	{
-		ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+		PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
 		// Add 1us delay between BB/RF register setting.
 		udelay(1);
 
@@ -44,16 +44,16 @@ odm_ConfigRFReg_8723B(
 		{
 			u4Byte getvalue=0;
 			u1Byte	count =0;
-			getvalue = ODM_GetRFReg(pDM_Odm, RF_PATH, Addr, bMaskDWord);	
+			getvalue = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH, Addr, bMaskDWord);
 
 			udelay(1);
 			
 			while((getvalue>>8)!=(Data>>8))
 			{
 				count++;
-				ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+				PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
 				udelay(1);
-				getvalue = ODM_GetRFReg(pDM_Odm, RF_PATH, Addr, bMaskDWord);
+				getvalue = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH, Addr, bMaskDWord);
 				ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [B6] getvalue 0x%x, Data 0x%x, count %d\n", getvalue, Data,count));			
 				if(count>5)
 					break;
@@ -64,19 +64,19 @@ odm_ConfigRFReg_8723B(
 		{
 			u4Byte getvalue=0;
 			u1Byte	count =0;
-			getvalue = ODM_GetRFReg(pDM_Odm, RF_PATH, Addr, bMaskDWord);	
+			getvalue = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH, Addr, bMaskDWord);
 
 			udelay(1);
 			
 			while(getvalue!=Data)
 			{
 				count++;
-				ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+				PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
 				udelay(1);
 				//Do LCK againg 
-				ODM_SetRFReg(pDM_Odm, RF_PATH, 0x18, bRFRegOffsetMask, 0x0fc07);
+				PHY_SetRFReg(pDM_Odm->Adapter, RF_PATH, 0x18, bRFRegOffsetMask, 0x0fc07);
 				udelay(1);
-				getvalue = ODM_GetRFReg(pDM_Odm, RF_PATH, Addr, bMaskDWord);
+				getvalue = PHY_QueryRFReg(pDM_Odm->Adapter, RF_PATH, Addr, bMaskDWord);
 				ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [B2] getvalue 0x%x, Data 0x%x, count %d\n", getvalue, Data,count));			
 				if(count>5)
 					break;
@@ -102,29 +102,13 @@ odm_ConfigRF_RadioA_8723B(
 }
 
 void 
-odm_ConfigRF_RadioB_8723B(
-	IN 	PDM_ODM_T 				pDM_Odm,
-	IN 	u4Byte 					Addr,
-	IN 	u4Byte 					Data
-	)
-{
-	u4Byte  content = 0x1001; // RF_Content: radiob_txt
-	u4Byte	maskforPhySet= (u4Byte)(content&0xE000);
-
-    odm_ConfigRFReg_8723B(pDM_Odm, Addr, Data, ODM_RF_PATH_B, Addr|maskforPhySet);
-	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigRFWithHeaderFile: [RadioB] %08X %08X\n", Addr, Data));
-    
-}
-
-void 
 odm_ConfigMAC_8723B(
  	IN 	PDM_ODM_T 	pDM_Odm,
  	IN 	u4Byte 		Addr,
  	IN 	u1Byte 		Data
  	)
 {
-	ODM_Write1Byte(pDM_Odm, Addr, Data);
+	rtw_write8(pDM_Odm->Adapter, Addr, Data);
     ODM_RT_TRACE(pDM_Odm,ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ConfigMACWithHeaderFile: [MAC_REG] %08X %08X\n", Addr, Data));
 }
 
@@ -136,7 +120,7 @@ odm_ConfigBB_AGC_8723B(
     IN 	u4Byte 		Data
     )
 {
-	ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);		
+	PHY_SetBBReg(pDM_Odm->Adapter, Addr, Bitmask, Data);
 	// Add 1us delay between BB/RF register setting.
 	udelay(1);
 
@@ -185,7 +169,7 @@ odm_ConfigBB_PHY_8723B(
 		udelay(1);
 	else 
 	{
-		ODM_SetBBReg(pDM_Odm, Addr, Bitmask, Data);		
+		PHY_SetBBReg(pDM_Odm->Adapter, Addr, Bitmask, Data);
 	}
 	
 	// Add 1us delay between BB/RF register setting.
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_RegConfig8723B.h linux/3rdparty/rtl8723bs/hal/odm_RegConfig8723B.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_RegConfig8723B.h	2015-05-10 14:36:05.710668369 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_RegConfig8723B.h	2015-05-07 17:46:55.000000000 +0300
@@ -37,13 +37,6 @@ odm_ConfigRF_RadioA_8723B(
 	);
 
 void 
-odm_ConfigRF_RadioB_8723B(
-	IN 	PDM_ODM_T 				pDM_Odm,
-	IN 	u4Byte 					Addr,
-	IN 	u4Byte 					Data
-	);
-
-void 
 odm_ConfigMAC_8723B(
  	IN 	PDM_ODM_T 	pDM_Odm,
  	IN 	u4Byte 		Addr,
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_RegDefine11AC.h linux/3rdparty/rtl8723bs/hal/odm_RegDefine11AC.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_RegDefine11AC.h	2015-05-10 14:36:05.710668369 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_RegDefine11AC.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,75 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
- 
-#ifndef	__ODM_REGDEFINE11AC_H__
-#define __ODM_REGDEFINE11AC_H__
-
-//2 RF REG LIST
-
-
-
-//2 BB REG LIST
-//PAGE 8
-#define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
-#define	ODM_REG_BB_RX_PATH_11AC			0x808
-#define	ODM_REG_BB_ATC_11AC				0x860
-#define	ODM_REG_DBG_RPT_11AC				0x8fc
-//PAGE 9
-#define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
-#define	ODM_REG_NHM_TIMER_11AC			0x990
-#define	ODM_REG_NHM_TH9_TH10_11AC		0x994
-#define	ODM_REG_NHM_TH3_TO_TH0_11AC	0x998
-#define	ODM_REG_NHM_TH7_TO_TH4_11AC	0x99c
-#define	ODM_REG_NHM_TH8_11AC			0x9a0
-#define	ODM_REG_NHM_9E8_11AC			0x9e8
-//PAGE A
-#define	ODM_REG_CCK_CCA_11AC			0xA0A
-#define	ODM_REG_CCK_FA_RST_11AC			0xA2C
-#define	ODM_REG_CCK_FA_11AC				0xA5C
-//PAGE B
-#define	ODM_REG_RST_RPT_11AC				0xB58
-//PAGE C
-#define	ODM_REG_TRMUX_11AC				0xC08
-#define	ODM_REG_IGI_A_11AC				0xC50
-//PAGE E
-#define	ODM_REG_IGI_B_11AC				0xE50
-//PAGE F
-#define	ODM_REG_CCK_CCA_CNT_11AC		0xF08
-#define	ODM_REG_OFDM_FA_11AC			0xF48
-#define	ODM_REG_RPT_11AC					0xfa0
-#define	ODM_REG_NHM_CNT_11AC			0xfa8
-//PAGE 18
-#define	ODM_REG_IGI_C_11AC				0x1850
-//PAGE 1A
-#define	ODM_REG_IGI_D_11AC				0x1A50
-
-//2 MAC REG LIST
-#define	ODM_REG_RESP_TX_11AC				0x6D8
-
-
-
-//DIG Related
-#define	ODM_BIT_IGI_11AC					0xFFFFFFFF
-#define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT16
-#define	ODM_BIT_BB_RX_PATH_11AC			0xF
-#define	ODM_BIT_BB_ATC_11AC				BIT14
-
-#endif
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_RTL8723B.c linux/3rdparty/rtl8723bs/hal/odm_RTL8723B.c
--- linux/3rdparty/rtl8723bs.old/hal/odm_RTL8723B.c	2015-05-10 14:36:05.710668369 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_RTL8723B.c	2015-05-07 17:46:55.000000000 +0300
@@ -24,221 +24,6 @@
 
 #include "odm_precomp.h"
 
-void 
-odm_DIG_8723(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
-	Pfalse_ALARM_STATISTICS		pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;
-	//pRXHP_T						pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-	u1Byte						DIG_Dynamic_MIN;
-	bool						FirstConnect, FirstDisConnect;
-	u1Byte						dm_dig_max, dm_dig_min;
-	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG()==>\n"));
-	//if(!(pDM_Odm->SupportAbility & (ODM_BB_DIG|ODM_BB_FA_CNT)))
-	if((!(pDM_Odm->SupportAbility&ODM_BB_DIG)) ||(!(pDM_Odm->SupportAbility&ODM_BB_FA_CNT)))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n"));
-		return;
-	}
-		
-	if(*(pDM_Odm->pbScanInProcess))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: In Scan Progress \n"));
-	    	return;
-	}
-
-	//add by Neil Chen to avoid PSD is processing
-       if(pDM_Odm->bDMInitialGainEnable == false)
-       {
-               ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: PSD is Processing \n"));
-               return;
-       }
-		
-	
-	DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
-	FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == false);
-	FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == true);
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): RSSI=0x%x\n",pDM_Odm->RSSI_Min));
-
-	dm_dig_max = 0x5A;
-
-			
-	dm_dig_min = DM_DIG_MIN_NIC_8723;
-		
-	if(pDM_Odm->bLinked)
-	{
-		//BT is Concurrent
-		if(pDM_Odm->bBtLimitedDig)
-		{
-			if(( pDM_Odm->RSSI_Min + 10) > DM_DIG_MAX_NIC )
-				pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
-			else if(( pDM_Odm->RSSI_Min + 10) < DM_DIG_MIN_NIC )
-				pDM_DigTable->rx_gain_range_max = DM_DIG_MIN_NIC;
-			else
-				pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 10;
-		
-			if(pDM_Odm->RSSI_Min>10)
-			{
-				if((pDM_Odm->RSSI_Min - 10) > DM_DIG_MAX_NIC)
-					DIG_Dynamic_MIN = DM_DIG_MAX_NIC;
-				else if((pDM_Odm->RSSI_Min - 10) < DM_DIG_MIN_NIC_8723)
-					DIG_Dynamic_MIN = DM_DIG_MIN_NIC_8723;
-				else
-					DIG_Dynamic_MIN = pDM_Odm->RSSI_Min - 10;
-			}
-			else
-				DIG_Dynamic_MIN=DM_DIG_MIN_NIC_8723;
-		}
-		else
-		{
-			if((pDM_Odm->RSSI_Min + 20) > dm_dig_max )
-				pDM_DigTable->rx_gain_range_max = dm_dig_max;
-			else if((pDM_Odm->RSSI_Min + 20) < dm_dig_min )
-				pDM_DigTable->rx_gain_range_max = dm_dig_min;
-			else
-				pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 20;
-
-
-			if(pDM_Odm->RSSI_Min>20)
-			{
-				if((pDM_Odm->RSSI_Min - 20) > DM_DIG_MAX_NIC)
-					DIG_Dynamic_MIN = DM_DIG_MAX_NIC;
-				else if((pDM_Odm->RSSI_Min - 20) < DM_DIG_MIN_NIC_8723)
-					DIG_Dynamic_MIN = DM_DIG_MIN_NIC_8723;
-				else
-					DIG_Dynamic_MIN = pDM_Odm->RSSI_Min -20;
-			}
-			else
-				DIG_Dynamic_MIN=DM_DIG_MIN_NIC_8723;
-			
-			
-		}
-	}
-	else
-	{
-		pDM_DigTable->rx_gain_range_max = dm_dig_max;
-		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC_8723;
-		DIG_Dynamic_MIN = dm_dig_min;
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() : No Link\n"));
-	}	
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG():pDM_DigTable->Recover_cnt=%d\n",pDM_DigTable->Recover_cnt));
-
-	//1 Adjust initial gain by false alarm
-	if(pDM_Odm->bLinked)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG AfterLink\n"));
-		if(FirstConnect)
-		{
-			CurrentIGI = pDM_Odm->RSSI_Min;
-			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("DIG: First Connect\n"));
-		}
-		else
-		{
-			//FA for Combo IC--NeilChen--2012--09--28 
-			//WLAN and BT ConCurrent
-			if(pDM_Odm->bBtLimitedDig)
-			{
-				if(pFalseAlmCnt->Cnt_all > 0x500)
-					CurrentIGI = CurrentIGI + 4;
-				else if (pFalseAlmCnt->Cnt_all > 0x300)
-					CurrentIGI = CurrentIGI + 2;
-				else if(pFalseAlmCnt->Cnt_all <0x150)
-					CurrentIGI = CurrentIGI -2;
-			}
-			else //Not Concurrent
-			{
-				if(pFalseAlmCnt->Cnt_all > 0x400)
-					CurrentIGI = CurrentIGI + 4;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2;
-				else if (pFalseAlmCnt->Cnt_all > 0x200)
-					CurrentIGI = CurrentIGI + 2;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1;
-				else if(pFalseAlmCnt->Cnt_all < 0x100)
-					CurrentIGI = CurrentIGI - 2;//pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1;	
-			}
-		}
-	}	
-	else
-	{
-                CurrentIGI = pDM_DigTable->rx_gain_range_min;//pDM_DigTable->CurIGValue = pDM_DigTable->rx_gain_range_min
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG BeforeLink\n"));
-		if(FirstDisConnect)
-		{
-				CurrentIGI = pDM_DigTable->rx_gain_range_min;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First DisConnect \n"));
-		}
-		else
-		{
-			//2012.03.30 LukeLee: enable DIG before link but with very high thresholds
-	             if(pFalseAlmCnt->Cnt_all > 10000)
-				CurrentIGI = CurrentIGI + 4;
-			else if (pFalseAlmCnt->Cnt_all > 8000)
-				CurrentIGI = CurrentIGI + 2;
-			else if(pFalseAlmCnt->Cnt_all < 500)
-				CurrentIGI = CurrentIGI - 2;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): England DIG \n"));
-		}
-	}
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG End Adjust IGI\n"));
-	//1 Check initial gain by upper/lower bound
-
-	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
-		CurrentIGI = pDM_DigTable->rx_gain_range_max;
-	if(CurrentIGI < pDM_DigTable->rx_gain_range_min)
-		CurrentIGI = pDM_DigTable->rx_gain_range_min;
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): rx_gain_range_max=0x%x, rx_gain_range_min=0x%x\n", 
-		pDM_DigTable->rx_gain_range_max, pDM_DigTable->rx_gain_range_min));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TotalFA=%d\n", pFalseAlmCnt->Cnt_all));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x\n", CurrentIGI));
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): RSSI=0x%x\n",pDM_Odm->RSSI_Min));
-
-	if(pDM_Odm->bBtHsOperation)
-	{
-		if(pDM_Odm->bLinked)
-		{
-			if(pDM_DigTable->BT30_CurIGI > (CurrentIGI))
-			{
-				ODM_Write_DIG(pDM_Odm, CurrentIGI);
-				
-			}	
-			else
-			{
-				ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);
-			}
-			pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-			pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-		}
-		else
-		{
-			if(pDM_Odm->bLinkInProcess)
-			{
-				ODM_Write_DIG(pDM_Odm, 0x1c);
-			}
-			else if(pDM_Odm->bBtConnectProcess)
-			{
-				ODM_Write_DIG(pDM_Odm, 0x28);
-			}
-			else
-			{
-				ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);	
-			}
-		}
-	}	
-	else		// BT is not using
-	{
-		ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
-		pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-		pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-	}	
-}
-
-
  s8
 odm_CCKRSSI_8723B(
 	IN		u1Byte	LNA_idx,
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/odm_RTL8723B.h linux/3rdparty/rtl8723bs/hal/odm_RTL8723B.h
--- linux/3rdparty/rtl8723bs.old/hal/odm_RTL8723B.h	2015-05-10 14:36:05.711668380 +0300
+++ linux/3rdparty/rtl8723bs/hal/odm_RTL8723B.h	2015-05-07 17:46:55.000000000 +0300
@@ -22,9 +22,6 @@
 
 #define	DM_DIG_MIN_NIC_8723	0x1C
 
-void 
-odm_DIG_8723(IN		PDM_ODM_T		pDM_Odm);
-
 s8
 odm_CCKRSSI_8723B(
 	IN		u1Byte	LNA_idx,
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723b_cmd.c linux/3rdparty/rtl8723bs/hal/rtl8723b_cmd.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723b_cmd.c	2015-05-10 14:36:05.712668391 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723b_cmd.c	2015-05-07 17:46:55.000000000 +0300
@@ -76,7 +76,8 @@ _func_enter_;
 
 	padapter = GET_PRIMARY_ADAPTER(padapter);
 	pHalData = GET_HAL_DATA(padapter);
-	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);
+	if (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex)))
+		return ret;
 
 	if (!pCmdBuffer) {
 		goto exit;
@@ -130,7 +131,7 @@ _func_enter_;
 
 exit:
 
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);	
+	mutex_unlock(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
 
 _func_exit_;
 
@@ -396,11 +397,7 @@ static void ConstructARPResponse(
 
 	//SET_80211_HDR_DURATION(pARPRspPkt, 0);
 	//SET_80211_HDR_FRAGMENT_SEQUENCE(pARPRspPkt, 0);
-#ifdef CONFIG_WAPI_SUPPORT
- 	*pLength = sMacHdrLng;
-#else
 	*pLength = 24;
-#endif
 
 	//-------------------------------------------------------------------------
 	// Security Header: leave space for it if necessary.
@@ -418,11 +415,6 @@ static void ConstructARPResponse(
 		case _AES_:
 			EncryptionHeadOverhead = 8;
 			break;
-#ifdef CONFIG_WAPI_SUPPORT
-		case _SMS4_:
-			EncryptionHeadOverhead = 18;
-			break;
-#endif			
 		default:
 			EncryptionHeadOverhead = 0;
 	}
@@ -664,11 +656,7 @@ static void ConstructGTKResponse(
 	SetSeqNum(pwlanhdr, 0);
 	SetDuration(pwlanhdr, 0);
 
-#ifdef CONFIG_WAPI_SUPPORT
- 	*pLength = sMacHdrLng;
-#else
 	*pLength = 24;
-#endif //CONFIG_WAPI_SUPPORT
 
 	//-------------------------------------------------------------------------
 	// Security Header: leave space for it if necessary.
@@ -686,11 +674,6 @@ static void ConstructGTKResponse(
 		case _AES_:
 			EncryptionHeadOverhead = 8;
 			break;
-#ifdef CONFIG_WAPI_SUPPORT
-		case _SMS4_:
-			EncryptionHeadOverhead = 18;
-			break;
-#endif //CONFIG_WAPI_SUPPORT
 		default:
 			EncryptionHeadOverhead = 0;
 	}
@@ -789,11 +772,9 @@ static void ConstructProbeRsp(_adapter *
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	u8 *pwps_ie;
 	uint wps_ielen;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 	//DBG_871X("%s\n", __FUNCTION__);
 
@@ -1273,37 +1254,13 @@ _func_enter_;
 _func_exit_;
 }
 
-void rtl8723b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param)
-{
-	u8 u1H2CBtMpOperParm[H2C_BTMP_OPER_LEN+1]={0};
-
-_func_enter_;
-
-	DBG_8192C("%s: idx=%d ver=%d reqnum=%d param1=0x%02x param2=0x%02x\n", __FUNCTION__, idx, ver, reqnum, param[0], param[1]);
-
-	SET_8723B_H2CCMD_BT_MPOPER_VER(u1H2CBtMpOperParm, ver);
-	SET_8723B_H2CCMD_BT_MPOPER_REQNUM(u1H2CBtMpOperParm, reqnum);
-	SET_8723B_H2CCMD_BT_MPOPER_IDX(u1H2CBtMpOperParm, idx);
-	SET_8723B_H2CCMD_BT_MPOPER_PARAM1(u1H2CBtMpOperParm, param[0]);
-	SET_8723B_H2CCMD_BT_MPOPER_PARAM2(u1H2CBtMpOperParm, param[1]);
-	SET_8723B_H2CCMD_BT_MPOPER_PARAM3(u1H2CBtMpOperParm, param[2]);
-
-	RT_PRINT_DATA(_module_hal_init_c_, _drv_always_, "u1H2CBtMpOperParm:", u1H2CBtMpOperParm, H2C_BTMP_OPER_LEN);
-
-	FillH2CCmd8723B(padapter, H2C_8723B_BT_MP_OPER, H2C_BTMP_OPER_LEN+1, u1H2CBtMpOperParm);
-_func_exit_;
-}
-
 void rtl8723b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param)
 {
-	//u8 cmd_param; //BIT0:enable, BIT1:NoConnect32k
+	//BIT0:enable, BIT1:NoConnect32k
 
 	DBG_871X("%s()\n", __func__);
 
-	cmd_param = cmd_param;
-
 	FillH2CCmd8723B(padapter, H2C_8723B_FWLPS_IN_IPS_, 1, &cmd_param);
-
 }
 
 #ifdef CONFIG_WOWLAN
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723b_dm.c linux/3rdparty/rtl8723bs/hal/rtl8723b_dm.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723b_dm.c	2015-05-10 14:36:05.712668391 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723b_dm.c	2015-05-07 17:46:55.000000000 +0300
@@ -42,36 +42,6 @@ dm_CheckStatistics(
 	)
 {
 }
-#ifdef CONFIG_SUPPORT_HW_WPS_PBC
-static void dm_CheckPbcGPIO(_adapter *padapter)
-{
-	u8	tmp1byte;
-	u8	bPbcPressed = false;
-
-	if(!padapter->registrypriv.hw_wps_pbc)
-		return;
-
-	tmp1byte = rtw_read8(padapter, GPIO_IN);
-	//RT_TRACE(COMP_IO, DBG_TRACE, ("dm_CheckPbcGPIO - %x\n", tmp1byte));
-
-	if (tmp1byte == 0xff || padapter->init_adpt_in_progress)
-		return ;
-
-	if((tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)==0)
-	{
-		bPbcPressed = true;
-	}
-
-	if( true == bPbcPressed)
-	{
-		// Here we only set bPbcPressed to true
-		// After trigger PBC, the variable will be set to false
-		DBG_8192C("CheckPbcGPIO - PBC is pressed\n");
-		rtw_request_wps_pbc_event(padapter);
-	}
-}
-#endif //#ifdef CONFIG_SUPPORT_HW_WPS_PBC
-
 //============================================================
 // functions
 //============================================================
@@ -277,17 +247,6 @@ rtl8723b_HalDmWatchDog(
 	}
 
 skip_dm:
-
-	// Check GPIO to determine current RF on/off and Pbc status.
-	// Check Hardware Radio ON/OFF or not
-	//if(Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
-	//{
-		//RTPRINT(FPWR, PWRHW, ("dm_CheckRfCtrlGPIO \n"));
-	//	dm_CheckRfCtrlGPIO(Adapter);
-	//}
-#ifdef CONFIG_SUPPORT_HW_WPS_PBC
-	dm_CheckPbcGPIO(Adapter);
-#endif
 	return;
 }
 
@@ -386,14 +345,5 @@ void rtl8723b_init_dm_priv(IN PADAPTER A
 	PDM_ODM_T 		podmpriv = &pHalData->odmpriv;
 	memset(pdmpriv, 0, sizeof(struct dm_priv));
 	Init_ODM_ComInfo_8723b(Adapter);
-	ODM_InitAllTimers(podmpriv );
-}
-
-void rtl8723b_deinit_dm_priv(IN PADAPTER Adapter)
-{
-	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	PDM_ODM_T 		podmpriv = &pHalData->odmpriv;
-	ODM_CancelAllTimers(podmpriv);
 }
 
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723b_hal_init.c linux/3rdparty/rtl8723bs/hal/rtl8723b_hal_init.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723b_hal_init.c	2015-05-10 14:36:05.715668424 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723b_hal_init.c	2015-05-07 17:46:55.000000000 +0300
@@ -557,9 +557,9 @@ fwdl_stat:
 
 exit:
 	if (pFirmware)
-		rtw_mfree((u8*)pFirmware, sizeof(RT_FIRMWARE_8723B));
+		kfree((u8*)pFirmware);
 	if (pBTFirmware)
-		rtw_mfree((u8*)pBTFirmware, sizeof(RT_FIRMWARE_8723B));
+		kfree((u8*)pBTFirmware);
 	DBG_871X(" <=== rtl8723b_FirmwareDownload()\n");
 	return rtStatus;
 }
@@ -971,7 +971,6 @@ hal_ReadEFuse_WiFi(
 if(0)
 {
 	for(i=0; i<256; i++)
-		//ReadEFuseByte(padapter, i, &efuseTbl[i], false);
 		efuse_OneByteRead(padapter, i, &efuseTbl[i], false);
 	DBG_871X("Efuse Content:\n");
 	for(i=0; i<256; i++)
@@ -990,7 +989,6 @@ if(0)
 
 	while (AVAILABLE_EFUSE_ADDR(eFuse_Addr))
 	{
-		//ReadEFuseByte(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
 		efuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
 		if (efuseHeader == 0xFF)
 		{
@@ -1005,7 +1003,6 @@ if(0)
 			offset = GET_HDR_OFFSET_2_0(efuseHeader);
 			//DBG_8192C("%s: extended header offset=0x%X\n", __FUNCTION__, offset);
 
-			//ReadEFuseByte(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);
 			efuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);
 			//DBG_8192C("%s: efuse[0x%X]=0x%02X\n", __FUNCTION__, eFuse_Addr-1, efuseExtHdr);
 			if (ALL_WORDS_DISABLED(efuseExtHdr))
@@ -1035,12 +1032,10 @@ if(0)
 				// Check word enable condition in the section
 				if (!(wden & (0x01<<i)))
 				{
-					//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 					efuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 //					DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, eFuse_Addr-1, efuseData);
 					efuseTbl[addr] = efuseData;
 
-					//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 					efuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 //					DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, eFuse_Addr-1, efuseData);
 					efuseTbl[addr+1] = efuseData;
@@ -1091,7 +1086,7 @@ if(1)
 	}
 
 	if (efuseTbl)
-		rtw_mfree(efuseTbl, EFUSE_MAX_MAP_LEN);
+		kfree(efuseTbl);
 }
 
 static void
@@ -1147,7 +1142,6 @@ hal_ReadEFuse_BT(
 
 		while (AVAILABLE_EFUSE_ADDR(eFuse_Addr))
 		{
-			//ReadEFuseByte(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
 			efuse_OneByteRead(padapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
 			if (efuseHeader == 0xFF) break;
 			DBG_8192C("%s: efuse[%#X]=0x%02x (header)\n", __FUNCTION__, (((bank-1)*EFUSE_REAL_CONTENT_LEN_8723B)+eFuse_Addr-1), efuseHeader);
@@ -1158,7 +1152,6 @@ hal_ReadEFuse_BT(
 				offset = GET_HDR_OFFSET_2_0(efuseHeader);
 				DBG_8192C("%s: extended header offset_2_0=0x%X\n", __FUNCTION__, offset);
 
-				//ReadEFuseByte(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);
 				efuse_OneByteRead(padapter, eFuse_Addr++, &efuseExtHdr, bPseudoTest);
 				DBG_8192C("%s: efuse[%#X]=0x%02x (ext header)\n", __FUNCTION__, (((bank-1)*EFUSE_REAL_CONTENT_LEN_8723B)+eFuse_Addr-1), efuseExtHdr);
 				if (ALL_WORDS_DISABLED(efuseExtHdr))
@@ -1188,12 +1181,10 @@ hal_ReadEFuse_BT(
 					// Check word enable condition in the section
 					if (!(wden & (0x01<<i)))
 					{
-						//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 						efuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 						DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, eFuse_Addr-1, efuseData);
 						efuseTbl[addr] = efuseData;
 
-						//ReadEFuseByte(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 						efuse_OneByteRead(padapter, eFuse_Addr++, &efuseData, bPseudoTest);
 						DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, eFuse_Addr-1, efuseData);
 						efuseTbl[addr+1] = efuseData;
@@ -1245,7 +1236,7 @@ hal_ReadEFuse_BT(
 
 exit:
 	if (efuseTbl)
-		rtw_mfree(efuseTbl, EFUSE_BT_MAP_LEN);
+		kfree(efuseTbl);
 }
 
 static void
@@ -1300,15 +1291,11 @@ hal_EfuseGetCurrentSize_WiFi(
 	count = 0;
 	while (AVAILABLE_EFUSE_ADDR(efuse_addr))
 	{
-#if 1
 		if (efuse_OneByteRead(padapter, efuse_addr, &efuse_data, bPseudoTest) == false)
 		{
 			DBG_8192C(KERN_ERR "%s: efuse_OneByteRead Fail! addr=0x%X !!\n", __FUNCTION__, efuse_addr);
 			goto error;
 		}
-#else
-		ReadEFuseByte(padapter, efuse_addr, &efuse_data, bPseudoTest);
-#endif
 
 		if (efuse_data == 0xFF) break;
 
@@ -1695,12 +1682,10 @@ Hal_EfusePgPacketRead(
 				// Check word enable condition in the section
 				if (!(hworden & (0x01<<i)))
 				{
-					//ReadEFuseByte(padapter, efuse_addr++, &efuse_data, bPseudoTest);
 					efuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);
 //					DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, efuse_addr+tmpidx, efuse_data);
 					data[i*2] = efuse_data;
 
-					//ReadEFuseByte(padapter, efuse_addr++, &efuse_data, bPseudoTest);
 					efuse_OneByteRead(padapter, efuse_addr++, &efuse_data, bPseudoTest);
 //					DBG_8192C("%s: efuse[%#X]=0x%02X\n", __FUNCTION__, efuse_addr+tmpidx, efuse_data);
 					data[(i*2)+1] = efuse_data;
@@ -2208,15 +2193,6 @@ void rtl8723b_InitBeaconParameters(PADAP
 	pHalData->RegCR_1 = rtw_read8(padapter, REG_CR+1);
 }
 
-void rtl8723b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode)
-{
-#ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
-	rtw_write8(padapter, REG_BCN_MAX_ERR, 0xFF);
-#else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
-#endif
-}
-
 void	_InitBurstPktLen_8723BS(PADAPTER Adapter)
 {
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
@@ -2453,7 +2429,6 @@ void rtl8723b_set_hal_ops(struct hal_ops
 	pHalFunc->free_hal_data = &rtl8723b_free_hal_data;
 
 	pHalFunc->dm_init = &rtl8723b_init_dm_priv;
-	pHalFunc->dm_deinit = &rtl8723b_deinit_dm_priv;
 
 	pHalFunc->read_chip_version = &rtl8723b_read_chip_version;
 
@@ -2519,35 +2494,6 @@ void rtl8723b_InitAntenna_Selection(PADA
 	rtw_write8(padapter, REG_LEDCFG2, val);
 }
 
-void rtl8723b_CheckAntenna_Selection(PADAPTER padapter)
-{
-	PHAL_DATA_TYPE pHalData;
-	u8 val;
-
-
-	pHalData = GET_HAL_DATA(padapter);
-
-	val = rtw_read8(padapter, REG_LEDCFG2);
-	// Let 8051 take control antenna settting
-	if(!(val &BIT(7))){
-		val |= BIT(7); // DPDT_SEL_EN, 0x4C[23]
-		rtw_write8(padapter, REG_LEDCFG2, val);
-	}
-}
-void rtl8723b_DeinitAntenna_Selection(PADAPTER padapter)
-{
-	PHAL_DATA_TYPE pHalData;
-	u8 val;
-
-
-	pHalData = GET_HAL_DATA(padapter);
-	val = rtw_read8(padapter, REG_LEDCFG2);
-	// Let 8051 take control antenna settting
-	val &= ~BIT(7); // DPDT_SEL_EN, clear 0x4C[23]
-	rtw_write8(padapter, REG_LEDCFG2, val);
-
-}
-
 void rtl8723b_init_default_value(PADAPTER padapter)
 {
 	PHAL_DATA_TYPE pHalData;
@@ -2655,319 +2601,6 @@ s32 rtl8723b_InitLLTTable(PADAPTER padap
 	return ret;
 }
 
-static void _DisableGPIO(PADAPTER	padapter)
-{
-/***************************************
-j. GPIO_PIN_CTRL 0x44[31:0]=0x000		//
-k.Value = GPIO_PIN_CTRL[7:0]
-l. GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); //write external PIN level
-m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
-n. LEDCFG 0x4C[15:0] = 0x8080
-***************************************/
-	u8	value8;
-	u16	value16;
-	u32	value32;
-	u32	u4bTmp;
-
-
-	//1. Disable GPIO[7:0]
-	rtw_write16(padapter, REG_GPIO_PIN_CTRL+2, 0x0000);
-	value32 = rtw_read32(padapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
-	u4bTmp = value32 & 0x000000FF;
-	value32 |= ((u4bTmp<<8) | 0x00FF0000);
-	rtw_write32(padapter, REG_GPIO_PIN_CTRL, value32);
-
-	//2. Disable GPIO[10:8]
-	rtw_write8(padapter, REG_MAC_PINMUX_CFG, 0x00);
-	value16 = rtw_read16(padapter, REG_GPIO_IO_SEL) & 0xFF0F;
-	value8 = (u8) (value16&0x000F);
-	value16 |= ((value8<<4) | 0x0780);
-	rtw_write16(padapter, REG_GPIO_IO_SEL, value16);
-
-	//3. Disable LED0 & 1
-	rtw_write16(padapter, REG_LEDCFG0, 0x8080);
-//	RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
-} //end of _DisableGPIO()
-
-static void _DisableRFAFEAndResetBB8192C(PADAPTER padapter)
-{
-/**************************************
-a.	TXPAUSE 0x522[7:0] = 0xFF             //Pause MAC TX queue
-b.	RF path 0 offset 0x00 = 0x00            // disable RF
-c. 	APSD_CTRL 0x600[7:0] = 0x40
-d.	SYS_FUNC_EN 0x02[7:0] = 0x16		//reset BB state machine
-e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset BB state machine
-***************************************/
-    	u8 eRFPath = 0, value8 = 0;
-
-	rtw_write8(padapter, REG_TXPAUSE, 0xFF);
-
-	PHY_SetRFReg(padapter, (RF_PATH)eRFPath, 0x0, bMaskByte0, 0x0);
-
-	value8 |= APSDOFF;
-	rtw_write8(padapter, REG_APSD_CTRL, value8);//0x40
-
-	// Set BB reset at first
-	value8 = 0 ;
-	value8 |= (FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtw_write8(padapter, REG_SYS_FUNC_EN, value8 );//0x16
-
-	// Set global reset.
-	value8 &= ~FEN_BB_GLB_RSTn;
-	rtw_write8(padapter, REG_SYS_FUNC_EN, value8); //0x14
-
-	// 2010/08/12 MH We need to set BB/GLBAL reset to save power for SS mode.
-
-//	RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n"));
-}
-
-static void _DisableRFAFEAndResetBB(PADAPTER padapter)
-{
-	_DisableRFAFEAndResetBB8192C(padapter);
-}
-
-static void _ResetDigitalProcedure1_92C(PADAPTER padapter, bool bWithoutHWSM)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-
-	if (IS_FW_81xxC(padapter) && (pHalData->FirmwareVersion <= 0x20))
-	{
-		/*****************************
-		f.	MCUFWDL 0x80[7:0]=0				// reset MCU ready status
-		g.	SYS_FUNC_EN 0x02[10]= 0			// reset MCU register, (8051 reset)
-		h.	SYS_FUNC_EN 0x02[15-12]= 5		// reset MAC register, DCORE
-		i.     SYS_FUNC_EN 0x02[10]= 1			// enable MCU register, (8051 enable)
-		******************************/
-			u16 valu16 = 0;
-			rtw_write8(padapter, REG_MCUFWDL, 0);
-
-			valu16 = rtw_read16(padapter, REG_SYS_FUNC_EN);
-			rtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 & (~FEN_CPUEN)));//reset MCU ,8051
-
-			valu16 = rtw_read16(padapter, REG_SYS_FUNC_EN)&0x0FFF;
-			rtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 |(FEN_HWPDN|FEN_ELDR)));//reset MAC
-
-			valu16 = rtw_read16(padapter, REG_SYS_FUNC_EN);
-			rtw_write16(padapter, REG_SYS_FUNC_EN, (valu16 | FEN_CPUEN));//enable MCU ,8051
-	}
-	else
-	{
-		u8 retry_cnts = 0;
-
-		// 2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to
-		// enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because
-		// we will init FW when power on again.
-		//if(!pDevice->RegUsbSS)
-		{	// If we want to SS mode, we can not reset 8051.
-			if(rtw_read8(padapter, REG_MCUFWDL) & BIT1)
-			{ //IF fw in RAM code, do reset
-
-
-				if(padapter->bFWReady)
-				{
-					// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
-					// HRCV INT to influence 8051 reset.
-					rtw_write8(padapter, REG_FWIMR, 0x20);
-					// 2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation.
-					rtw_write8(padapter, REG_FTIMR, 0x00);
-					rtw_write8(padapter, REG_FSIMR, 0x00);
-
-					rtw_write8(padapter, REG_HMETFR+3, 0x20);//8051 reset by self
-
-					while( (retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(padapter, REG_SYS_FUNC_EN)))
-					{
-						udelay(50);//us
-						// 2010/08/25 For test only We keep on reset 5051 to prevent fail.
-						//rtw_write8(padapter, REG_HMETFR+3, 0x20);//8051 reset by self
-					}
-//					RT_ASSERT((retry_cnts < 100), ("8051 reset failed!\n"));
-
-					if (retry_cnts >= 100)
-					{
-						// if 8051 reset fail we trigger GPIO 0 for LA
-						//rtw_write32(	padapter,
-						//						REG_GPIO_PIN_CTRL,
-						//						0x00010100);
-						// 2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly.
-						rtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x50);	//Reset MAC and Enable 8051
-						mdelay(10);
-					}
-//					else
-//					RT_TRACE(COMP_INIT, DBG_LOUD, ("=====> 8051 reset success (%d) .\n",retry_cnts));
-				}
-			}
-//			else
-//			{
-//				RT_TRACE(COMP_INIT, DBG_LOUD, ("=====> 8051 in ROM.\n"));
-//			}
-			rtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
-			rtw_write8(padapter, REG_MCUFWDL, 0);
-		}
-	}
-
-	//if(pDevice->RegUsbSS)
-		//bWithoutHWSM = true;	// Sugest by Filen and Issau.
-
-	if(bWithoutHWSM)
-	{
-		//HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
-	/*****************************
-		Without HW auto state machine
-	g.	SYS_CLKR 0x08[15:0] = 0x30A3			//disable MAC clock
-	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
-	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
-	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			// isolated digital to PON
-	******************************/
-		//rtw_write16(padapter, REG_SYS_CLKR, 0x30A3);
-		//if(!pDevice->RegUsbSS)
-		// 2011/01/26 MH SD4 Scott suggest to fix UNC-B cut bug.
-		//if (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))
-			//rtw_write16(padapter, REG_SYS_CLKR, (0x70A3|BIT6));  //modify to 0x70A3 by Scott.
-		//else
-			rtw_write16(padapter, REG_SYS_CLKR, 0x70A3);  //modify to 0x70A3 by Scott.
-		rtw_write8(padapter, REG_AFE_PLL_CTRL, 0x80);
-		rtw_write16(padapter, REG_AFE_XTAL_CTRL, 0x880F);
-		//if(!pDevice->RegUsbSS)
-			rtw_write8(padapter, REG_SYS_ISO_CTRL, 0xF9);
-	}
-	else
-	{
-		// Disable all RF/BB power
-		rtw_write8(padapter, REG_RF_CTRL, 0x00);
-	}
-//	RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n"));
-
-}
-
-static void _ResetDigitalProcedure1(PADAPTER padapter, bool bWithoutHWSM)
-{
-	_ResetDigitalProcedure1_92C(padapter, bWithoutHWSM);
-}
-
-static void _ResetDigitalProcedure2(PADAPTER padapter)
-{
-	//HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
-/*****************************
-k.	SYS_FUNC_EN 0x03[7:0] = 0x44			// disable ELDR runction
-l.	SYS_CLKR 0x08[15:0] = 0x3083			// disable ELDR clock
-m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			// isolated ELDR to PON
-******************************/
-	//rtw_write8(padapter, REG_SYS_FUNC_EN+1, 0x44); //marked by Scott.
-	// 2011/01/26 MH SD4 Scott suggest to fix UNC-B cut bug.
-	//if (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))
-		//rtw_write16(padapter, REG_SYS_CLKR, 0x70a3|BIT6);
-	//else
-		rtw_write16(padapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.
-	rtw_write8(padapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.
-}
-
-static void _DisableAnalog(PADAPTER padapter, bool bWithoutHWSM)
-{
-	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
-	u16 value16 = 0;
-	u8 value8 = 0;
-
-
-	if (bWithoutHWSM)
-	{
-		/*****************************
-		n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
-		o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
-		r.	When driver call disable, the ASIC will turn off remaining clock automatically
-		******************************/
-
-		rtw_write8(padapter, REG_LDOA15_CTRL, 0x04);
-		//rtw_write8(padapter, REG_LDOV12D_CTRL, 0x54);
-
-		value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
-		value8 &= (~LDV12_EN);
-		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
-//		RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
-	}
-
-	/*****************************
-	h.	SPS0_CTRL 0x11[7:0] = 0x23			//enter PFM mode
-	i.	APS_FSMCO 0x04[15:0] = 0x4802		// set USB suspend
-	******************************/
-	value8 = 0x23;
-
-	rtw_write8(padapter, REG_SPS0_CTRL, value8);
-
-	if(bWithoutHWSM)
-	{
-		//value16 |= (APDM_HOST | /*AFSM_HSUS |*/PFM_ALDN);
-		// 2010/08/31 According to Filen description, we need to use HW to shut down 8051 automatically.
-		// Becasue suspend operatione need the asistance of 8051 to wait for 3ms.
-		value16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);
-	}
-	else
-	{
-		value16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);
-	}
-
-	rtw_write16(padapter, REG_APS_FSMCO, value16);//0x4802
-
-	rtw_write8(padapter, REG_RSV_CTRL, 0x0e);
-
-//	RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16));
-}
-
-// HW Auto state machine
-s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU)
-{
-	int rtStatus = _SUCCESS;
-
-
-	if (padapter->bSurpriseRemoved){
-		return rtStatus;
-	}
-	//==== RF Off Sequence ====
-	_DisableRFAFEAndResetBB(padapter);
-
-	//  ==== Reset digital sequence   ======
-	_ResetDigitalProcedure1(padapter, false);
-
-	//  ==== Pull GPIO PIN to balance level and LED control ======
-	_DisableGPIO(padapter);
-
-	//  ==== Disable analog sequence ===
-	_DisableAnalog(padapter, false);
-
-	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("======> Card disable finished.\n"));
-
-	return rtStatus;
-}
-
-// without HW Auto state machine
-s32 CardDisableWithoutHWSM(PADAPTER padapter)
-{
-	s32 rtStatus = _SUCCESS;
-
-
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Card Disable Without HWSM .\n"));
-	if (padapter->bSurpriseRemoved) {
-		return rtStatus;
-	}
-
-	//==== RF Off Sequence ====
-	_DisableRFAFEAndResetBB(padapter);
-
-	//  ==== Reset digital sequence   ======
-	_ResetDigitalProcedure1(padapter, true);
-
-	//  ==== Pull GPIO PIN to balance level and LED control ======
-	_DisableGPIO(padapter);
-
-	//  ==== Reset digital sequence   ======
-	_ResetDigitalProcedure2(padapter);
-
-	//  ==== Disable analog sequence ===
-	_DisableAnalog(padapter, true);
-
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n"));
-	return rtStatus;
-}
-
 static bool
 Hal_GetChnlGroup8723B(
 	IN	u8 Channel,
@@ -3710,11 +3343,6 @@ static u8 fill_txdesc_sectype(struct pkt
 				sectype = 1;
 				break;
 
-#ifdef CONFIG_WAPI_SUPPORT
-			case _SMS4_:
-				sectype = 2;
-				break;
-#endif
 			case _AES_:
 				sectype = 3;
 				break;
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723b_phycfg.c linux/3rdparty/rtl8723bs/hal/rtl8723b_phycfg.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723b_phycfg.c	2015-05-10 14:36:05.715668424 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723b_phycfg.c	2015-05-07 17:46:55.000000000 +0300
@@ -291,11 +291,6 @@ phy_RFSerialWrite_8723B(
 	Offset &= 0xff;
 
 	//
-	// Shadow Update
-	//
-	//PHY_RFShadowWrite(Adapter, eRFPath, Offset, Data);
-
-	//
 	// Switch page for 8256 RF IC
 	//
 	NewOffset = Offset;
@@ -661,31 +656,6 @@ PHY_RFConfig8723B(
 	return rtStatus;
 }
 
-/*-----------------------------------------------------------------------------
- * Function:    PHY_ConfigRFWithParaFile()
- *
- * Overview:    This function read RF parameters from general file format, and do RF 3-wire
- *
- * Input:      	PADAPTER			Adapter
- *			s8 * 				pFileName
- *			RF_PATH				eRFPath
- *
- * Output:      NONE
- *
- * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
- * Note:		Delay may be required for RF configuration
- *---------------------------------------------------------------------------*/
-int
-PHY_ConfigRFWithParaFile_8723B(
-	IN	PADAPTER			Adapter,
-	IN	u8* 				pFileName,
-	RF_PATH				eRFPath
-)
-{
-	return _SUCCESS;
-}
-
 /**************************************************************************************************************
  *   Description: 
  *       The low-level interface to set TxAGC , called by both MP and Normal Driver.
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723b_rxdesc.c linux/3rdparty/rtl8723bs/hal/rtl8723b_rxdesc.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723b_rxdesc.c	2015-05-10 14:36:05.716668435 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723b_rxdesc.c	2015-05-07 17:46:55.000000000 +0300
@@ -92,45 +92,3 @@ void rtl8723b_process_phy_info(_adapter
 	#endif
 
 }
-
-void rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc)
-{
-	struct rx_pkt_attrib	*pattrib = &precvframe->u.hdr.attrib;
-
-	memset(pattrib, 0, sizeof(struct rx_pkt_attrib));
-
-	//Offset 0
-	pattrib->pkt_len = (u16)GET_RX_STATUS_DESC_PKT_LEN_8723B(pdesc);//(le32_to_cpu(pdesc->rxdw0)&0x00003fff)
-	pattrib->crc_err = (u8)GET_RX_STATUS_DESC_CRC32_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 14) & 0x1);
-	pattrib->icv_err = (u8)GET_RX_STATUS_DESC_ICV_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 15) & 0x1);
-	pattrib->drvinfo_sz = (u8)GET_RX_STATUS_DESC_DRVINFO_SIZE_8723B(pdesc) * 8;//((le32_to_cpu(pdesc->rxdw0) >> 16) & 0xf) * 8;//uint 2^3 = 8 bytes
-	pattrib->encrypt = (u8)GET_RX_STATUS_DESC_SECURITY_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 20) & 0x7);
-	pattrib->qos = (u8)GET_RX_STATUS_DESC_QOS_8723B(pdesc);//(( le32_to_cpu( pdesc->rxdw0 ) >> 23) & 0x1);// Qos data, wireless lan header length is 26
-	pattrib->shift_sz = (u8)GET_RX_STATUS_DESC_SHIFT_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 24) & 0x3);
-	pattrib->physt = (u8)GET_RX_STATUS_DESC_PHY_STATUS_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 26) & 0x1);
-	pattrib->bdecrypted = !GET_RX_STATUS_DESC_SWDEC_8723B(pdesc);//(le32_to_cpu(pdesc->rxdw0) & BIT(27))? 0:1;
-
-	//Offset 4
-	pattrib->priority = (u8)GET_RX_STATUS_DESC_TID_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 8) & 0xf);
-	pattrib->mdata = (u8)GET_RX_STATUS_DESC_MORE_DATA_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 26) & 0x1);
-	pattrib->mfrag = (u8)GET_RX_STATUS_DESC_MORE_FRAG_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 27) & 0x1);//more fragment bit
-
-	//Offset 8
-	pattrib->seq_num = (u16)GET_RX_STATUS_DESC_SEQ_8723B(pdesc);//(le32_to_cpu(pdesc->rxdw2) & 0x00000fff);
-	pattrib->frag_num = (u8)GET_RX_STATUS_DESC_FRAG_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw2) >> 12) & 0xf);//fragmentation number
-
-	if (GET_RX_STATUS_DESC_RPT_SEL_8723B(pdesc))
-		pattrib->pkt_rpt_type = C2H_PACKET;
-	else
-		pattrib->pkt_rpt_type = NORMAL_RX;
-
-	//Offset 12
-	pattrib->data_rate=(u8)GET_RX_STATUS_DESC_RX_RATE_8723B(pdesc);//((le32_to_cpu(pdesc->rxdw3))&0x7f);
-
-	//Offset 16
-	//Offset 20
-
-}
-
-
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_led.c linux/3rdparty/rtl8723bs/hal/rtl8723bs_led.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_led.c	2015-05-10 14:36:05.716668435 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723bs_led.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,58 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#define _RTL8723BS_LED_C_
-
-#include "rtl8723b_hal.h"
-
-//================================================================================
-// LED object.
-//================================================================================
-
-//================================================================================
-// Interface to manipulate LED objects.
-//================================================================================
-
-//================================================================================
-// Default LED behavior.
-//================================================================================
-
-//
-//	Description:
-//		Initialize all LED_871x objects.
-//
-void
-rtl8723bs_InitSwLeds(
-	_adapter	*padapter
-	)
-{
-}
-
-
-//
-//	Description:
-//		DeInitialize all LED_819xUsb objects.
-//
-void
-rtl8723bs_DeInitSwLeds(
-	_adapter	*padapter
-	)
-{
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_recv.c linux/3rdparty/rtl8723bs/hal/rtl8723bs_recv.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_recv.c	2015-05-10 14:36:05.716668435 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723bs_recv.c	2015-05-07 17:46:55.000000000 +0300
@@ -24,7 +24,7 @@
 
 static s32 initrecvbuf(struct recv_buf *precvbuf, PADAPTER padapter)
 {
-	_rtw_init_listhead(&precvbuf->list);
+	INIT_LIST_HEAD(&precvbuf->list);
 	spin_lock_init(&precvbuf->recvbuf_lock);
 
 	precvbuf->adapter = padapter;
@@ -137,10 +137,10 @@ static void update_recvframe_phyinfo(
 	pkt_info.DataRate = pattrib->data_rate;
 
 	//rtl8723b_query_rx_phy_status(precvframe, pphy_status);
-	//_enter_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+	//spin_lock_bh(&pHalData->odm_stainfo_lock);
 	ODM_PhyStatusQuery(&pHalData->odmpriv,pPHYInfo,(u8 *)pphy_status,&(pkt_info));
 	if(psta) psta->rssi = pattrib->phy_info.RecvSignalPower;
-	//_exit_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+	//spin_unlock_bh(&pHalData->odm_stainfo_lock);
 	precvframe->u.hdr.psta = NULL;
 	if (pkt_info.bPacketMatchBSSID &&
 		(check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true))
@@ -182,8 +182,8 @@ static void rtl8723bs_c2h_packet_handler
 
 	res = rtw_c2h_packet_wk_cmd(padapter, tmpBuf, length);
 
-	if (res == false && tmpBuf != NULL)
-			rtw_mfree(tmpBuf, length);
+	if (res == false)
+		kfree(tmpBuf);
 
 	//DBG_871X("-%s res(%d)\n", __func__, res);
 
@@ -434,10 +434,6 @@ s32 rtl8723bs_init_recv_priv(PADAPTER pa
 		if (res == _FAIL)
 			break;
 
-		res = rtw_os_recvbuf_resource_alloc(padapter, precvbuf);
-		if (res == _FAIL)
-			break;
-
 		if (precvbuf->pskb == NULL) {
 			SIZE_PTR tmpaddr=0;
 			SIZE_PTR alignment=0;
@@ -458,7 +454,7 @@ s32 rtl8723bs_init_recv_priv(PADAPTER pa
 			}
 		}
 
-		rtw_list_insert_tail(&precvbuf->list, &precvpriv->free_recv_buf_queue.queue);
+		list_add_tail(&precvbuf->list, &precvpriv->free_recv_buf_queue.queue);
 
 		precvbuf++;
 	}
@@ -481,7 +477,7 @@ initbuferror:
 		precvpriv->free_recv_buf_queue_cnt = 0;
 		for (i = 0; i < n ; i++)
 		{
-			rtw_list_delete(&precvbuf->list);
+			list_del_init(&precvbuf->list);
 			rtw_os_recvbuf_resource_free(padapter, precvbuf);
 			precvbuf++;
 		}
@@ -490,7 +486,7 @@ initbuferror:
 
 	if (precvpriv->pallocated_recv_buf) {
 		n = NR_RECVBUFF * sizeof(struct recv_buf) + 4;
-		rtw_mfree(precvpriv->pallocated_recv_buf, n);
+		kfree(precvpriv->pallocated_recv_buf);
 		precvpriv->pallocated_recv_buf = NULL;
 	}
 
@@ -523,7 +519,7 @@ void rtl8723bs_free_recv_priv(PADAPTER p
 		precvpriv->free_recv_buf_queue_cnt = 0;
 		for (i = 0; i < n ; i++)
 		{
-			rtw_list_delete(&precvbuf->list);
+			list_del_init(&precvbuf->list);
 			rtw_os_recvbuf_resource_free(padapter, precvbuf);
 			precvbuf++;
 		}
@@ -532,7 +528,7 @@ void rtl8723bs_free_recv_priv(PADAPTER p
 
 	if (precvpriv->pallocated_recv_buf) {
 		n = NR_RECVBUFF * sizeof(struct recv_buf) + 4;
-		rtw_mfree(precvpriv->pallocated_recv_buf, n);
+		kfree(precvpriv->pallocated_recv_buf);
 		precvpriv->pallocated_recv_buf = NULL;
 	}
 }
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_xmit.c linux/3rdparty/rtl8723bs/hal/rtl8723bs_xmit.c
--- linux/3rdparty/rtl8723bs.old/hal/rtl8723bs_xmit.c	2015-05-10 14:36:05.716668435 +0300
+++ linux/3rdparty/rtl8723bs/hal/rtl8723bs_xmit.c	2015-05-07 17:46:55.000000000 +0300
@@ -244,13 +244,13 @@ static s32 xmit_xmitframes(PADAPTER pada
 
 		max_xmit_len = rtw_hal_get_sdio_tx_max_length(padapter, inx[idx]);
 
-		_enter_critical_bh(&pxmitpriv->lock, &irql);
+		spin_lock_bh(&pxmitpriv->lock);
 		
 		sta_phead = get_list_head(phwxmit->sta_queue);
 		sta_plist = get_next(sta_phead);
 		//because stop_sta_xmit may delete sta_plist at any time
 		//so we should add lock here, or while loop can not exit
-		while (rtw_end_of_queue_search(sta_phead, sta_plist) == false)
+		while (sta_phead != sta_plist)
 		{
 			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
 			sta_plist = get_next(sta_plist);
@@ -265,7 +265,7 @@ static s32 xmit_xmitframes(PADAPTER pada
 
 			frame_phead = get_list_head(pframe_queue);
 
-			while (rtw_is_list_empty(frame_phead) == false)
+			while (list_empty(frame_phead) == false)
 			{
 				frame_plist = get_next(frame_phead);
 				pxmitframe = LIST_CONTAINOR(frame_plist, struct xmit_frame, list);
@@ -310,7 +310,6 @@ static s32 xmit_xmitframes(PADAPTER pada
 				}
 
 				// ok to send, remove frame from queue
-#ifdef CONFIG_AP_MODE
 				if (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true) {
 					if ((pxmitframe->attrib.psta->state & WIFI_SLEEP_STATE) &&
 						(pxmitframe->attrib.triggered == 0)) {
@@ -319,8 +318,8 @@ static s32 xmit_xmitframes(PADAPTER pada
 						break;
 					}
 				}
-#endif
-				rtw_list_delete(&pxmitframe->list);
+
+				list_del_init(&pxmitframe->list);
 				ptxservq->qcnt--;
 				phwxmit->accnt--;
 
@@ -357,12 +356,12 @@ static s32 xmit_xmitframes(PADAPTER pada
 				pxmitframe = NULL;
 			}
 
-			if (_rtw_queue_empty(pframe_queue) == true)
-				rtw_list_delete(&ptxservq->tx_pending);
+			if (list_empty(&pframe_queue->queue))
+				list_del_init(&ptxservq->tx_pending);
 
 			if (err) break;
 		}
-		_exit_critical_bh(&pxmitpriv->lock, &irql);
+		spin_unlock_bh(&pxmitpriv->lock);
 		
 		// dump xmit_buf to hw tx fifo
 		if (pxmitbuf)
@@ -422,9 +421,9 @@ next:
 		return _FAIL;
 	}
 
-	_enter_critical_bh(&pxmitpriv->lock, &irql);
+	spin_lock_bh(&pxmitpriv->lock);
 	ret = rtw_txframes_pending(padapter);
-	_exit_critical_bh(&pxmitpriv->lock, &irql);
+	spin_unlock_bh(&pxmitpriv->lock);
 	if (ret == 0) {
 		return _SUCCESS;
 	}
@@ -442,9 +441,9 @@ next:
 		goto next;
 	}
 
-	_enter_critical_bh(&pxmitpriv->lock, &irql);
+	spin_lock_bh(&pxmitpriv->lock);
 	ret = rtw_txframes_pending(padapter);
-	_exit_critical_bh(&pxmitpriv->lock, &irql);
+	spin_unlock_bh(&pxmitpriv->lock);
 	if (ret == 1) {
 		goto next;
 	}
@@ -559,9 +558,9 @@ s32 rtl8723bs_hal_xmit(PADAPTER padapter
 			rtw_issue_addbareq_cmd(padapter, pxmitframe);
 	}
 
-	_enter_critical_bh(&pxmitpriv->lock, &irql);
+	spin_lock_bh(&pxmitpriv->lock);
 	err = rtw_xmitframe_enqueue(padapter, pxmitframe);
-	_exit_critical_bh(&pxmitpriv->lock, &irql);
+	spin_unlock_bh(&pxmitpriv->lock);
 	if (err != _SUCCESS) {
 		RT_TRACE(_module_hal_xmit_c_, _drv_err_, ("rtl8723bs_hal_xmit: enqueue xmitframe fail\n"));
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
@@ -635,23 +634,23 @@ void rtl8723bs_free_xmit_priv(PADAPTER p
 	pxmitpriv = &padapter->xmitpriv;
 	pqueue = &pxmitpriv->pending_xmitbuf_queue;
 	phead = get_list_head(pqueue);
-	_rtw_init_listhead(&tmplist);
+	INIT_LIST_HEAD(&tmplist);
 
-	_enter_critical_bh(&pqueue->lock, &irql);
-	if (_rtw_queue_empty(pqueue) == false)
+	spin_lock_bh(&pqueue->lock);
+	if (!list_empty(&pqueue->queue))
 	{
 		// Insert tmplist to end of queue, and delete phead
 		// then tmplist become head of queue.
-		rtw_list_insert_tail(&tmplist, phead);
-		rtw_list_delete(phead);
+		list_add_tail(&tmplist, phead);
+		list_del_init(phead);
 	}
-	_exit_critical_bh(&pqueue->lock, &irql);
+	spin_unlock_bh(&pqueue->lock);
 
 	phead = &tmplist;
-	while (rtw_is_list_empty(phead) == false)
+	while (list_empty(phead) == false)
 	{
 		plist = get_next(phead);
-		rtw_list_delete(plist);
+		list_del_init(plist);
 
 		pxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);
 		rtw_free_xmitframe(pxmitpriv, (struct xmit_frame*)pxmitbuf->priv_data);
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/sdio_halinit.c linux/3rdparty/rtl8723bs/hal/sdio_halinit.c
--- linux/3rdparty/rtl8723bs.old/hal/sdio_halinit.c	2015-05-10 14:36:05.717668447 +0300
+++ linux/3rdparty/rtl8723bs/hal/sdio_halinit.c	2015-05-07 17:46:55.000000000 +0300
@@ -962,7 +962,6 @@ static u32 rtl8723bs_hal_init(PADAPTER p
 	_initSdioAggregationSetting(padapter);
 	_InitOperationMode(padapter);
 	rtl8723b_InitBeaconParameters(padapter);
-	rtl8723b_InitBeaconMaxError(padapter, true);
 	_InitInterrupt(padapter);
 	_InitBurstPktLen_8723BS(padapter);
 
@@ -970,17 +969,8 @@ static u32 rtl8723bs_hal_init(PADAPTER p
 	rtw_write8(padapter, REG_SECONDARY_CCA_CTRL_8723B, 0x3);	// CCA 
 	rtw_write8(padapter, 0x976, 0);	// hpfan_todo: 2nd CCA related
 
-#if defined(CONFIG_TX_MCAST2UNI)
-
-#ifdef CONFIG_TX_MCAST2UNI
 	rtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);	// unit: 256us. 256ms
 	rtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);	// unit: 256us. 256ms
-#else	// CONFIG_TX_MCAST2UNI
-	rtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x3000);	// unit: 256us. 3s
-	rtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
-#endif	// CONFIG_TX_MCAST2UNI
-#endif	// CONFIG_TX_MCAST2UNI
-
 
 	invalidate_cam_all(padapter);
 
@@ -1540,7 +1530,7 @@ static void SetHwReg8723BS(PADAPTER pada
 	PHAL_DATA_TYPE pHalData;
 	u8 val8;
 
-#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_MODE)
+#if defined(CONFIG_WOWLAN)
 	struct wowlan_ioctl_param *poidparam;
 	struct recv_buf *precvbuf;
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
@@ -1596,12 +1586,6 @@ _func_enter_;
 				case WOWLAN_ENABLE:
 					DBG_871X_LEVEL(_drv_always_, "WOWLAN_ENABLE\n");
 
-					#ifndef DYNAMIC_CAMID_ALLOC
-					val8 = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
-					rtw_write8(padapter, REG_SECCFG, val8);
-					DBG_871X_LEVEL(_drv_always_, "REG_SECCFG: %02x\n", rtw_read8(padapter, REG_SECCFG));
-					#endif
-
 					//backup data rate to register 0x8b for wowlan FW
 					rtw_write8(padapter, 0x8d, 1);
 					rtw_write8(padapter, 0x8c, 0);
@@ -1682,11 +1666,6 @@ _func_enter_;
 					else
 						DBG_871X("psta is null\n");
 
-					#ifndef DYNAMIC_CAMID_ALLOC
-					rtw_write8(padapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC
-					DBG_871X_LEVEL(_drv_always_, "REG_SECCFG: %02x\n", rtw_read8(padapter, REG_SECCFG));
-					#endif
-					
 					// 1. Read wakeup reason
 					pwrctl->wowlan_wake_reason = rtw_read8(padapter, REG_WOWLAN_WAKE_REASON);
 					DBG_871X_LEVEL(_drv_always_, "wakeup_reason: 0x%02x, mac_630=0x%08x, mac_634=0x%08x, mac_1c0=0x%08x, mac_1c4=0x%08x"
@@ -2033,9 +2012,6 @@ _func_enter_;
 	pHalFunc->init_recv_priv = &rtl8723bs_init_recv_priv;
 	pHalFunc->free_recv_priv = &rtl8723bs_free_recv_priv;
 
-	pHalFunc->InitSwLeds = &rtl8723bs_InitSwLeds;
-	pHalFunc->DeInitSwLeds = &rtl8723bs_DeInitSwLeds;
-
 	pHalFunc->init_default_value = &rtl8723bs_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8723bs_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8723BS;
diff -Nurp linux/3rdparty/rtl8723bs.old/hal/sdio_ops.c linux/3rdparty/rtl8723bs/hal/sdio_ops.c
--- linux/3rdparty/rtl8723bs.old/hal/sdio_ops.c	2015-05-10 14:36:05.718668458 +0300
+++ linux/3rdparty/rtl8723bs/hal/sdio_ops.c	2015-05-07 17:46:55.000000000 +0300
@@ -239,7 +239,7 @@ _func_enter_;
 		memcpy(&val, ptmpbuf+shift, 4);
 		val = le32_to_cpu(val);
 
-		rtw_mfree(ptmpbuf, 8);
+		kfree(ptmpbuf);
 	}
 
 _func_exit_;
@@ -288,7 +288,7 @@ _func_enter_;
 		err = sd_read(pintfhdl, ftaddr, n, ptmpbuf);
 		if (!err)
 			memcpy(pbuf, ptmpbuf+shift, cnt);
-		rtw_mfree(ptmpbuf, n);
+		kfree(ptmpbuf);
 	}
 
 _func_exit_;
@@ -409,12 +409,12 @@ _func_enter_;
 		if (NULL == ptmpbuf) return -1;
 		err = sd_read(pintfhdl, ftaddr, 4, ptmpbuf);
 		if (err) {
-			rtw_mfree(ptmpbuf, n);
+			kfree(ptmpbuf);
 			return err;
 		}
 		memcpy(ptmpbuf+shift, pbuf, cnt);
 		err = sd_write(pintfhdl, ftaddr, n, ptmpbuf);
-		rtw_mfree(ptmpbuf, n);
+		kfree(ptmpbuf);
 	}
 
 _func_exit_;
@@ -518,7 +518,7 @@ static u32 sdio_read_port(
 #ifdef SDIO_DYNAMIC_ALLOC_MEM
 	if ((oldcnt != cnt) && (oldmem)) {
 		memcpy(oldmem, mem, oldcnt);
-		rtw_mfree(mem, cnt);
+		kfree(mem);
 	}
 #endif
 
@@ -602,7 +602,7 @@ _func_exit_;
 /*
  * Todo: align address to 4 bytes.
  */
-s32 _sdio_local_read(
+static s32 _sdio_local_read(
 	PADAPTER	padapter,
 	u32			addr,
 	u32			cnt,
@@ -636,7 +636,7 @@ s32 _sdio_local_read(
 		memcpy(pbuf, ptmpbuf, cnt);
 
 	if (ptmpbuf)
-		rtw_mfree(ptmpbuf, n);
+		kfree(ptmpbuf);
 
 	return err;
 }
@@ -678,53 +678,7 @@ s32 sdio_local_read(
 		memcpy(pbuf, ptmpbuf, cnt);
 
 	if (ptmpbuf)
-		rtw_mfree(ptmpbuf, n);
-
-	return err;
-}
-
-/*
- * Todo: align address to 4 bytes.
- */
-s32 _sdio_local_write(
-	PADAPTER	padapter,
-	u32			addr,
-	u32			cnt,
-	u8			*pbuf)
-{
-	struct intf_hdl * pintfhdl;
-	u8 bMacPwrCtrlOn;
-	s32 err;
-	u8 *ptmpbuf;
-
-	if(addr & 0x3)
-		DBG_8192C("%s, address must be 4 bytes alignment\n", __FUNCTION__);
-
-	if(cnt  & 0x3)
-		DBG_8192C("%s, size must be the multiple of 4 \n", __FUNCTION__);
-
-	pintfhdl=&padapter->iopriv.intf;
-
-	HalSdioGetCmdAddr8723BSdio(padapter, SDIO_LOCAL_DEVICE_ID, addr, &addr);
-
-	rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
-	if ((false == bMacPwrCtrlOn)
-		|| (true == adapter_to_pwrctl(padapter)->bFwCurrentInPSMode))
-	{
-		err = _sd_cmd52_write(pintfhdl, addr, cnt, pbuf);
-		return err;
-	}
-
-	ptmpbuf = (u8*)rtw_malloc(cnt);
-	if (!ptmpbuf)
-		return (-1);
-
-	memcpy(ptmpbuf, pbuf, cnt);
-
-	err = _sd_write(pintfhdl, addr, cnt, ptmpbuf);
-
-	if (ptmpbuf)
-		rtw_mfree(ptmpbuf, cnt);
+		kfree(ptmpbuf);
 
 	return err;
 }
@@ -769,8 +723,7 @@ s32 sdio_local_write(
 
 	err = sd_write(pintfhdl, addr, cnt, ptmpbuf);
 
-	if (ptmpbuf)
-		rtw_mfree(ptmpbuf, cnt);
+	kfree(ptmpbuf);
 
 	return err;
 }
@@ -957,7 +910,7 @@ void ClearInterrupt8723BSdio(PADAPTER pa
 		sdio_local_write(padapter, SDIO_REG_HISR, 4, clear);
 	}
 
-	rtw_mfree(clear, 4);
+	kfree(clear);
 }
 #endif
 
@@ -1037,22 +990,6 @@ u8 CheckIPSStatus(PADAPTER padapter)
 		return false;
 }
 
-#ifdef CONFIG_WOWLAN
-void DisableInterruptButCpwm28723BSdio(PADAPTER padapter)
-{
-	u32 himr, tmp;
-
-	sdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
-	DBG_871X("DisableInterruptButCpwm28723BSdio(): Read SDIO_REG_HIMR: 0x%08x\n", tmp);
-	
-	himr = cpu_to_le32(SDIO_HIMR_DISABLED)|SDIO_HIMR_CPWM2_MSK;
-	sdio_local_write(padapter, SDIO_REG_HIMR, 4, (u8*)&himr);
-
-	sdio_local_read(padapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
-	DBG_871X("DisableInterruptButCpwm28723BSdio(): Read again SDIO_REG_HIMR: 0x%08x\n", tmp);
-}
-#endif //CONFIG_WOWLAN
-
 static struct recv_buf* sd_recv_rxfifo(PADAPTER padapter, u32 size)
 {
 	u32 readsize, ret;
@@ -1097,7 +1034,6 @@ static struct recv_buf* sd_recv_rxfifo(P
 
 	//3 3. read data from rxfifo
 	preadbuf = precvbuf->pskb->data;
-//	rtw_read_port(padapter, WLAN_RX0FF_DEVICE_ID, readsize, preadbuf);
 	ret = sdio_read_port(&padapter->iopriv.intf, WLAN_RX0FF_DEVICE_ID, readsize, preadbuf);
 	if (ret == _FAIL) {
 		RT_TRACE(_module_hci_ops_os_c_, _drv_err_, ("%s: read port FAIL!\n", __FUNCTION__));
@@ -1150,9 +1086,9 @@ void sd_int_dpc(PADAPTER padapter)
 		u8	freepage[4];
 
 		_sdio_local_read(padapter, SDIO_REG_FREE_TXPG, 4, freepage);
-		//_enter_critical_bh(&phal->SdioTxFIFOFreePageLock, &irql);
+		//spin_lock_bh(&phal->SdioTxFIFOFreePageLock);
 		//memcpy(phal->SdioTxFIFOFreePage, freepage, 4);
-		//_exit_critical_bh(&phal->SdioTxFIFOFreePageLock, &irql);
+		//spin_unlock_bh(&phal->SdioTxFIFOFreePageLock);
 		//DBG_871X("SDIO_HISR_AVAL, Tx Free Page = 0x%x%x%x%x\n",
 		//	freepage[0],
 		//	freepage[1],
@@ -1186,7 +1122,7 @@ void sd_int_dpc(PADAPTER padapter)
 			_sd_read(pintfhdl, addr, 4, status);
 			_sd_write(pintfhdl, addr, 4, status);
 			DBG_8192C("%s: SDIO_HISR_TXERR (0x%08x)\n", __func__, le32_to_cpu(*(u32*)status));
-			rtw_mfree(status, 4);
+			kfree(status);
 		} else {
 			DBG_8192C("%s: SDIO_HISR_TXERR, but can't allocate memory to read status!\n", __func__);
 		}
@@ -1212,7 +1148,7 @@ void sd_int_dpc(PADAPTER padapter)
 				if (c2h_id_filter_ccx_8723b((u8 *)c2h_evt)) {
 					/* Handle CCX report here */
 					rtw_hal_c2h_handler(padapter, (u8 *)c2h_evt);
-					rtw_mfree((u8*)c2h_evt, 16);
+					kfree((u8*)c2h_evt);
 				} else {
 					rtw_c2h_wk_cmd(padapter, (u8 *)c2h_evt);
 				}
@@ -1330,7 +1266,7 @@ u8 HalQueryTxBufferStatus8723BSdio(PADAP
 
 	NumOfFreePage = SdioLocalCmd53Read4Byte(padapter, SDIO_REG_FREE_TXPG);
 
-	//_enter_critical_bh(&phal->SdioTxFIFOFreePageLock, &irql);
+	//spin_lock_bh(&phal->SdioTxFIFOFreePageLock);
 	memcpy(phal->SdioTxFIFOFreePage, &NumOfFreePage, 4);
 	RT_TRACE(_module_hci_ops_c_, _drv_notice_,
 			("%s: Free page for HIQ(%#x),MIDQ(%#x),LOWQ(%#x),PUBQ(%#x)\n",
@@ -1339,7 +1275,7 @@ u8 HalQueryTxBufferStatus8723BSdio(PADAP
 			phal->SdioTxFIFOFreePage[MID_QUEUE_IDX],
 			phal->SdioTxFIFOFreePage[LOW_QUEUE_IDX],
 			phal->SdioTxFIFOFreePage[PUBLIC_QUEUE_IDX]));
-	//_exit_critical_bh(&phal->SdioTxFIFOFreePageLock, &irql);
+	//spin_unlock_bh(&phal->SdioTxFIFOFreePageLock);
 
 	return true;
 }
diff -Nurp linux/3rdparty/rtl8723bs.old/include/autoconf.h linux/3rdparty/rtl8723bs/include/autoconf.h
--- linux/3rdparty/rtl8723bs.old/include/autoconf.h	2015-05-10 14:36:05.718668458 +0300
+++ linux/3rdparty/rtl8723bs/include/autoconf.h	2015-05-07 17:46:55.000000000 +0300
@@ -23,11 +23,6 @@
  * Automatically generated C config: don't edit
  */
 
-#define AUTOCONF_INCLUDED
-
-#define RTL871X_MODULE_NAME "8723BS"
-#define DRV_NAME "rtl8723bs"
-
 //#define CONFIG_FILE_FWIMG
 
 /*
@@ -35,22 +30,6 @@
  */
 //#define CONFIG_DEBUG_CFG80211
 
-#define CONFIG_AP_MODE
-#ifdef CONFIG_AP_MODE
-	#define CONFIG_NATIVEAP_MLME
-	#define CONFIG_TX_MCAST2UNI		// Support IP multicast->unicast
-#endif
-
-#define CONFIG_LAYER2_ROAMING
-#define CONFIG_LAYER2_ROAMING_RESUME
-
-//#define CONFIG_80211D
-
-/*
- * Others
- */
-#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
-
 /*
  * Auto Config Section
  */
diff -Nurp linux/3rdparty/rtl8723bs.old/include/basic_types.h linux/3rdparty/rtl8723bs/include/basic_types.h
--- linux/3rdparty/rtl8723bs.old/include/basic_types.h	2015-05-10 14:36:05.718668458 +0300
+++ linux/3rdparty/rtl8723bs/include/basic_types.h	2015-05-07 17:46:55.000000000 +0300
@@ -32,9 +32,6 @@
 
 	#define FIELD_OFFSET(s,field)	((__kernel_ssize_t)&((s*)(0))->field)
 
-#define MEM_ALIGNMENT_OFFSET	(sizeof (__kernel_size_t))
-#define MEM_ALIGNMENT_PADDING	(sizeof(__kernel_size_t) - 1)
-
 #define SIZE_PTR __kernel_size_t
 #define SSIZE_PTR __kernel_ssize_t
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/drv_conf.h linux/3rdparty/rtl8723bs/include/drv_conf.h
--- linux/3rdparty/rtl8723bs.old/include/drv_conf.h	2015-05-10 14:36:05.718668458 +0300
+++ linux/3rdparty/rtl8723bs/include/drv_conf.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,43 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __DRV_CONF_H__
-#define __DRV_CONF_H__
-#include "autoconf.h"
-
-//About USB VENDOR REQ
-#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX) 
-	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
-	#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
-	#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-
-#define DYNAMIC_CAMID_ALLOC
-
-#ifndef CONFIG_RTW_HIQ_FILTER
-	#define CONFIG_RTW_HIQ_FILTER 1
-#endif
-
-//#include <rtl871x_byteorder.h>
-
-#endif // __DRV_CONF_H__
-
diff -Nurp linux/3rdparty/rtl8723bs.old/include/drv_types.h linux/3rdparty/rtl8723bs/include/drv_types.h
--- linux/3rdparty/rtl8723bs.old/include/drv_types.h	2015-05-10 14:36:05.719668469 +0300
+++ linux/3rdparty/rtl8723bs/include/drv_types.h	2015-05-07 17:46:55.000000000 +0300
@@ -27,7 +27,7 @@
 #ifndef __DRV_TYPES_H__
 #define __DRV_TYPES_H__
 
-#include <drv_conf.h>
+#include <autoconf.h>
 #include <basic_types.h>
 #include <osdep_service.h>
 #include <rtw_byteorder.h>
@@ -66,7 +66,6 @@ typedef struct _ADAPTER _adapter, ADAPTE
 #include <rtw_efuse.h>
 #include <hal_intf.h>
 #include <hal_com.h>
-#include <hal_com_led.h>
 #include <rtw_qos.h>
 #include <rtw_pwrctrl.h>
 #include <rtw_mlme.h>
@@ -84,10 +83,6 @@ typedef struct _ADAPTER _adapter, ADAPTE
 #include <rtw_version.h>
 #include <rtw_odm.h>
 
-#ifdef CONFIG_WAPI_SUPPORT
-#include <rtw_wapi.h>
-#endif // CONFIG_WAPI_SUPPORT
-
 #include "ioctl_cfg80211.h"
 
 #include <linux/ip.h>
@@ -200,13 +195,9 @@ struct registry_priv
 
 	u8	hw_wps_pbc;//0:disable,1:enable
 
-#ifdef CONFIG_LAYER2_ROAMING
 	u8	max_roaming_times; // the max number driver will try to roaming
-#endif
 
-#ifdef CONFIG_80211D
 	u8 enable80211d;
-#endif
 
 	u8 ifname[16];
 	u8 if2name[16];
@@ -573,19 +564,11 @@ struct _ADAPTER{
 	_lock   security_key_mutex; // add for CONFIG_IEEE80211W, none 11w also can use
 	struct	registry_priv	registrypriv;
 	struct 	eeprom_priv eeprompriv;
-	struct	led_priv	ledpriv;
 
-#ifdef CONFIG_AP_MODE
 	struct	hostapd_priv	*phostapdpriv;
-#endif
 
 	u32	setband;
 
-#ifdef CONFIG_WAPI_SUPPORT
-	u8	WapiSupport;
-	RT_WAPI_T	wapiInfo;
-#endif
-
 	void *			HalData;
 	u32 hal_data_sz;
 	struct hal_ops	HalFunc;
@@ -721,15 +704,6 @@ __inline static void RTW_ENABLE_FUNC(_ad
 			 (padapter)->bSurpriseRemoved || \
 			 RTW_IS_FUNC_DISABLED((padapter), DF_TX_BIT))
 
-#ifdef CONFIG_PNO_SUPPORT
-int rtw_parse_ssid_list_tlv(char** list_str, pno_ssid_t* ssid, int max, int *bytes_left);
-int rtw_dev_pno_set(struct net_device *net, pno_ssid_t* ssid, int num, 
-					int pno_time, int pno_repeat, int pno_freq_expo_max);
-#ifdef CONFIG_PNO_SET_DEBUG
-void rtw_dev_pno_debug(struct net_device *net);
-#endif //CONFIG_PNO_SET_DEBUG
-#endif //CONFIG_PNO_SUPPORT
-
 #ifdef CONFIG_GPIO_API
 int rtw_get_gpio(struct net_device *netdev, int gpio_num);
 int rtw_set_gpio_output_value(struct net_device *netdev, int gpio_num, bool isHigh);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/Hal8723BPhyCfg.h linux/3rdparty/rtl8723bs/include/Hal8723BPhyCfg.h
--- linux/3rdparty/rtl8723bs.old/include/Hal8723BPhyCfg.h	2015-05-10 14:36:05.720668480 +0300
+++ linux/3rdparty/rtl8723bs/include/Hal8723BPhyCfg.h	2015-05-07 17:46:55.000000000 +0300
@@ -77,13 +77,6 @@ int PHY_RFConfig8723B(PADAPTER	Adapter	)
 
 s32 PHY_MACConfig8723B(PADAPTER padapter);
 
-int
-PHY_ConfigRFWithParaFile_8723B(
-	IN	PADAPTER			Adapter,
-	IN	u8* 				pFileName,
-	RF_PATH				eRFPath
-);
-
 void
 PHY_SetTxPowerIndex_8723B(
 	IN	PADAPTER			Adapter,
@@ -135,10 +128,6 @@ PHY_SetSwChnlBWMode8723B(
 	IN	u8					Offset80
 );
 
-void PHY_SetRFPathSwitch_8723B(
-	IN	PADAPTER	pAdapter,
-	IN	bool		bMain
-	);
 /*--------------------------Exported Function prototype End---------------------*/
 
 #endif
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_btcoex.h linux/3rdparty/rtl8723bs/include/hal_btcoex.h
--- linux/3rdparty/rtl8723bs.old/include/hal_btcoex.h	2015-05-10 14:36:05.720668480 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_btcoex.h	2015-05-07 17:46:55.000000000 +0300
@@ -38,9 +38,7 @@ void hal_btcoex_SetBTCoexist(PADAPTER pa
 u8 hal_btcoex_IsBtExist(PADAPTER padapter);
 u8 hal_btcoex_IsBtDisabled(PADAPTER);
 void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
-u8 hal_btcoex_GetChipType(PADAPTER padapter);
 void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);
-u8 hal_btcoex_GetPgAntNum(PADAPTER padapter);
 void hal_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
 
 u8 hal_btcoex_Initialize(PADAPTER padapter);
@@ -57,14 +55,11 @@ void hal_btcoex_IQKNotify(PADAPTER padap
 void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
 void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
 void hal_btcoex_HaltNotify(PADAPTER padapter);
-void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);
 
 void hal_btcoex_Hanlder(PADAPTER padapter);
 
 s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter);
-u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter);
 void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual);
-u8 hal_btcoex_1Ant(PADAPTER padapter);
 u8 hal_btcoex_IsBtControlLps(PADAPTER);
 u8 hal_btcoex_IsLpsOn(PADAPTER);
 u8 hal_btcoex_RpwmVal(PADAPTER);
@@ -74,8 +69,6 @@ void hal_btcoex_RecordPwrMode(PADAPTER p
 void hal_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
 void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
 u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
-u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
-u8 hal_btcoex_IsBtLinkExist(PADAPTER);
 
 #endif // !__HAL_BTCOEX_H__
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_com.h linux/3rdparty/rtl8723bs/include/hal_com.h
--- linux/3rdparty/rtl8723bs.old/include/hal_com.h	2015-05-10 14:36:05.721668491 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_com.h	2015-05-07 17:46:55.000000000 +0300
@@ -244,7 +244,6 @@ void hal_init_macaddr(_adapter *adapter)
 void rtw_init_hal_com_default_value(PADAPTER Adapter);
 
 void c2h_evt_clear(_adapter *adapter);
-s32 c2h_evt_read(_adapter *adapter, u8 *buf);
 s32 c2h_evt_read_88xx(_adapter *adapter, u8 *buf);
 
 u8  rtw_hal_networktype_to_raid(_adapter *adapter, struct sta_info *psta);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_com_h2c.h linux/3rdparty/rtl8723bs/include/hal_com_h2c.h
--- linux/3rdparty/rtl8723bs.old/include/hal_com_h2c.h	2015-05-10 14:36:05.721668491 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_com_h2c.h	2015-05-07 17:46:55.000000000 +0300
@@ -291,8 +291,6 @@ typedef struct _RSVDPAGE_LOC {
 } RSVDPAGE_LOC, *PRSVDPAGE_LOC;
 
 #endif
-void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
-u8 rtw_check_invalid_mac_address (u8 *mac_addr);
 #if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
 void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
 void rtw_get_sec_iv(PADAPTER padapter, u8*pcur_dot11txpn, u8 *StaAddr);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_com_led.h linux/3rdparty/rtl8723bs/include/hal_com_led.h
--- linux/3rdparty/rtl8723bs.old/include/hal_com_led.h	2015-05-10 14:36:05.721668491 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_com_led.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,261 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_COMMON_LED_H_
-#define __HAL_COMMON_LED_H_
-
-
-#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
-
-//================================================================================
-//	LED Behavior Constant.
-//================================================================================
-// Default LED behavior.
-//
-#define LED_BLINK_NORMAL_INTERVAL	100
-#define LED_BLINK_SLOWLY_INTERVAL	200
-#define LED_BLINK_LONG_INTERVAL	400
-#define LED_INITIAL_INTERVAL		1800
-
-// LED Customerization
-
-//NETTRONIX
-#define LED_BLINK_NORMAL_INTERVAL_NETTRONIX	100
-#define LED_BLINK_SLOWLY_INTERVAL_NETTRONIX	2000
-
-//PORNET
-#define LED_BLINK_SLOWLY_INTERVAL_PORNET	1000
-#define LED_BLINK_NORMAL_INTERVAL_PORNET	100
-#define LED_BLINK_FAST_INTERVAL_BITLAND		30
-
-//AzWave.
-#define LED_CM2_BLINK_ON_INTERVAL		250
-#define LED_CM2_BLINK_OFF_INTERVAL		4750
-#define LED_CM8_BLINK_OFF_INTERVAL		3750	//for QMI
-
-//RunTop
-#define LED_RunTop_BLINK_INTERVAL		300
-
-//ALPHA
-#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
-#define LED_BLINK_NO_LINK_INTERVAL_ALPHA_500MS 500 //add by ylb 20121012 for customer led for alpha
-#define LED_BLINK_LINK_INTERVAL_ALPHA		500	//500
-#define LED_BLINK_SCAN_INTERVAL_ALPHA		180 	//150
-#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
-#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
-
-// 111122 by hpfan: Customized for Xavi
-#define LED_CM11_BLINK_INTERVAL			300
-#define LED_CM11_LINK_ON_INTERVEL		3000
-
-//Netgear
-#define LED_BLINK_LINK_INTERVAL_NETGEAR		500
-#define LED_BLINK_LINK_SLOWLY_INTERVAL_NETGEAR		1000
-
-#define LED_WPS_BLINK_OFF_INTERVAL_NETGEAR		100
-#define LED_WPS_BLINK_ON_INTERVAL_NETGEAR		500
-
-//Belkin AC950
-#define LED_BLINK_LINK_INTERVAL_ON_BELKIN		200
-#define LED_BLINK_LINK_INTERVAL_OFF_BELKIN		100
-#define LED_BLINK_ERROR_INTERVAL_BELKIN		100
-
-//by chiyokolin for Azurewave
-#define LED_CM12_BLINK_INTERVAL_5Mbps		160
-#define LED_CM12_BLINK_INTERVAL_10Mbps		80
-#define LED_CM12_BLINK_INTERVAL_20Mbps		50
-#define LED_CM12_BLINK_INTERVAL_40Mbps		40
-#define LED_CM12_BLINK_INTERVAL_80Mbps		30
-#define LED_CM12_BLINK_INTERVAL_MAXMbps		25
-
-//Dlink
-#define	LED_BLINK_NO_LINK_INTERVAL		1000
-#define	LED_BLINK_LINK_IDEL_INTERVAL		100
-
-#define	LED_BLINK_SCAN_ON_INTERVAL		30
-#define	LED_BLINK_SCAN_OFF_INTERVAL		300
-
-#define LED_WPS_BLINK_ON_INTERVAL_DLINK		30
-#define LED_WPS_BLINK_OFF_INTERVAL_DLINK			300
-#define LED_WPS_BLINK_LINKED_ON_INTERVAL_DLINK			5000
-
-//================================================================================
-// LED object.
-//================================================================================
-
-typedef enum _LED_CTL_MODE{
-	LED_CTL_POWER_ON = 1,
-	LED_CTL_LINK = 2,
-	LED_CTL_NO_LINK = 3,
-	LED_CTL_TX = 4,
-	LED_CTL_RX = 5,
-	LED_CTL_SITE_SURVEY = 6,
-	LED_CTL_POWER_OFF = 7,
-	LED_CTL_START_TO_LINK = 8,
-	LED_CTL_START_WPS = 9,
-	LED_CTL_STOP_WPS = 10,
-	LED_CTL_START_WPS_BOTTON = 11, //added for runtop
-	LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA	
-	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
-	LED_CTL_CONNECTION_NO_TRANSFER = 14,
-}LED_CTL_MODE;
-
-typedef	enum _LED_STATE{
-	LED_UNKNOWN = 0,
-	RTW_LED_ON = 1,
-	RTW_LED_OFF = 2,
-	LED_BLINK_NORMAL = 3,
-	LED_BLINK_SLOWLY = 4,
-	LED_BLINK_POWER_ON = 5,
-	LED_BLINK_SCAN = 6, 	// LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
-	LED_BLINK_NO_LINK = 7, // LED is blinking during no link state.
-	LED_BLINK_StartToBlink = 8, // Customzied for Sercomm Printer Server case
-	LED_BLINK_TXRX = 9,
-	LED_BLINK_WPS = 10,	// LED is blinkg during WPS communication
-	LED_BLINK_WPS_STOP = 11,	//for ALPHA
-	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
-	LED_BLINK_RUNTOP = 13, 	// Customized for RunTop
-	LED_BLINK_CAMEO = 14,
-	LED_BLINK_XAVI = 15,
-	LED_BLINK_ALWAYS_ON = 16,
-	LED_BLINK_LINK_IN_PROCESS = 17,  //Customized for Belkin AC950
-	LED_BLINK_AUTH_ERROR = 18,  //Customized for Belkin AC950
-	LED_BLINK_Azurewave_5Mbps = 19,
-	LED_BLINK_Azurewave_10Mbps = 20,
-	LED_BLINK_Azurewave_20Mbps = 21,
-	LED_BLINK_Azurewave_40Mbps = 22,
-	LED_BLINK_Azurewave_80Mbps = 23,
-	LED_BLINK_Azurewave_MAXMbps = 24,
-	LED_BLINK_LINK_IDEL = 25,
-	LED_BLINK_WPS_LINKED = 26,
-}LED_STATE;
-
-typedef enum _LED_PIN{
-	LED_PIN_GPIO0,
-	LED_PIN_LED0,
-	LED_PIN_LED1,
-	LED_PIN_LED2
-}LED_PIN;
-
-//================================================================================
-// SDIO LED Definition.
-//================================================================================
-#define IS_LED_WPS_BLINKING(_LED_SDIO)	(((PLED_SDIO)_LED_SDIO)->CurrLedState==LED_BLINK_WPS \
-					|| ((PLED_SDIO)_LED_SDIO)->CurrLedState==LED_BLINK_WPS_STOP \
-					|| ((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress)
-
-#define IS_LED_BLINKING(_LED_SDIO) 	(((PLED_SDIO)_LED_SDIO)->bLedWPSBlinkInProgress \
-					||((PLED_SDIO)_LED_SDIO)->bLedScanBlinkInProgress)
-
-
-typedef	enum _LED_STRATEGY_SDIO{
-	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
-	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
-	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
-	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
-	SW_LED_MODE4, //for Edimax / Belkin
-	SW_LED_MODE5, //for Sercomm / Belkin	
-	SW_LED_MODE6,	//for 88CU minicard, porting from ce SW_LED_MODE7
-	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
-}LED_STRATEGY_SDIO, *PLED_STRATEGY_SDIO;
-
-typedef struct _LED_SDIO{
-	PADAPTER			padapter;
-
-	LED_PIN				LedPin;	// Identify how to implement this SW led.
-
-	LED_STATE			CurrLedState; // Current LED state.
-	bool				bLedOn; // true if LED is ON, false if LED is OFF.
-
-	bool				bSWLedCtrl;
-
-	bool				bLedBlinkInProgress; // true if it is blinking, false o.w..
-	// ALPHA, added by chiyoko, 20090106
-	bool				bLedNoLinkBlinkInProgress;
-	bool				bLedLinkBlinkInProgress;
-	bool				bLedStartToLinkBlinkInProgress;	
-	bool				bLedScanBlinkInProgress;
-	bool				bLedWPSBlinkInProgress;
-	
-	u32					BlinkTimes; // Number of times to toggle led state for blinking.
-	LED_STATE			BlinkingLedState; // Next state for blinking, either LED_ON or LED_OFF are.
-
-	_timer				BlinkTimer; // Timer object for led blinking.
-
-	_workitem			BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED.
-} LED_SDIO, *PLED_SDIO;
-
-typedef struct _LED_SDIO	LED_DATA, *PLED_DATA;
-typedef enum _LED_STRATEGY_SDIO	LED_STRATEGY, *PLED_STRATEGY;
-
-void
-LedControlSDIO(
-	IN	PADAPTER		Adapter,
-	IN	LED_CTL_MODE		LedAction
-	);
-
-struct led_priv{
-	/* add for led controll */
-	LED_DATA			SwLed0;
-	LED_DATA			SwLed1;
-	LED_DATA			SwLed2;
-	LED_STRATEGY		LedStrategy;
-	u8					bRegUseLed;
-	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
-	void (*SwLedOn)(_adapter *padapter, PLED_DATA pLed);
-	void (*SwLedOff)(_adapter *padapter, PLED_DATA pLed);
-	/* add for led controll */
-};
-
-#define rtw_led_control(adapter, LedAction)
-
-#define SwLedOn(adapter, pLed) \
-	do { \
-		if((adapter)->ledpriv.SwLedOn) \
-			(adapter)->ledpriv.SwLedOn((adapter), (pLed)); \
-	} while(0)
-
-#define SwLedOff(adapter, pLed) \
-	do { \
-		if((adapter)->ledpriv.SwLedOff) \
-			(adapter)->ledpriv.SwLedOff((adapter), (pLed)); \
-	} while(0)
-
-void BlinkTimerCallback(void *data);
-void BlinkWorkItemCallback(_workitem *work);
-
-void ResetLedStatus(PLED_DATA pLed);
-
-void
-InitLed(
-	_adapter			*padapter,
-	PLED_DATA		pLed,
-	LED_PIN			LedPin
-	);
-
-void
-DeInitLed(
-	PLED_DATA		pLed
-	);
-
-//hal...
-extern void BlinkHandler(PLED_DATA	pLed);
-
-#endif //__RTW_LED_H_
-
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_com_phycfg.h linux/3rdparty/rtl8723bs/include/hal_com_phycfg.h
--- linux/3rdparty/rtl8723bs.old/include/hal_com_phycfg.h	2015-05-10 14:36:05.721668491 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_com_phycfg.h	2015-05-07 17:46:55.000000000 +0300
@@ -84,13 +84,6 @@ typedef struct _BB_REGISTER_DEFINITION{
 
 
 //----------------------------------------------------------------------
-s32
-phy_TxPwrIdxToDbm(
-	IN	PADAPTER		Adapter,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u8				TxPwrIdx	
-	);
-
 u8
 PHY_GetTxPowerByRateBase(
 	IN	PADAPTER		Adapter,
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_intf.h linux/3rdparty/rtl8723bs/include/hal_intf.h
--- linux/3rdparty/rtl8723bs.old/include/hal_intf.h	2015-05-10 14:36:05.723668514 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_intf.h	2015-05-07 17:46:55.000000000 +0300
@@ -200,9 +200,6 @@ struct hal_ops {
 	s32	(*init_recv_priv)(_adapter *padapter);
 	void	(*free_recv_priv)(_adapter *padapter);
 
-	void	(*InitSwLeds)(_adapter *padapter);
-	void	(*DeInitSwLeds)(_adapter *padapter);
-
 	void	(*dm_init)(_adapter *padapter);
 	void	(*dm_deinit)(_adapter *padapter);
 	void	(*read_chip_version)(_adapter *padapter);
@@ -341,11 +338,7 @@ void	rtw_hal_free_data(_adapter *padapte
 
 void rtw_hal_dm_init(_adapter *padapter);
 void rtw_hal_dm_deinit(_adapter *padapter);
-void rtw_hal_sw_led_init(_adapter *padapter);
-void rtw_hal_sw_led_deinit(_adapter *padapter);
 
-u32 rtw_hal_power_on(_adapter *padapter);
-void rtw_hal_power_off(_adapter *padapter);
 uint rtw_hal_init(_adapter *padapter);
 uint rtw_hal_deinit(_adapter *padapter);
 void rtw_hal_stop(_adapter *padapter);
@@ -369,13 +362,6 @@ void rtw_hal_disable_interrupt(_adapter
 
 u8 rtw_hal_check_ips_status(_adapter *padapter);
 
-u32	rtw_hal_inirp_init(_adapter *padapter);
-u32	rtw_hal_inirp_deinit(_adapter *padapter);
-
-void	rtw_hal_irp_reset(_adapter *padapter);
-
-u8	rtw_hal_intf_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id, u8* val);
-
 s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
 s32	rtw_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
 s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe);
@@ -407,17 +393,11 @@ void	rtw_hal_write_rfreg(_adapter *padap
 #define PHY_SetMacReg	PHY_SetBBReg
 #define PHY_QueryMacReg PHY_QueryBBReg
 
-s32	rtw_hal_interrupt_handler(_adapter *padapter);
-
-void	rtw_hal_set_bwmode(_adapter *padapter, CHANNEL_WIDTH Bandwidth, u8 Offset);
 void	rtw_hal_set_chan(_adapter *padapter, u8 channel);
 void	rtw_hal_set_chnl_bw(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80);
 void	rtw_hal_dm_watchdog(_adapter *padapter);
 void	rtw_hal_dm_watchdog_in_lps(_adapter *padapter);
 
-void	rtw_hal_set_tx_power_level(_adapter *padapter, u8 channel);
-void	rtw_hal_get_tx_power_level(_adapter *padapter, s32 *powerlevel);
-
 s32 rtw_hal_xmit_thread_handler(_adapter *padapter);
 
 void rtw_hal_notch_filter(_adapter * adapter, bool enable);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/hal_phy.h linux/3rdparty/rtl8723bs/include/hal_phy.h
--- linux/3rdparty/rtl8723bs.old/include/hal_phy.h	2015-05-10 14:36:05.723668514 +0300
+++ linux/3rdparty/rtl8723bs/include/hal_phy.h	2015-05-07 17:46:55.000000000 +0300
@@ -192,69 +192,5 @@ typedef struct RF_Shadow_Compare_Map {
 
 /*--------------------------Exported Function prototype---------------------*/
 
-u32
-PHY_CalculateBitShift(
-	u32 BitMask
-	);
-
-u32
-PHY_RFShadowRead(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset);
-
-void
-PHY_RFShadowWrite(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u32				Data);
-
-bool
-PHY_RFShadowCompare(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset);
-
-void
-PHY_RFShadowRecorver(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset);
-
-void
-PHY_RFShadowCompareAll(
-	IN	PADAPTER		Adapter);
-
-void
-PHY_RFShadowRecorverAll(
-	IN	PADAPTER		Adapter);
-
-void
-PHY_RFShadowCompareFlagSet(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u8				Type);
-
-void
-PHY_RFShadowRecorverFlagSet(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath,
-	IN	u32				Offset,
-	IN	u8				Type);
-
-void
-PHY_RFShadowCompareFlagSetAll(
-	IN	PADAPTER		Adapter);
-
-void
-PHY_RFShadowRecorverFlagSetAll(
-	IN	PADAPTER		Adapter);
-
-void
-PHY_RFShadowRefresh(
-	IN	PADAPTER		Adapter);
-
 #endif //__HAL_COMMON_H__
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/ieee80211.h linux/3rdparty/rtl8723bs/include/ieee80211.h
--- linux/3rdparty/rtl8723bs.old/include/ieee80211.h	2015-05-10 14:36:05.724668524 +0300
+++ linux/3rdparty/rtl8723bs/include/ieee80211.h	2015-05-07 17:46:55.000000000 +0300
@@ -27,8 +27,6 @@
 #define ETH_TYPE_LEN		2
 #define PAYLOAD_TYPE_LEN	1
 
-#ifdef CONFIG_AP_MODE
-
 #define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
 
 /* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
@@ -77,8 +75,6 @@ enum {
 #define WLAN_STA_VHT BIT(14)
 #define WLAN_STA_NONERP BIT(31)
 
-#endif
-
 #define IEEE_CMD_SET_WPA_PARAM			1
 #define IEEE_CMD_SET_WPA_IE				2
 #define IEEE_CMD_SET_ENCRYPTION			3
@@ -199,30 +195,27 @@ enum NETWORK_TYPE
 	WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
 	WIRELESS_11ABGN = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N),
 	WIRELESS_MODE_24G = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11AC),
-	WIRELESS_MODE_5G = (WIRELESS_11A|WIRELESS_11_5N|WIRELESS_11AC),
 	WIRELESS_MODE_MAX = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N|WIRELESS_11AC),
 };
 
 #define SUPPORTED_24G_NETTYPE_MSK (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N)
-#define SUPPORTED_5G_NETTYPE_MSK (WIRELESS_11A | WIRELESS_11_5N)
 
 #define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WIRELESS_11BG|WIRELESS_11A)))
 
 #define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? true : false)
-#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? true : false)
 
 #define IsEnableHWCCK(NetType) IsSupported24G(NetType)
-#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? true : false)
+#define IsEnableHWOFDM(NetType) (((NetType) & (WIRELESS_11G|WIRELESS_11_24N)) ? true : false)
 
 #define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
 #define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
 #define IsSupportedRxHT(NetType) IsEnableHWOFDM(NetType)
 
-#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? true : false)
-#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? true : false)
-#define IsSupportedHT(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? true : false) 
+#define IsSupportedTxCCK(NetType) (((NetType) & (WIRELESS_11B)) ? true : false)
+#define IsSupportedTxOFDM(NetType) (((NetType) & (WIRELESS_11G|WIRELESS_11A)) ? true : false)
+#define IsSupportedHT(NetType) (((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N)) ? true : false)
 
-#define IsSupportedVHT(NetType) ((NetType) & (WIRELESS_11AC) ? true : false) 
+#define IsSupportedVHT(NetType) (((NetType) & (WIRELESS_11AC)) ? true : false)
 
 
 typedef struct ieee_param {
@@ -251,7 +244,6 @@ typedef struct ieee_param {
 			u16 key_len;
 			u8 key[0];
 		} crypt;
-#ifdef CONFIG_AP_MODE
 		struct {
 			u16 aid;
 			u16 capability;
@@ -263,12 +255,9 @@ typedef struct ieee_param {
 			u8	reserved[2];//for set max_num_sta
 			u8	buf[0];
 		} bcn_ie;
-#endif
-
-	} u;	   
+	} u;
 }ieee_param;
 
-#ifdef CONFIG_AP_MODE
 typedef struct ieee_param_ex {
 	u32 cmd;
 	u8 sta_addr[ETH_ALEN];
@@ -290,8 +279,6 @@ struct sta_data{
 	u64	tx_bytes;
 	u64	tx_drops;
 };
-#endif
-
 
 #define IEEE80211_DATA_LEN		2304
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
@@ -848,10 +835,8 @@ struct ieee80211_softmac_stats{
 #define WEP_KEYS 4
 #define WEP_KEY_LEN 13
 
-#ifdef CONFIG_IEEE80211W
 #define BIP_MAX_KEYID 5
 #define BIP_AAD_SIZE  20
-#endif //CONFIG_IEEE80211W
 
 struct ieee80211_security {
 	u16 active_key:2,
@@ -1107,10 +1092,6 @@ typedef struct tx_pending_t{
 #define IEEE_G            (1<<2)
 #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
 
-//Baron move to ieee80211.c
-int ieee80211_is_empty_essid(const char *essid, int essid_len);
-int ieee80211_get_hdrlen(u16 fc);
-
 /* Action category code */
 enum rtw_ieee80211_category {
 	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
@@ -1357,11 +1338,6 @@ enum secondary_ch_offset {
 	SCA = 1, /* secondary channel above */
 	SCB = 3,  /* secondary channel below */
 };
-u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset);
-u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset);
-u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode, u8 new_ch, u8 ch_switch_cnt);
-u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset);
-u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl, u8 flags, u16 reason, u16 precedence);
 
 u8 *rtw_get_ie(u8*pbuf, sint index, sint *len, sint limit);
 u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
@@ -1380,7 +1356,6 @@ int rtw_parse_wpa2_ie(u8* wpa_ie, int wp
 int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
 
 u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
-u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type);
 u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
 u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_attr, u32 *len_attr);
 u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_content, uint *len_content);
@@ -1394,9 +1369,6 @@ u8 *rtw_get_wps_attr_content(u8 *wps_ie,
 #define for_each_ie(ie, buf, buf_len) \
 	for (ie = (void*)buf; (((u8*)ie) - ((u8*)buf) + 1) < buf_len; ie = (void*)(((u8*)ie) + *(((u8*)ie)+1) + 2))
 
-void dump_ies(u8 *buf, u32 buf_len);
-void dump_wps_ie(u8 *ie, u32 ie_len);
-
 uint	rtw_get_rateset_len(u8	*rateset);
 
 struct registry_priv;
diff -Nurp linux/3rdparty/rtl8723bs.old/include/ioctl_cfg80211.h linux/3rdparty/rtl8723bs/include/ioctl_cfg80211.h
--- linux/3rdparty/rtl8723bs.old/include/ioctl_cfg80211.h	2015-05-10 14:36:05.725668535 +0300
+++ linux/3rdparty/rtl8723bs/include/ioctl_cfg80211.h	2015-05-07 17:46:55.000000000 +0300
@@ -20,6 +20,11 @@
 #ifndef __IOCTL_CFG80211_H__
 #define __IOCTL_CFG80211_H__ 
 
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+#error This driver only works with kernel 4.0
+#endif
 
 struct rtw_wdev_invit_info {
 	u8 state; /* 0: req, 1:rep */
@@ -116,26 +121,14 @@ void rtw_cfg80211_indicate_connect(_adap
 void rtw_cfg80211_indicate_disconnect(_adapter *padapter);
 void rtw_cfg80211_indicate_scan_done(_adapter *adapter, bool aborted);
 
-#ifdef CONFIG_AP_MODE
 void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
 void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, unsigned short reason);
-#endif //CONFIG_AP_MODE
 
-void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
-void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
 void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const char*msg);
 
-int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len, int type);
-
 bool rtw_cfg80211_pwr_mgmt(_adapter *adapter);
 
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0))
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len,0,gfp)
-#else
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len,0)
-#endif /* KERNEL_VERSION(3,18,0) and newer */
-
 #define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, bss, buf, len)
 #define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->rtw_wdev, cookie, buf, len, ack, gfp)
 #define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, duration, gfp)
diff -Nurp linux/3rdparty/rtl8723bs.old/include/osdep_intf.h linux/3rdparty/rtl8723bs/include/osdep_intf.h
--- linux/3rdparty/rtl8723bs.old/include/osdep_intf.h	2015-05-10 14:36:05.725668535 +0300
+++ linux/3rdparty/rtl8723bs/include/osdep_intf.h	2015-05-07 17:46:55.000000000 +0300
@@ -64,9 +64,6 @@ void rtw_dev_unload(PADAPTER padapter);
 
 u32 rtw_start_drv_threads(_adapter *padapter);
 void rtw_stop_drv_threads (_adapter *padapter);
-#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
-void rtw_cancel_dynamic_chk_timer(_adapter *padapter);
-#endif
 void rtw_cancel_all_timer(_adapter *padapter);
 
 int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/osdep_service.h linux/3rdparty/rtl8723bs/include/osdep_service.h
--- linux/3rdparty/rtl8723bs.old/include/osdep_service.h	2015-05-10 14:36:05.725668535 +0300
+++ linux/3rdparty/rtl8723bs/include/osdep_service.h	2015-05-07 17:46:55.000000000 +0300
@@ -74,8 +74,6 @@
 
 extern int RTW_STATUS_CODE(int error_code);
 
-#define CONFIG_USE_VMALLOC
-
 /* flags used for rtw_mstat_update() */
 enum mstat_f {
 	/* type: 0x00ff */
@@ -106,62 +104,27 @@ typedef enum mstat_status{
 
 #define rtw_mstat_update(flag, status, sz) do {} while(0)
 #define rtw_mstat_dump(sel) do {} while(0)
-u8*	_rtw_zvmalloc(u32 sz);
-void	_rtw_vmfree(u8 *pbuf, u32 sz);
 u8*	_rtw_zmalloc(u32 sz);
 u8*	_rtw_malloc(u32 sz);
-void	_rtw_mfree(u8 *pbuf, u32 sz);
+void	_kfree(u8 *pbuf, u32 sz);
 
 struct sk_buff *_rtw_skb_alloc(u32 sz);
-void _rtw_skb_free(struct sk_buff *skb);
 struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb);
 struct sk_buff *_rtw_skb_clone(struct sk_buff *skb);
 int _rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb);
-void _rtw_skb_queue_purge(struct sk_buff_head *list);
 
-#ifdef CONFIG_USE_VMALLOC
-#define rtw_zvmalloc(sz)			_rtw_zvmalloc((sz))
-#define rtw_vmfree(pbuf, sz)		_rtw_vmfree((pbuf), (sz))
-#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zvmalloc((sz))
-#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_vmfree((pbuf), (sz))
-#else /* CONFIG_USE_VMALLOC */
-#define rtw_zvmalloc(sz)			_rtw_zmalloc((sz))
-#define rtw_vmfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
-#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zmalloc((sz))
-#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_mfree((pbuf), (sz))
-#endif /* CONFIG_USE_VMALLOC */
 #define rtw_malloc(sz)			_rtw_malloc((sz))
 #define rtw_zmalloc(sz)			_rtw_zmalloc((sz))
-#define rtw_mfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
-#define rtw_malloc_f(sz, mstat_f)			_rtw_malloc((sz))
-#define rtw_zmalloc_f(sz, mstat_f)			_rtw_zmalloc((sz))
-#define rtw_mfree_f(pbuf, sz, mstat_f)		_rtw_mfree((pbuf), (sz))
 
 #define rtw_skb_alloc(size) _rtw_skb_alloc((size))
-#define rtw_skb_free(skb) _rtw_skb_free((skb))
 #define rtw_skb_alloc_f(size, mstat_f)	_rtw_skb_alloc((size))
-#define rtw_skb_free_f(skb, mstat_f)	_rtw_skb_free((skb))
 #define rtw_skb_copy(skb)	_rtw_skb_copy((skb))
 #define rtw_skb_clone(skb)	_rtw_skb_clone((skb))
 #define rtw_skb_copy_f(skb, mstat_f)	_rtw_skb_copy((skb))
 #define rtw_skb_clone_f(skb, mstat_f)	_rtw_skb_clone((skb))
 #define rtw_netif_rx(ndev, skb) _rtw_netif_rx(ndev, skb)
-#define rtw_skb_queue_purge(sk_buff_head) _rtw_skb_queue_purge(sk_buff_head)
-
-extern void	_rtw_init_listhead(_list *list);
-extern u32	rtw_is_list_empty(_list *phead);
-extern void	rtw_list_insert_head(_list *plist, _list *phead);
-extern void	rtw_list_insert_tail(_list *plist, _list *phead);
-extern void	rtw_list_delete(_list *plist);
 
 extern void	_rtw_init_queue(_queue	*pqueue);
-extern u32	_rtw_queue_empty(_queue	*pqueue);
-extern u32	rtw_end_of_queue_search(_list *queue, _list *pelement);
-
-extern u32	rtw_systime_to_ms(u32 systime);
-extern s32	rtw_get_time_interval_ms(u32 start, u32 end);
-
-extern void	rtw_sleep_schedulable(int ms);
 
 extern void rtw_init_timer(_timer *ptimer, void *padapter, void *pfunc);
 
@@ -184,17 +147,6 @@ __inline static void flush_signals_threa
 	}
 }
 
-__inline static _OS_STATUS res_to_status(sint res)
-{
-
-	return res;
-}
-
-__inline static void rtw_dump_stack(void)
-{
-	dump_stack();
-}
-
 #define rtw_warn_on(condition) WARN_ON(condition)
 
 __inline static int rtw_bug_check(void *parg1, void *parg2, void *parg3, void *parg4)
@@ -230,49 +182,6 @@ __inline static u32 _RND8(u32 sz)
 
 }
 
-__inline static u32 _RND128(u32 sz)
-{
-
-	u32	val;
-
-	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
-	
-	return val;
-
-}
-
-__inline static u32 _RND256(u32 sz)
-{
-
-	u32	val;
-
-	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
-	
-	return val;
-
-}
-
-__inline static u32 _RND512(u32 sz)
-{
-
-	u32	val;
-
-	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
-	
-	return val;
-
-}
-
-__inline static u32 bitshift(u32 bitmask)
-{
-	u32 i;
-
-	for (i = 0; i <= 31; i++)
-		if (((bitmask>>i) &  0x1) == 1) break;
-
-	return i;
-}
-
 #ifndef MAC_FMT
 #define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 #endif
@@ -281,17 +190,6 @@ __inline static u32 bitshift(u32 bitmask
 #endif
 
 
-extern void rtw_suspend_lock_init(void);
-extern void rtw_suspend_lock_uninit(void);
-extern void rtw_lock_suspend(void);
-extern void rtw_unlock_suspend(void);
-extern void rtw_lock_suspend_timeout(u32 timeout_ms);
-extern void rtw_lock_ext_suspend_timeout(u32 timeout_ms);
-extern void rtw_lock_rx_suspend_timeout(u32 timeout_ms);
-extern void rtw_lock_traffic_suspend_timeout(u32 timeout_ms);
-extern void rtw_lock_resume_scan_timeout(u32 timeout_ms);
-extern void rtw_resume_lock_suspend(void);
-extern void rtw_resume_unlock_suspend(void);
 #ifdef CONFIG_AP_WOWLAN
 extern void rtw_softap_lock_suspend(void);
 extern void rtw_softap_unlock_suspend(void);
@@ -300,15 +198,11 @@ extern void rtw_softap_unlock_suspend(vo
 //File operation APIs, just for linux now
 extern int rtw_is_file_readable(char *path);
 extern int rtw_retrive_from_file(char *path, u8* buf, u32 sz);
-extern int rtw_store_to_file(char *path, u8* buf, u32 sz);
-
 
 extern void rtw_free_netdev(struct net_device * netdev);
 
 
 extern u64 rtw_modular64(u64 x, u64 y);
-extern u64 rtw_division64(u64 x, u64 y);
-extern u32 rtw_random32(void);
 
 /* Macros for handling unaligned memory accesses */
 
@@ -391,7 +285,6 @@ bool rtw_cbuf_empty(struct rtw_cbuf *cbu
 bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf);
 void *rtw_cbuf_pop(struct rtw_cbuf *cbuf);
 struct rtw_cbuf *rtw_cbuf_alloc(u32 size);
-void rtw_cbuf_free(struct rtw_cbuf *cbuf);
 
 // String handler
 /*
diff -Nurp linux/3rdparty/rtl8723bs.old/include/osdep_service_linux.h linux/3rdparty/rtl8723bs/include/osdep_service_linux.h
--- linux/3rdparty/rtl8723bs.old/include/osdep_service_linux.h	2015-05-10 14:36:05.725668535 +0300
+++ linux/3rdparty/rtl8723bs/include/osdep_service_linux.h	2015-05-07 17:46:55.000000000 +0300
@@ -20,7 +20,6 @@
 #ifndef __OSDEP_LINUX_SERVICE_H_
 #define __OSDEP_LINUX_SERVICE_H_
 
-	#include <linux/version.h>
 	#include <linux/spinlock.h>
 	#include <linux/compiler.h>
 	#include <linux/kernel.h>
@@ -96,56 +95,6 @@ __inline static _list	*get_list_head(_qu
 #define LIST_CONTAINOR(ptr, type, member) \
         ((type *)((char *)(ptr)-(__kernel_size_t)(&((type *)0)->member)))	
 
-        
-__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_irqsave(plock, *pirqL);
-}
-
-__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_irqrestore(plock, *pirqL);
-}
-
-__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_irqsave(plock, *pirqL);
-}
-
-__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_irqrestore(plock, *pirqL);
-}
-
-__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_bh(plock);
-}
-
-__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_bh(plock);
-}
-
-__inline static int _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	int ret = 0;
-	//mutex_lock(pmutex);
-	ret = mutex_lock_interruptible(pmutex);
-	return ret;
-}
-
-
-__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	mutex_unlock(pmutex);
-}
-
-__inline static void rtw_list_delete(_list *plist)
-{
-	list_del_init(plist);
-}
-
 #define RTW_TIMER_HDL_ARGS void *FunctionContext
 
 __inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,void* cntx)
diff -Nurp linux/3rdparty/rtl8723bs.old/include/recv_osdep.h linux/3rdparty/rtl8723bs/include/recv_osdep.h
--- linux/3rdparty/rtl8723bs.old/include/recv_osdep.h	2015-05-10 14:36:05.725668535 +0300
+++ linux/3rdparty/rtl8723bs/include/recv_osdep.h	2015-05-07 17:46:55.000000000 +0300
@@ -29,31 +29,24 @@ extern s32  rtw_recv_entry(union recv_fr
 extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
 extern void rtw_recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
 
-extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
 extern void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup);
-		
 
 int	rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
 void rtw_free_recv_priv (struct recv_priv *precvpriv);
 
 
-int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
 int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
 void rtw_os_recv_resource_free(struct recv_priv *precvpriv);
 
 
-int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb);
 void rtw_os_free_recvframe(union recv_frame *precvframe);
 
 
-int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
 int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);
 
 _pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8 *pdata);
 void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attrib *pattrib);
 
-void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf);
-
 void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
 
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_cmd.h linux/3rdparty/rtl8723bs/include/rtl8723b_cmd.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_cmd.h	2015-05-10 14:36:05.726668547 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_cmd.h	2015-05-07 17:46:55.000000000 +0300
@@ -337,7 +337,6 @@ void rtl8723b_fw_try_ap_cmd(PADAPTER pad
 void rtl8723b_set_FwPsTuneParam_cmd(PADAPTER padapter);
 void rtl8723b_set_FwMacIdConfig_cmd(_adapter* padapter, u8 mac_id, u8 raid, u8 bw, u8 sgi, u32 mask);
 void rtl8723b_set_FwMediaStatusRpt_cmd(PADAPTER	padapter, u8 mstatus, u8 macid);
-void rtl8723b_set_FwBtMpOper_cmd(PADAPTER padapter, u8 idx, u8 ver, u8 reqnum, u8 *param);
 void rtl8723b_download_rsvd_page(PADAPTER padapter, u8 mstatus);
 void rtl8723b_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_dm.h linux/3rdparty/rtl8723bs/include/rtl8723b_dm.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_dm.h	2015-05-10 14:36:05.726668547 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_dm.h	2015-05-07 17:46:55.000000000 +0300
@@ -36,7 +36,6 @@
 //============================================================
 
 void rtl8723b_init_dm_priv(PADAPTER padapter);
-void rtl8723b_deinit_dm_priv(PADAPTER padapter);
 
 void rtl8723b_InitHalDm(PADAPTER padapter);
 void rtl8723b_HalDmWatchDog(PADAPTER padapter);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_hal.h linux/3rdparty/rtl8723bs/include/rtl8723b_hal.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_hal.h	2015-05-10 14:36:05.726668547 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_hal.h	2015-05-07 17:46:55.000000000 +0300
@@ -28,7 +28,6 @@
 #include "rtl8723b_recv.h"
 #include "rtl8723b_xmit.h"
 #include "rtl8723b_cmd.h"
-#include "rtl8723b_led.h"
 #include "rtw_mp.h"
 #include "Hal8723BPwrSeq.h"
 #include "Hal8723BPhyReg.h"
@@ -232,15 +231,10 @@ void rtl8723b_FirmwareSelfReset(PADAPTER
 void rtl8723b_InitializeFirmwareVars(PADAPTER padapter);
 
 void rtl8723b_InitAntenna_Selection(PADAPTER padapter);
-void rtl8723b_DeinitAntenna_Selection(PADAPTER padapter);
-void rtl8723b_CheckAntenna_Selection(PADAPTER padapter);
 void rtl8723b_init_default_value(PADAPTER padapter);
 
 s32 rtl8723b_InitLLTTable(PADAPTER padapter);
 
-s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
-s32 CardDisableWithoutHWSM(PADAPTER padapter);
-
 // EFuse
 u8 GetEEPROMSize8723B(PADAPTER padapter);
 void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
@@ -266,7 +260,6 @@ u8 GetHalDefVar8723B(PADAPTER padapter,
 
 // register
 void rtl8723b_InitBeaconParameters(PADAPTER padapter);
-void rtl8723b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
 void	_InitBurstPktLen_8723BS(PADAPTER Adapter);
 void _8051Reset8723(PADAPTER padapter);
 #ifdef CONFIG_WOWLAN
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_led.h linux/3rdparty/rtl8723bs/include/rtl8723b_led.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_led.h	2015-05-10 14:36:05.726668547 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_led.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,34 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTL8723B_LED_H__
-#define __RTL8723B_LED_H__
-
-#include <drv_conf.h>
-#include <osdep_service.h>
-#include <drv_types.h>
-
-
-//================================================================================
-// Interface to manipulate LED objects.
-//================================================================================
-void rtl8723bs_InitSwLeds(PADAPTER padapter);
-void rtl8723bs_DeInitSwLeds(PADAPTER padapter);
-#endif
-
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_recv.h linux/3rdparty/rtl8723bs/include/rtl8723b_recv.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_recv.h	2015-05-10 14:36:05.726668547 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_recv.h	2015-05-07 17:46:55.000000000 +0300
@@ -146,7 +146,5 @@ void rtl8723bs_free_recv_priv(PADAPTER p
 void rtl8723b_query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy_stat);
 void rtl8723b_process_phy_info(PADAPTER padapter, void *prframe);
 
-void	rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
-
 #endif
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtl8723b_spec.h linux/3rdparty/rtl8723bs/include/rtl8723b_spec.h
--- linux/3rdparty/rtl8723bs.old/include/rtl8723b_spec.h	2015-05-10 14:36:05.727668558 +0300
+++ linux/3rdparty/rtl8723bs/include/rtl8723b_spec.h	2015-05-07 17:46:55.000000000 +0300
@@ -19,7 +19,7 @@
 #ifndef __RTL8723B_SPEC_H__
 #define __RTL8723B_SPEC_H__
 
-#include <drv_conf.h>
+#include <autoconf.h>
 
 
 #define HAL_NAV_UPPER_UNIT_8723B		128		// micro-second
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_ap.h linux/3rdparty/rtl8723bs/include/rtw_ap.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_ap.h	2015-05-10 14:36:05.727668558 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_ap.h	2015-05-07 17:46:55.000000000 +0300
@@ -20,19 +20,9 @@
 #ifndef __RTW_AP_H_
 #define __RTW_AP_H_
 
-
-#ifdef CONFIG_AP_MODE
-
-//external function
-extern void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta);
-extern void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta);
-
-
 void init_mlme_ap_info(_adapter *padapter);
 void free_mlme_ap_info(_adapter *padapter);
 //void update_BCNTIM(_adapter *padapter);
-void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
-void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
 void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
 void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level);
 void expire_timeout_chk(_adapter *padapter);
@@ -48,7 +38,6 @@ u8 rtw_ap_set_pairwise_key(_adapter *pad
 int rtw_ap_set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid);
 int rtw_ap_set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid, u8 set_tx);
 
-#ifdef CONFIG_NATIVEAP_MLME
 void associated_clients_update(_adapter *padapter, u8 updated);
 void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
 u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
@@ -56,16 +45,8 @@ void sta_info_update(_adapter *padapter,
 void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta);
 u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason);
 int rtw_sta_flush(_adapter *padapter);
-int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset);
 void start_ap_mode(_adapter *padapter);
 void stop_ap_mode(_adapter *padapter);
-#endif
-
-#ifdef CONFIG_AUTO_AP_MODE
-extern void rtw_start_auto_ap(_adapter *adapter);
-#endif //CONFIG_AUTO_AP_MODE
-
-#endif //end of CONFIG_AP_MODE
 
 #endif
 void update_bmc_sta(_adapter *padapter);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_btcoex.h linux/3rdparty/rtl8723bs/include/rtw_btcoex.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_btcoex.h	2015-05-10 14:36:05.728668569 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_btcoex.h	2015-05-07 17:46:55.000000000 +0300
@@ -41,14 +41,10 @@ void rtw_btcoex_IQKNotify(PADAPTER padap
 void rtw_btcoex_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
 void rtw_btcoex_SuspendNotify(PADAPTER, u8 state);
 void rtw_btcoex_HaltNotify(PADAPTER);
-void rtw_btcoex_SwitchBtTRxMask(PADAPTER);
-void rtw_btcoex_Switch(PADAPTER, u8 enable);
 u8 rtw_btcoex_IsBtDisabled(PADAPTER);
 void rtw_btcoex_Handler(PADAPTER);
 s32 rtw_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER);
-u32 rtw_btcoex_GetAMPDUSize(PADAPTER);
 void rtw_btcoex_SetManualControl(PADAPTER, u8 bmanual);
-u8 rtw_btcoex_1Ant(PADAPTER);
 u8 rtw_btcoex_IsBtControlLps(PADAPTER);
 u8 rtw_btcoex_IsLpsOn(PADAPTER);
 u8 rtw_btcoex_RpwmVal(PADAPTER);
@@ -56,15 +52,12 @@ u8 rtw_btcoex_LpsVal(PADAPTER);
 void rtw_btcoex_SetBTCoexist(PADAPTER, u8 bBtExist);
 void rtw_btcoex_SetChipType(PADAPTER, u8 chipType);
 void rtw_btcoex_SetPGAntNum(PADAPTER, u8 antNum);
-u8 rtw_btcoex_GetPGAntNum(PADAPTER);
 void rtw_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
 u32 rtw_btcoex_GetRaMask(PADAPTER);
 void rtw_btcoex_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
 void rtw_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
 void rtw_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
 u32 rtw_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
-u8 rtw_btcoex_IncreaseScanDeviceNum(PADAPTER);
-u8 rtw_btcoex_IsBtLinkExist(PADAPTER);
 
 // ==================================================
 // Below Functions are called by BT-Coex
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_cmd.h linux/3rdparty/rtl8723bs/include/rtw_cmd.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_cmd.h	2015-05-10 14:36:05.728668569 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_cmd.h	2015-05-07 17:46:55.000000000 +0300
@@ -86,7 +86,7 @@
 
 #define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
 do {\
-	_rtw_init_listhead(&pcmd->list);\
+	INIT_LIST_HEAD(&pcmd->list);\
 	pcmd->cmdcode = code;\
 	pcmd->parmbuf = (u8 *)(pparm);\
 	pcmd->cmdsz = sizeof (*pparm);\
@@ -96,7 +96,7 @@ do {\
 
 #define init_h2fwcmd_w_parm_no_parm_rsp(pcmd, code) \
 do {\
-	_rtw_init_listhead(&pcmd->list);\
+	INIT_LIST_HEAD(&pcmd->list);\
 	pcmd->cmdcode = code;\
 	pcmd->parmbuf = NULL;\
 	pcmd->cmdsz = 0;\
@@ -148,7 +148,6 @@ extern void rtw_free_cmd_priv (struct cm
 
 extern u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
 extern void rtw_free_evt_priv (struct evt_priv *pevtpriv);
-extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
 extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
 
 enum rtw_drvextra_cmd_id
@@ -843,13 +842,9 @@ Result:
 #define H2C_CMD_OVERFLOW		0x06
 #define H2C_RESERVED			0x07
 
-extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
-extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
 u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num, struct rtw_ieee80211_channel *ch, int ch_num);
 extern u8 rtw_createbss_cmd(_adapter  *padapter);
-extern u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz);
 u8 rtw_startbss_cmd(_adapter  *padapter, int flags);
-extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
 
 struct sta_info;
 extern u8 rtw_setstakey_cmd(_adapter  *padapter, struct sta_info *sta, u8 unicast_key, bool enqueue);
@@ -859,14 +854,7 @@ extern u8 rtw_joinbss_cmd(_adapter  *pad
 u8 rtw_disassoc_cmd(_adapter *padapter, u32 deauth_timeout_ms, bool enqueue);
 extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, bool enqueue);
 extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
-extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
-extern u8 rtw_setbbreg_cmd(_adapter * padapter, u8 offset, u8 val);
-extern u8 rtw_setrfreg_cmd(_adapter * padapter, u8 offset, u32 val);
-extern u8 rtw_getbbreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
-extern u8 rtw_getrfreg_cmd(_adapter * padapter, u8 offset, u8 * pval);
 extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
-extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
-extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
 
 extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset,u8 *pval);
 extern u8 rtw_setfwdig_cmd(_adapter*padapter, u8 type);
@@ -880,29 +868,18 @@ extern u8 rtw_dynamic_chk_wk_cmd(_adapte
 
 u8 rtw_lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue);
 u8 rtw_dm_in_lps_wk_cmd(_adapter*padapter);
-u8 rtw_lps_change_dtim_cmd(_adapter*padapter, u8 dtim);
 
 u8 rtw_dm_ra_mask_wk_cmd(_adapter*padapter, u8 *psta);
 
 extern u8 rtw_ps_cmd(_adapter*padapter);
 
-#ifdef CONFIG_AP_MODE
 u8 rtw_chk_hi_queue_cmd(_adapter*padapter);
-#endif
 
-u8 rtw_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
-
-u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
 extern u8 rtw_set_chplan_cmd(_adapter*padapter, u8 chplan, u8 enqueue, u8 swconfig);
-extern u8 rtw_led_blink_cmd(_adapter*padapter, void * pLed);
-extern u8 rtw_set_csa_cmd(_adapter*padapter, u8 new_ch_no);
-extern u8 rtw_tdls_cmd(_adapter*padapter, u8 *addr, u8 option);
 
 extern u8 rtw_c2h_packet_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
 extern u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *c2h_evt);
 
-u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void*), void* context);
-
 u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);
 
 extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
@@ -910,7 +887,6 @@ extern void rtw_disassoc_cmd_callback(_a
 extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);	
 extern void rtw_createbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
 extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
 
 extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
 extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_debug.h linux/3rdparty/rtl8723bs/include/rtw_debug.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_debug.h	2015-05-10 14:36:05.728668569 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_debug.h	2015-05-07 17:46:55.000000000 +0300
@@ -314,13 +314,13 @@ ssize_t proc_set_read_reg(struct file *f
 int proc_get_fwstate(struct seq_file *m, void *v);
 int proc_get_sec_info(struct seq_file *m, void *v);
 int proc_get_mlmext_state(struct seq_file *m, void *v);
-#ifdef CONFIG_LAYER2_ROAMING
+
 int proc_get_roam_flags(struct seq_file *m, void *v);
 ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 int proc_get_roam_param(struct seq_file *m, void *v);
 ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
-#endif /* CONFIG_LAYER2_ROAMING */
+
 int proc_get_qos_option(struct seq_file *m, void *v);
 int proc_get_ht_option(struct seq_file *m, void *v);
 int proc_get_rf_info(struct seq_file *m, void *v);
@@ -335,9 +335,7 @@ int proc_get_suspend_resume_info(struct
 ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
-#ifdef CONFIG_AP_MODE
 int proc_get_all_sta_info(struct seq_file *m, void *v);
-#endif /* CONFIG_AP_MODE */
 
 int proc_get_rx_signal(struct seq_file *m, void *v);
 ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_eeprom.h linux/3rdparty/rtl8723bs/include/rtw_eeprom.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_eeprom.h	2015-05-10 14:36:05.729668580 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_eeprom.h	2015-05-07 17:46:55.000000000 +0300
@@ -130,13 +130,5 @@ struct eeprom_priv
 	u8		cis1[eeprom_cis1_sz];	
 };
 
-
-extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
-extern u16 eeprom_read16(_adapter *padapter, u16 reg);
-extern void read_eeprom_content(_adapter *padapter);
-extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz); 
-
-extern void read_eeprom_content_by_attrib(_adapter *	padapter	);
-
 #endif  //__RTL871X_EEPROM_H__
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_efuse.h linux/3rdparty/rtl8723bs/include/rtw_efuse.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_efuse.h	2015-05-10 14:36:05.729668580 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_efuse.h	2015-05-07 17:46:55.000000000 +0300
@@ -116,22 +116,12 @@ extern u8 fakeBTEfuseInitMap[];
 extern u8 fakeBTEfuseModifiedMap[];
 /*------------------------Export global variable----------------------------*/
 
-u8	efuse_GetCurrentSize(PADAPTER padapter, u16 *size);
-u16	efuse_GetMaxSize(PADAPTER padapter);
-u8	rtw_efuse_access(PADAPTER padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
-u8	rtw_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8	rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8	rtw_BT_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 	rtw_BT_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-
 u16	Efuse_GetCurrentSize(PADAPTER pAdapter, u8 efuseType, bool bPseudoTest);
 u8	Efuse_CalculateWordCnts(u8 word_en);
-void	ReadEFuseByte(PADAPTER Adapter, u16 _offset, u8 *pbuf, bool bPseudoTest) ;
 void	EFUSE_GetEfuseDefinition(PADAPTER pAdapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
 u8	efuse_OneByteRead(PADAPTER pAdapter, u16 addr, u8 *data, bool	 bPseudoTest);
 u8	efuse_OneByteWrite(PADAPTER pAdapter, u16 addr, u8 data, bool	 bPseudoTest);
 
-void	BTEfuse_PowerSwitch(PADAPTER pAdapter,u8	bWrite,u8	 PwrState);
 void	Efuse_PowerSwitch(PADAPTER pAdapter,u8	bWrite,u8	 PwrState);
 int 	Efuse_PgPacketRead(PADAPTER pAdapter, u8 offset, u8 *data, bool bPseudoTest);
 int 	Efuse_PgPacketWrite(PADAPTER pAdapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_ioctl_set.h linux/3rdparty/rtl8723bs/include/rtw_ioctl_set.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_ioctl_set.h	2015-05-10 14:36:05.729668580 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_ioctl_set.h	2015-05-07 17:46:55.000000000 +0300
@@ -29,26 +29,19 @@ typedef struct _BSSIDInfo {
 } BSSIDInfo, *PBSSIDInfo;
 
 
-u8 rtw_set_802_11_add_key(_adapter * padapter, NDIS_802_11_KEY * key);
 u8 rtw_set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
 u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid);
 u8 rtw_set_802_11_add_wep(_adapter * padapter, NDIS_802_11_WEP * wep);
 u8 rtw_set_802_11_disassociate(_adapter * padapter);
 u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, int ssid_max_num);
 u8 rtw_set_802_11_infrastructure_mode(_adapter * padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
-u8 rtw_set_802_11_remove_wep(_adapter * padapter, u32 keyindex);
 u8 rtw_set_802_11_ssid(_adapter * padapter, NDIS_802_11_SSID * ssid);
 u8 rtw_set_802_11_connect(_adapter* padapter, u8 *bssid, NDIS_802_11_SSID *ssid);
-u8 rtw_set_802_11_remove_key(_adapter * padapter, NDIS_802_11_REMOVE_KEY * key);
 
 u8 rtw_validate_bssid(u8 *bssid);
 u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
 
 u16 rtw_get_cur_max_rate(_adapter *adapter);
-int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
-int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
-int rtw_set_country(_adapter *adapter, const char *country_code);
-int rtw_set_band(_adapter *adapter, enum _BAND band);
 
 #endif
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_io.h linux/3rdparty/rtl8723bs/include/rtw_io.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_io.h	2015-05-10 14:36:05.730668591 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_io.h	2015-05-07 17:46:55.000000000 +0300
@@ -318,47 +318,24 @@ extern void _rtw_attrib_write(_adapter *
 extern u8 _rtw_read8(_adapter *adapter, u32 addr);
 extern u16 _rtw_read16(_adapter *adapter, u32 addr);
 extern u32 _rtw_read32(_adapter *adapter, u32 addr);
-extern void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
-extern void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
-extern void _rtw_read_port_cancel(_adapter *adapter);
-
 
 extern int _rtw_write8(_adapter *adapter, u32 addr, u8 val);
 extern int _rtw_write16(_adapter *adapter, u32 addr, u16 val);
 extern int _rtw_write32(_adapter *adapter, u32 addr, u32 val);
-extern int _rtw_writeN(_adapter *adapter, u32 addr, u32 length, u8 *pdata);
 
 extern u8 _rtw_sd_f0_read8(_adapter *adapter, u32 addr);
 
-extern int _rtw_write8_async(_adapter *adapter, u32 addr, u8 val);
-extern int _rtw_write16_async(_adapter *adapter, u32 addr, u16 val);
-extern int _rtw_write32_async(_adapter *adapter, u32 addr, u32 val);
-
-extern void _rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
 extern u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
-u32 _rtw_write_port_and_wait(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms);
-extern void _rtw_write_port_cancel(_adapter *adapter);
 
 #define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
 #define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
 #define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
-#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
-#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
-#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
 
 #define  rtw_write8(adapter, addr, val) _rtw_write8((adapter), (addr), (val))
 #define  rtw_write16(adapter, addr, val) _rtw_write16((adapter), (addr), (val))
 #define  rtw_write32(adapter, addr, val) _rtw_write32((adapter), (addr), (val))
-#define  rtw_writeN(adapter, addr, length, data) _rtw_writeN((adapter), (addr), (length), (data))
 
-#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
-#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
-#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
-
-#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), (addr), (cnt), (mem))
 #define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
-#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
-#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))
 
 #define rtw_sd_f0_read8(adapter, addr) _rtw_sd_f0_read8((adapter), (addr))
 
@@ -414,10 +391,6 @@ extern void dev_power_down(_adapter * Ad
 */
 
 /*
-#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(padapter, reg, val8)
-#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(padapter, reg, val16)
-#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(padapter, reg, val32)
-
 #define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
 #define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
 */
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_mlme_ext.h linux/3rdparty/rtl8723bs/include/rtw_mlme_ext.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_mlme_ext.h	2015-05-10 14:36:05.730668591 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_mlme_ext.h	2015-05-07 17:46:55.000000000 +0300
@@ -494,11 +494,9 @@ struct mlme_ext_priv
 	u8	mlmeext_init;
 	atomic_t		event_seq;
 	u16	mgnt_seq;
-#ifdef CONFIG_IEEE80211W
 	u16	sa_query_seq;
 	u64 mgnt_80211w_IPN;
 	u64 mgnt_80211w_IPN_rx;
-#endif //CONFIG_IEEE80211W
 	//struct fw_priv 	fwpriv;
 	
 	unsigned char	cur_channel;
@@ -518,9 +516,7 @@ struct mlme_ext_priv
                                                      //for ap mode, network includes ap's cap_info
 	_timer		survey_timer;
 	_timer		link_timer;
-#ifdef CONFIG_IEEE80211W
 	_timer		sa_query_timer;
-#endif //CONFIG_IEEE80211W
 	//_timer		ADDBA_timer;
 	u16			chan_scan_time;
 	unsigned long last_scan_time;
@@ -539,13 +535,10 @@ struct mlme_ext_priv
 	u8 DrvBcnEarly;
 	u8 DrvBcnTimeOut;
 
-#ifdef CONFIG_AP_MODE	
 	unsigned char bstart_bss;
-#endif
 
-#ifdef CONFIG_80211D
 	u8 update_channel_plan_by_ap_done;
-#endif
+
 	//recv_decache check for Action_public frame 
 	u8 action_public_dialog_token;
 	u16 	 action_public_rxseq;
@@ -564,19 +557,15 @@ void free_mlme_ext_priv (struct mlme_ext
 extern void init_mlme_ext_timer(_adapter *padapter);
 extern void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
 extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
-struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv);
 
 //void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv);
 
-unsigned char networktype_to_raid(_adapter *adapter,struct sta_info *psta);
 unsigned char networktype_to_raid_ex(_adapter *adapter, struct sta_info *psta);
 
-u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
 void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
 void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask);
 void UpdateBrateTbl(_adapter *padapter,u8 *mBratesOS);
 void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
-void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork);
 
 void Save_DM_Func_Flag(_adapter *padapter);
 void Restore_DM_Func_Flag(_adapter *padapter);
@@ -593,14 +582,10 @@ void rtw_set_oper_bw(_adapter *adapter,
 u8 rtw_get_oper_choffset(_adapter *adapter);
 void rtw_set_oper_choffset(_adapter *adapter, u8 offset);
 u8	rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset);
-u32 rtw_get_on_oper_ch_time(_adapter *adapter);
 unsigned long rtw_get_on_cur_ch_time(_adapter *adapter);
 
-u8 rtw_get_offset_by_ch(u8 channel);
-
 void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
 void SelectChannel(_adapter *padapter, unsigned char channel);
-void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
 
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
 
@@ -620,19 +605,15 @@ void write_cam_cache(_adapter *adapter,
 void clear_cam_cache(_adapter *adapter, u8 id);
 
 void invalidate_cam_all(_adapter *padapter);
-void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
 
 
 int allocate_fw_sta_entry(_adapter *padapter);
 void flush_all_cam_entry(_adapter *padapter);
 
-bool IsLegal5GChannel(PADAPTER Adapter, u8 channel);
-
 void site_survey(_adapter *padapter);
 u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
 void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter * padapter, bool update_ie);
 
-int get_bsstype(unsigned short capability);
 u8* get_my_bssid(WLAN_BSSID_EX *pnetwork);
 u16 get_beacon_interval(WLAN_BSSID_EX *bss);
 
@@ -658,15 +639,11 @@ int rtw_check_bcn_info(ADAPTER *Adapter,
 void update_IOT_info(_adapter *padapter);
 void update_capinfo(PADAPTER Adapter, u16 updateCap);
 void update_wireless_mode(_adapter * padapter);
-void update_tx_basic_rate(_adapter *padapter, u8 modulation);
 void update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode);
 int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx);
 
 //for sta/adhoc mode
 void update_sta_info(_adapter *padapter, struct sta_info *psta);
-unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
-unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
-unsigned int update_MCS_rate(struct HT_caps_element *pHT_caps);
 void Update_RA_Entry(_adapter *padapter, struct sta_info *psta);
 void set_sta_rate(_adapter *padapter, struct sta_info *psta);
 
@@ -675,10 +652,7 @@ unsigned int receive_disconnect(_adapter
 unsigned char get_highest_rate_idx(u32 mask);
 int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode);
 unsigned int is_ap_in_tkip(_adapter *padapter);
-unsigned int is_ap_in_wep(_adapter *padapter);
-unsigned int should_forbid_n_rate(_adapter * padapter);
 
-s16 rtw_get_camid(_adapter *adapter, struct sta_info* sta, s16 kid);
 s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid);
 s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid);
 void rtw_camid_free(_adapter *adapter, u8 cam_id);
@@ -718,11 +692,8 @@ s32 issue_nulldata_in_interrupt(PADAPTER
 int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
 int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
 int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
-void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset);
 void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status);
-#ifdef CONFIG_IEEE80211W
 void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid);
-#endif //CONFIG_IEEE80211W
 unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
 unsigned int send_beacon(_adapter *padapter);
 
@@ -748,9 +719,7 @@ unsigned int on_action_spct(_adapter *pa
 unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
 unsigned int on_action_public(_adapter *padapter, union recv_frame *precv_frame);
 unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
-#ifdef CONFIG_IEEE80211W
 unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame);
-#endif //CONFIG_IEEE80211W
 
 void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
 void mlmeext_sta_del_event_callback(_adapter *padapter);
@@ -763,9 +732,7 @@ void _linked_info_dump(_adapter *padapte
 void survey_timer_hdl (_adapter *padapter);
 void link_timer_hdl (_adapter *padapter);
 void addba_timer_hdl(struct sta_info *psta);
-#ifdef CONFIG_IEEE80211W
 void sa_query_timer_hdl(_adapter *padapter);
-#endif //CONFIG_IEEE80211W
 //void reauth_timer_hdl(_adapter *padapter);
 //void reassoc_timer_hdl(_adapter *padapter);
 
@@ -780,13 +747,11 @@ void sa_query_timer_hdl(_adapter *padapt
 		/*DBG_871X("%s set_link_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
 		_set_timer(&(mlmeext)->link_timer, (ms)); \
 	} while(0)
-#ifdef CONFIG_IEEE80211W
 #define set_sa_query_timer(mlmeext, ms) \
 	do { \
 		DBG_871X("%s set_sa_query_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms)); \
 		_set_timer(&(mlmeext)->sa_query_timer, (ms)); \
 	} while(0)
-#endif //CONFIG_IEEE80211W
 extern int cckrates_included(unsigned char *rate, int ratelen);
 extern int cckratesonly_included(unsigned char *rate, int ratelen);
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_mlme.h linux/3rdparty/rtl8723bs/include/rtw_mlme.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_mlme.h	2015-05-10 14:36:05.731668602 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_mlme.h	2015-05-07 17:46:55.000000000 +0300
@@ -349,7 +349,7 @@ struct mlme_priv {
 	sint	fw_state;	//shall we protect this variable? maybe not necessarily...
 	u8 bScanInProcess;
 	u8	to_join; //flag
-	#ifdef CONFIG_LAYER2_ROAMING
+
 	u8 to_roam; /* roaming trying times */
 	struct wlan_network *roam_network; /* the target of active roam */
 	u8 roam_flags;
@@ -357,7 +357,6 @@ struct mlme_priv {
 	u32 roam_scan_int_ms; /* scan interval for active roam */
 	u32 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
 	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
-	#endif
 
 	u8	*nic_hdl;
 
@@ -412,7 +411,6 @@ struct mlme_priv {
 	u8 *wps_probe_req_ie;
 	u32 wps_probe_req_ie_len;
 
-#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
 	 * in 802.11g BSS) */
 	int num_sta_non_erp;
@@ -468,9 +466,6 @@ struct mlme_priv {
 
 	_lock	bcn_update_lock;
 	u8		update_bcn;
-	
-	
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 #ifdef CONFIG_INTEL_WIDI
 	int	widi_state;
@@ -510,8 +505,6 @@ struct mlme_priv {
 
 void rtw_mlme_reset_auto_scan_int(_adapter *adapter);
 
-#ifdef CONFIG_AP_MODE
-
 struct hostapd_priv
 {
 	_adapter *padapter;
@@ -519,8 +512,6 @@ struct hostapd_priv
 
 extern int hostapd_mode_init(_adapter *padapter);
 extern void hostapd_mode_unload(_adapter *padapter);
-#endif
-
 
 extern void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf);
 extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
@@ -597,48 +588,17 @@ __inline static void _clr_fwstate_(struc
  */
 __inline static void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	if (check_fwstate(pmlmepriv, state) == true)
 		pmlmepriv->fw_state ^= state;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-}
-
-__inline static void clr_fwstate_ex(struct mlme_priv *pmlmepriv, sint state)
-{
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_clr_fwstate_(pmlmepriv, state);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-}
-
-__inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
-{
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	pmlmepriv->num_of_scanned++;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-}
-
-__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
-{
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	pmlmepriv->num_of_scanned--;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 __inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	pmlmepriv->num_of_scanned = val;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
@@ -648,7 +608,6 @@ extern void rtw_generate_random_ibss(u8
 extern struct wlan_network* rtw_find_network(_queue *scanned_queue, u8 *addr);
 extern struct wlan_network* rtw_get_oldest_wlan_network(_queue *scanned_queue);
 struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
-struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
 
 extern void rtw_free_assoc_resources(_adapter* adapter, int lock_scanned_queue);
 extern void rtw_indicate_disconnect(_adapter* adapter);
@@ -679,8 +638,6 @@ void rtw_free_mlme_priv_ie_data(struct m
 
 extern void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
 
-extern int _rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
-
 //extern struct wlan_network* _rtw_dequeue_network(_queue *queue);
 
 extern struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
@@ -699,7 +656,6 @@ extern sint rtw_if_up(_adapter *padapter
 sint rtw_linked_check(_adapter *padapter);
 
 u8 *rtw_get_capability_from_ie(u8 *ie);
-u8 *rtw_get_timestampe_from_ie(u8 *ie);
 u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
 
 
@@ -715,7 +671,6 @@ void rtw_append_exented_cap(_adapter *pa
 int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
 int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature);
 
-#ifdef CONFIG_LAYER2_ROAMING
 #define rtw_roam_flags(adapter) ((adapter)->mlmepriv.roam_flags)
 #define rtw_chk_roam_flags(adapter, flags) ((adapter)->mlmepriv.roam_flags & flags)
 #define rtw_clr_roam_flags(adapter, flags) \
@@ -739,19 +694,6 @@ void rtw_set_to_roam(_adapter *adapter,
 u8 rtw_dec_to_roam(_adapter *adapter);
 u8 rtw_to_roam(_adapter *adapter);
 int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
-#else
-#define rtw_roam_flags(adapter) 0
-#define rtw_chk_roam_flags(adapter, flags) 0
-#define rtw_clr_roam_flags(adapter, flags) do {} while (0)
-#define rtw_set_roam_flags(adapter, flags) do {} while (0)
-#define rtw_assign_roam_flags(adapter, flags) do {} while (0)
-#define _rtw_roaming(adapter, tgt_network) do {} while(0)
-#define rtw_roaming(adapter, tgt_network) do {} while(0)
-#define rtw_set_to_roam(adapter, to_roam) do {} while(0)
-#define rtw_dec_to_roam(adapter) 0
-#define rtw_to_roam(adapter) 0
-#define rtw_select_roaming_candidate(mlme) _FAIL
-#endif /* CONFIG_LAYER2_ROAMING */
 
 void rtw_sta_media_status_rpt(_adapter *adapter,struct sta_info *psta, u32 mstatus);
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_pwrctrl.h linux/3rdparty/rtl8723bs/include/rtw_pwrctrl.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_pwrctrl.h	2015-05-10 14:36:05.731668602 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_pwrctrl.h	2015-05-07 17:46:55.000000000 +0300
@@ -347,12 +347,8 @@ s32 rtw_register_task_alive(PADAPTER, u3
 void rtw_unregister_task_alive(PADAPTER, u32 task);
 extern s32 rtw_register_tx_alive(PADAPTER padapter);
 extern void rtw_unregister_tx_alive(PADAPTER padapter);
-extern s32 rtw_register_rx_alive(PADAPTER padapter);
-extern void rtw_unregister_rx_alive(PADAPTER padapter);
 extern s32 rtw_register_cmd_alive(PADAPTER padapter);
 extern void rtw_unregister_cmd_alive(PADAPTER padapter);
-extern s32 rtw_register_evt_alive(PADAPTER padapter);
-extern void rtw_unregister_evt_alive(PADAPTER padapter);
 extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportpwrstate);
 extern void LPS_Leave_check(PADAPTER padapter);
 
@@ -365,8 +361,6 @@ int ips_leave(_adapter * padapter);
 
 void rtw_ps_processor(_adapter*padapter);
 
-int rtw_fw_ps_state(PADAPTER padapter);
-
 s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
 void LPS_Enter(PADAPTER padapter, const char *msg);
 void LPS_Leave(PADAPTER padapter, const char *msg);
@@ -374,7 +368,6 @@ void traffic_check_for_leave_lps(PADAPTE
 void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
 void rtw_set_rpwm(_adapter * padapter, u8 val8);
 
-u8 rtw_interface_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id,u8* val);
 void rtw_set_ips_deny(_adapter *padapter, u32 ms);
 int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller);
 #define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __FUNCTION__)
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_recv.h linux/3rdparty/rtl8723bs/include/rtw_recv.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_recv.h	2015-05-10 14:36:05.732668613 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_recv.h	2015-05-07 17:46:55.000000000 +0300
@@ -439,15 +439,6 @@ struct recv_frame_hdr
 
 	//for A-MPDU Rx reordering buffer control
 	struct recv_reorder_ctrl *preorder_ctrl;
-
-#ifdef CONFIG_WAPI_SUPPORT
-	u8 UserPriority;
-	u8 WapiTempPN[16];
-	u8 WapiSrcAddr[6];
-	u8 bWapiCheckPNInDecrypt;
-	u8 bIsWaiPacket;
-#endif
-
 };
 
 
@@ -473,7 +464,6 @@ typedef enum _RX_PACKET_TYPE{
 
 extern union recv_frame *_rtw_alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
 extern union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
-extern void rtw_init_recvframe(union recv_frame *precvframe ,struct recv_priv *precvpriv);
 extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);
 
 #define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
@@ -498,13 +488,6 @@ __inline static u8 *get_rxmem(union recv
 	return precvframe->u.hdr.rx_head;
 }
 
-__inline static u8 *get_rx_status(union recv_frame *precvframe)
-{
-
-	return get_rxmem(precvframe);
-
-}
-
 __inline static u8 *get_recvframe_data(union recv_frame *precvframe)
 {
 
@@ -516,34 +499,6 @@ __inline static u8 *get_recvframe_data(u
 
 }
 
-__inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
-{
-	// append data before rx_data
-
-	/* add data to the start of recv_frame
- *
- *      This function extends the used data area of the recv_frame at the buffer
- *      start. rx_data must be still larger than rx_head, after pushing.
- */
-
-	if(precvframe==NULL)
-		return NULL;
-
-
-	precvframe->u.hdr.rx_data -= sz ;
-	if( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
-	{
-		precvframe->u.hdr.rx_data += sz ;
-		return NULL;
-	}
-
-	precvframe->u.hdr.len +=sz;
-
-	return precvframe->u.hdr.rx_data;
-
-}
-
-
 __inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
 {
 	// rx_data += sz; move rx_data sz bytes  hereafter
@@ -586,7 +541,7 @@ __inline static u8 *recvframe_put(union
 
 	if(precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
 	{
-		precvframe->u.hdr.rx_tail -= sz;
+		precvframe->u.hdr.rx_tail = prev_rx_tail;
 		return NULL;
 	}
 
@@ -622,18 +577,6 @@ __inline static u8 *recvframe_pull_tail(
 
 }
 
-
-
-__inline static _buffer * get_rxbuf_desc(union recv_frame *precvframe)
-{
-	_buffer * buf_desc;
-
-	if(precvframe==NULL)
-		return NULL;
-	return buf_desc;
-}
-
-
 __inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
 {
 	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame
@@ -644,37 +587,6 @@ __inline static union recv_frame *rxmem_
 
 }
 
-__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
-{
-
-	u8 * buf_star;
-	union recv_frame * precv_frame;
-	precv_frame = rxmem_to_recvframe((unsigned char*)buf_star);
-
-	return precv_frame;
-}
-
-__inline static u8 *pkt_to_recvmem(_pkt *pkt)
-{
-	// return the rx_head
-
-	union recv_frame * precv_frame = pkt_to_recvframe(pkt);
-
-	return 	precv_frame->u.hdr.rx_head;
-
-}
-
-__inline static u8 *pkt_to_recvdata(_pkt *pkt)
-{
-	// return the rx_data
-
-	union recv_frame * precv_frame =pkt_to_recvframe(pkt);
-
-	return 	precv_frame->u.hdr.rx_data;
-
-}
-
-
 __inline static sint get_recvframe_len(union recv_frame *precvframe)
 {
 	return precvframe->u.hdr.len;
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_rf.h linux/3rdparty/rtl8723bs/include/rtw_rf.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_rf.h	2015-05-10 14:36:05.732668613 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_rf.h	2015-05-07 17:46:55.000000000 +0300
@@ -168,8 +168,6 @@ typedef	enum _RT_RF_TYPE_DEFINITION
 
 
 u32 rtw_ch2freq(u32 ch);
-u32 rtw_freq2ch(u32 freq);
-
 
 #endif //_RTL8711_RF_H_
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_security.h linux/3rdparty/rtl8723bs/include/rtw_security.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_security.h	2015-05-10 14:36:05.732668613 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_security.h	2015-05-07 17:46:55.000000000 +0300
@@ -29,9 +29,7 @@
 #define _WEP104_			0x5
 #define _WEP_WPA_MIXED_	0x07  // WEP + WPA
 #define _SMS4_				0x06
-#ifdef CONFIG_IEEE80211W
 #define _BIP_				0x8 
-#endif //CONFIG_IEEE80211W
 #define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
 
 const char *security_type_str(u8 value);
@@ -134,13 +132,11 @@ struct security_priv
 	union Keytype	dot118021XGrprxmickey[4];
 	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
 	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
-#ifdef CONFIG_IEEE80211W
 	u32	dot11wBIPKeyid;						// key id used for BIP Key ( tx key index)
 	union Keytype	dot11wBIPKey[6];		// BIP Key, for index4 and index5
 	union pn48		dot11wBIPtxpn;			// PN48 used for Grp Key xmit.
 	union pn48		dot11wBIPrxpn;			// PN48 used for Grp Key recv.
-#endif //CONFIG_IEEE80211W
-#ifdef CONFIG_AP_MODE
+
 	//extend security capabilities for AP_MODE 
 	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
 	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
@@ -148,7 +144,6 @@ struct security_priv
 	unsigned int wpa2_group_cipher;
 	unsigned int wpa_pairwise_cipher;
 	unsigned int wpa2_pairwise_cipher;	
-#endif
 
 	u8 wps_ie[MAX_WPS_IE_LEN];//added in assoc req
 	int wps_ie_len;
@@ -158,9 +153,7 @@ struct security_priv
 #ifdef CONFIG_GTK_OL
 	u8	binstallKCK_KEK;
 #endif //CONFIG_GTK_OL
-#ifdef CONFIG_IEEE80211W
 	u8	binstallBIPkey;
-#endif //CONFIG_IEEE80211W
 	u8	busetkipkey;
 	//_timer tkip_timer;
 	u8	bcheck_grpkey;
@@ -455,11 +448,7 @@ void rtw_wep_encrypt(_adapter *padapter,
 u32 rtw_aes_decrypt(_adapter *padapter, u8  *precvframe);
 u32 rtw_tkip_decrypt(_adapter *padapter, u8  *precvframe);
 void rtw_wep_decrypt(_adapter *padapter, u8  *precvframe);
-#ifdef CONFIG_IEEE80211W
 u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe);
-#endif //CONFIG_IEEE80211W
-
-void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS);
 
 void rtw_sec_restore_wep_key(_adapter *adapter);
 u8 rtw_handle_tkip_countermeasure(_adapter* adapter, const char *caller);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_wapi.h linux/3rdparty/rtl8723bs/include/rtw_wapi.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_wapi.h	2015-05-10 14:36:05.732668613 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_wapi.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,222 +0,0 @@
-#ifndef __INC_WAPI_H
-#define __INC_WAPI_H
-
-
-#define CONFIG_WAPI_SW_SMS4
-#define WAPI_DEBUG
-
-#define SMS4_MIC_LEN                16
-#define WAPI_EXT_LEN                18
-#define MAX_WAPI_IE_LEN		    256
-#define sMacHdrLng				24		// octets in data header, no WEP
-
-#ifdef WAPI_DEBUG
-
-/* WAPI trace debug */
-extern u32 wapi_debug_component;
-
-static inline void dump_buf(u8 *buf, u32 len)
-{
-	u32 i;
-	printk("-----------------Len %d----------------\n", len);
-	for(i=0; i<len; i++)
-		printk("%2.2x-", *(buf+i));
-	printk("\n");
-}
-
-#define WAPI_TRACE(component, x, args...) \
-do { if(wapi_debug_component & (component)) \
-	printk(KERN_DEBUG "WAPI" ":" x "" , \
-	       ##args);\
-}while(0);
-
-#define WAPI_DATA(component, x, buf, len) \
-do { if(wapi_debug_component & (component)){ \
-	printk("%s:\n", x);\
-	dump_buf((buf), (len));}\
-}while(0);
-
-#define RT_ASSERT_RET(_Exp)								\
-		if(!(_Exp))									\
-		{											\
-			printk("RTWLAN: ");					\
-                	printk( "Assertion failed! %s,%s,line=%d\n", \
-                	#_Exp,__FUNCTION__,__LINE__);          \
-			return;						\
-		}
-#define RT_ASSERT_RET_VALUE(_Exp,Ret)								\
-		if(!(_Exp))									\
-		{											\
-			printk("RTWLAN: ");					\
-                	printk( "Assertion failed! %s,%s,line=%d\n", \
-                	#_Exp,__FUNCTION__,__LINE__);          \
-			return (Ret);						\
-		}
-
-#else
-#define RT_ASSERT_RET(_Exp) do {} while(0)
-#define RT_ASSERT_RET_VALUE(_Exp,Ret) do {} while(0)
-#define WAPI_TRACE(component, x, args...) do {} while(0)
-#define WAPI_DATA(component, x, buf, len) do {} while(0)
-#endif
-
-
-enum WAPI_DEBUG {
-	WAPI_INIT				= 1,
-	WAPI_API				= 1<<1,
-	WAPI_TX				= 1<<2,
-	WAPI_RX				= 1<<3,
-	WAPI_MLME				= 1<<4,
-	WAPI_IOCTL				= 1<<5,
-	WAPI_ERR		        	= 1<<31
-};
-
-#define			WAPI_MAX_BKID_NUM				4
-#define			WAPI_MAX_STAINFO_NUM			4
-#define			WAPI_CAM_ENTRY_NUM			14	// 28/2=14
-
-typedef struct  _RT_WAPI_BKID
-{
-	struct list_head	list;
-	u8				bkid[16];
-}RT_WAPI_BKID,*PRT_WAPI_BKID;
-
-typedef struct  _RT_WAPI_KEY
-{
-	u8			dataKey[16];
-	u8			micKey[16];
-	u8			keyId;
-	bool			bSet;
-	bool             bTxEnable;
-}RT_WAPI_KEY,*PRT_WAPI_KEY;
-
-typedef enum _RT_WAPI_PACKET_TYPE
-{
-	WAPI_NONE = 0,
-	WAPI_PREAUTHENTICATE=1,
-	WAPI_STAKEY_REQUEST=2,
-	WAPI_AUTHENTICATE_ACTIVE=3,
-	WAPI_ACCESS_AUTHENTICATE_REQUEST=4,
-	WAPI_ACCESS_AUTHENTICATE_RESPONSE=5,
-	WAPI_CERTIFICATE_AUTHENTICATE_REQUEST=6,
-	WAPI_CERTIFICATE_AUTHENTICATE_RESPONSE=7,
-	WAPI_USK_REQUEST=8,
-	WAPI_USK_RESPONSE=9,
-	WAPI_USK_CONFIRM=10,
-	WAPI_MSK_NOTIFICATION=11,
-	WAPI_MSK_RESPONSE=12
-}RT_WAPI_PACKET_TYPE;
-
-typedef struct	_RT_WAPI_STA_INFO
-{
-	struct list_head		list;
-	u8					PeerMacAddr[6];
-	RT_WAPI_KEY		      wapiUsk;
-	RT_WAPI_KEY		      wapiUskUpdate;
-	RT_WAPI_KEY		      wapiMsk;
-	RT_WAPI_KEY		      wapiMskUpdate;
-	u8					lastRxUnicastPN[16];
-	u8					lastTxUnicastPN[16];
-	u8					lastRxMulticastPN[16];
-	u8					lastRxUnicastPNBEQueue[16];
-	u8					lastRxUnicastPNBKQueue[16];
-	u8					lastRxUnicastPNVIQueue[16];
-	u8					lastRxUnicastPNVOQueue[16];
-	bool					bSetkeyOk;
-	bool					bAuthenticateInProgress;
-	bool					bAuthenticatorInUpdata;
-}RT_WAPI_STA_INFO,*PRT_WAPI_STA_INFO;
-
-//Added for HW wapi en/decryption
-typedef struct _RT_WAPI_CAM_ENTRY{
-	//RT_LIST_ENTRY		list;
-	u8			IsUsed;
-	u8			entry_idx;//for cam entry
-	u8			keyidx;	// 0 or 1,new or old key
-	u8			PeerMacAddr[6];
-	u8			type;	//should be 110,wapi
-}RT_WAPI_CAM_ENTRY,*PRT_WAPI_CAM_ENTRY;
-
-typedef struct _RT_WAPI_T
-{
-//BKID
-	RT_WAPI_BKID		wapiBKID[WAPI_MAX_BKID_NUM];
-	struct list_head		wapiBKIDIdleList;
-	struct list_head  		wapiBKIDStoreList;
-//Key for Tx Multicast/Broadcast
-	RT_WAPI_KEY		      wapiTxMsk;
-
-//sec related
-	u8				lastTxMulticastPN[16];
-//STA list
-	RT_WAPI_STA_INFO	wapiSta[WAPI_MAX_STAINFO_NUM];
-	struct list_head		wapiSTAIdleList;
-	struct list_head		wapiSTAUsedList;
-//
-	bool				bWapiEnable;
-
-//store WAPI IE
-	u8				wapiIE[256];
-	u8				wapiIELength;
-	bool				bWapiPSK;
-//last sequece number for wai packet
-	u16				wapiSeqnumAndFragNum;
-	int extra_prefix_len;
-	int extra_postfix_len;
-
-	RT_WAPI_CAM_ENTRY	wapiCamEntry[WAPI_CAM_ENTRY_NUM];
-}RT_WAPI_T,*PRT_WAPI_T;
-
-typedef struct _WLAN_HEADER_WAPI_EXTENSION
-{
-    u8      KeyIdx;
-    u8      Reserved;
-    u8      PN[16];
-} WLAN_HEADER_WAPI_EXTENSION, *PWLAN_HEADER_WAPI_EXTENSION;
-
-u32 WapiComparePN(u8 *PN1, u8 *PN2);
-
-
-void rtw_wapi_init(_adapter *padapter);
-
-void rtw_wapi_free(_adapter *padapter);
-
-void rtw_wapi_disable_tx(_adapter *padapter);
-
-u8 rtw_wapi_is_wai_packet(_adapter* padapter,u8 *pkt_data);
-
-void rtw_wapi_update_info(_adapter *padapter, union recv_frame *precv_frame);
-
-u8 rtw_wapi_check_for_drop(_adapter *padapter, union recv_frame *precv_frame);
-
-void rtw_build_probe_resp_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
-
-void rtw_build_beacon_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
-
-void rtw_build_assoc_req_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
-
-void rtw_wapi_on_assoc_ok(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
-
-void rtw_wapi_return_one_sta_info(_adapter *padapter, u8 *MacAddr);
-
-void rtw_wapi_return_all_sta_info(_adapter *padapter);
-
-void rtw_wapi_clear_cam_entry(_adapter *padapter, u8 *pMacAddr);
-
-void rtw_wapi_clear_all_cam_entry(_adapter *padapter);
-
-void rtw_wapi_set_key(_adapter *padapter, RT_WAPI_KEY *pWapiKey, RT_WAPI_STA_INFO *pWapiSta, u8 bGroupKey, u8 bUseDefaultKey);
-
-int rtw_wapi_create_event_send(_adapter *padapter, u8 EventId, u8 *MacAddr, u8 *Buff, u16 BufLen);
-
-u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe);
-
-u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe);
-
-void rtw_wapi_get_iv(_adapter *padapter, u8*pRA, u8*IV);
-
-u8 WapiIncreasePN(u8 *PN, u8 AddCount);
-
-bool rtw_wapi_drop_for_key_absent(_adapter *padapter,u8 *pRA);
-
-#endif
diff -Nurp linux/3rdparty/rtl8723bs.old/include/rtw_xmit.h linux/3rdparty/rtl8723bs/include/rtw_xmit.h
--- linux/3rdparty/rtl8723bs.old/include/rtw_xmit.h	2015-05-10 14:36:05.733668625 +0300
+++ linux/3rdparty/rtl8723bs/include/rtw_xmit.h	2015-05-07 17:46:55.000000000 +0300
@@ -482,21 +482,17 @@ extern s32 rtw_free_xmitframe(struct xmi
 extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue);
 struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac);
 extern s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
-extern struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry);
 
 extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
 extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
 #define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
 extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
-#ifdef CONFIG_IEEE80211W
 extern s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
-#endif //CONFIG_IEEE80211W
 s32 _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
 void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
 
 
 s32 rtw_txframes_pending(_adapter *padapter);
-s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
 void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry);
 
 
@@ -510,12 +506,11 @@ void rtw_free_hwxmits(_adapter *padapter
 
 s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
 bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
-#if defined(CONFIG_AP_MODE)
+
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
 void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
 void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
 void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
-#endif
 
 u8	query_ra_short_GI(struct sta_info *psta);
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/sdio_ops.h linux/3rdparty/rtl8723bs/include/sdio_ops.h
--- linux/3rdparty/rtl8723bs.old/include/sdio_ops.h	2015-05-10 14:36:05.733668625 +0300
+++ linux/3rdparty/rtl8723bs/include/sdio_ops.h	2015-05-07 17:46:55.000000000 +0300
@@ -29,9 +29,7 @@ extern void sdio_set_intf_ops(_adapter *
 //extern void sdio_func1cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
 extern u8 SdioLocalCmd52Read1Byte(PADAPTER padapter, u32 addr);
 extern void SdioLocalCmd52Write1Byte(PADAPTER padapter, u32 addr, u8 v);
-extern s32 _sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
 extern s32 sdio_local_read(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
-extern s32 _sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
 extern s32 sdio_local_write(PADAPTER padapter, u32 addr, u32 cnt, u8 *pbuf);
 
 u32 _sdio_read32(PADAPTER padapter, u32 addr);
@@ -50,7 +48,6 @@ extern void DisableInterrupt8723BSdio(PA
 extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
 extern u8 HalQueryTxOQTBufferStatus8723BSdio(PADAPTER padapter);
 #if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
-extern void DisableInterruptButCpwm28723BSdio(PADAPTER padapter);
 extern void ClearInterrupt8723BSdio(PADAPTER padapter);
 #endif //CONFIG_WOWLAN
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/sdio_ops_linux.h linux/3rdparty/rtl8723bs/include/sdio_ops_linux.h
--- linux/3rdparty/rtl8723bs.old/include/sdio_ops_linux.h	2015-05-10 14:36:05.733668625 +0300
+++ linux/3rdparty/rtl8723bs/include/sdio_ops_linux.h	2015-05-07 17:46:55.000000000 +0300
@@ -25,23 +25,17 @@
 #define SDIO_ERR_VAL32	0xEAEAEAEA
 
 u8 sd_f0_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
-void sd_f0_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);
 
 s32 _sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
 s32 _sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
 s32 sd_cmd52_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
 s32 sd_cmd52_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pdata);
 
-u8 _sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
 u8 sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
-u16 sd_read16(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
-u32 _sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
 u32 sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err);
 s32 _sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
 s32 sd_read(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
 void sd_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err);
-void sd_write16(struct intf_hdl *pintfhdl, u32 addr, u16 v, s32 *err);
-void _sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
 void sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err);
 s32 _sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
 s32 sd_write(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, void *pdata);
diff -Nurp linux/3rdparty/rtl8723bs.old/include/sta_info.h linux/3rdparty/rtl8723bs/include/sta_info.h
--- linux/3rdparty/rtl8723bs.old/include/sta_info.h	2015-05-10 14:36:05.733668625 +0300
+++ linux/3rdparty/rtl8723bs/include/sta_info.h	2015-05-07 17:46:55.000000000 +0300
@@ -113,9 +113,7 @@ struct sta_info {
 	u8 kck[RTW_KCK_LEN];
 	u8 replay_ctr[RTW_REPLAY_CTR_LEN];
 #endif //CONFIG_GTK_OL
-#ifdef CONFIG_IEEE80211W
 	union pn48		dot11wtxpn;			// PN48 used for Unicast mgmt xmit.
-#endif //CONFIG_IEEE80211W
 	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
 
 
@@ -159,8 +157,6 @@ struct sta_info {
 	//AP_Mode:
 	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
 	//sta_info: (AP & STA) CAP/INFO
-		
-#ifdef CONFIG_AP_MODE
 
 	_list asoc_list;
 	_list auth_list;
@@ -182,7 +178,6 @@ struct sta_info {
 
 	u8 bpairwise_key_installed;
 
-#ifdef CONFIG_NATIVEAP_MLME
 	u8 wpa_ie[32];
 
 	u8 nonerp_set;
@@ -191,7 +186,6 @@ struct sta_info {
 	u8 no_ht_gf_set;
 	u8 no_ht_set;
 	u8 ht_20mhz_set;
-#endif	// CONFIG_NATIVEAP_MLME
 
 	unsigned int tx_ra_bitmap;
 	u8 qos_info;
@@ -205,10 +199,8 @@ struct sta_info {
 	u8 has_legacy_ac;
 	unsigned int sleepq_ac_len;
 
-#ifdef CONFIG_TX_MCAST2UNI
 	u8 under_exist_checking;
-#endif	// CONFIG_TX_MCAST2UNI
-	
+
 	u8 keep_alive_trycnt;
 
 #ifdef CONFIG_AUTO_AP_MODE
@@ -216,8 +208,6 @@ struct sta_info {
 	u16 pid; // pairing id
 #endif
 
-#endif	// CONFIG_AP_MODE	
-
 	u8 *passoc_req;
 	u32 assoc_req_len;
 
@@ -348,9 +338,7 @@ struct	sta_priv {
 	_queue wakeup_q;
 	
 	_adapter *padapter;
-	
 
-#ifdef CONFIG_AP_MODE
 	_list asoc_list;
 	_list auth_list;
 	_lock asoc_list_lock;
@@ -374,7 +362,6 @@ struct	sta_priv {
 	u16 max_num_sta;
 
 	struct wlan_acl_pool acl_list;
-#endif
 };
 
 
diff -Nurp linux/3rdparty/rtl8723bs.old/include/wifi.h linux/3rdparty/rtl8723bs/include/wifi.h
--- linux/3rdparty/rtl8723bs.old/include/wifi.h	2015-05-10 14:36:05.734668636 +0300
+++ linux/3rdparty/rtl8723bs/include/wifi.h	2015-05-07 17:46:55.000000000 +0300
@@ -541,9 +541,7 @@ __inline static int IsFrameTypeCtrl(unsi
 //#define EID_BSSCoexistence			72 // 20/40 BSS Coexistence
 //#define EID_BSSIntolerantChlReport	73
 #define _RIC_Descriptor_IE_			75
-#ifdef CONFIG_IEEE80211W
 #define _MME_IE_					76 //802.11w Management MIC element
-#endif //CONFIG_IEEE80211W
 #define _LINK_ID_IE_					101
 #define _CH_SWITCH_TIMING_		104
 #define _PTI_BUFFER_STATUS_		106
@@ -677,9 +675,7 @@ typedef	enum _ELEMENT_ID{
 #define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
 */
 
-#ifdef CONFIG_IEEE80211W
 #define _MME_IE_LENGTH_  18
-#endif //CONFIG_IEEE80211W				
 /*-----------------------------------------------------------------------------
 				Below is the definition for WMM
 ------------------------------------------------------------------------------*/
@@ -1185,15 +1181,12 @@ enum P2P_PROTO_WK_ID
 #define	WFD_DEVINFO_PC_TDLS					0x0080
 #define	WFD_DEVINFO_HDCP_SUPPORT			0x0100
 
-#ifdef  CONFIG_TX_MCAST2UNI
 #define IP_MCAST_MAC(mac)		((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
 #define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
-#endif	// CONFIG_TX_MCAST2UNI
 
 /* Regulatroy Domain */
 struct regd_pair_mapping {
 	u16 reg_dmnenum;
-	u16 reg_5ghz_ctl;
 	u16 reg_2ghz_ctl;
 };
 
@@ -1208,20 +1201,5 @@ struct rtw_regulatory {
 	struct regd_pair_mapping *regpair;
 };
 
-#ifdef CONFIG_WAPI_SUPPORT
-#ifndef IW_AUTH_WAPI_VERSION_1
-#define IW_AUTH_WAPI_VERSION_1		0x00000008
-#endif
-#ifndef IW_AUTH_KEY_MGMT_WAPI_PSK
-#define IW_AUTH_KEY_MGMT_WAPI_PSK	0x04
-#endif
-#ifndef IW_AUTH_WAPI_ENABLED
-#define IW_AUTH_WAPI_ENABLED		0x20
-#endif
-#ifndef IW_ENCODE_ALG_SM4
-#define IW_ENCODE_ALG_SM4			0x20
-#endif
-#endif
-
 #endif // _WIFI_H_
 
diff -Nurp linux/3rdparty/rtl8723bs.old/Makefile linux/3rdparty/rtl8723bs/Makefile
--- linux/3rdparty/rtl8723bs.old/Makefile	2015-05-10 14:36:05.745668758 +0300
+++ linux/3rdparty/rtl8723bs/Makefile	2015-05-07 17:46:55.000000000 +0300
@@ -8,11 +8,11 @@ EXTRA_CFLAGS += -O1
 #EXTRA_CFLAGS += -Wshadow -Wpointer-arith -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes
 
 EXTRA_CFLAGS += -Wno-unused-variable
-#EXTRA_CFLAGS += -Wno-unused-value
-#EXTRA_CFLAGS += -Wno-unused-label
-#EXTRA_CFLAGS += -Wno-unused-parameter
-#EXTRA_CFLAGS += -Wno-unused-function
-#EXTRA_CFLAGS += -Wno-unused
+EXTRA_CFLAGS += -Wno-unused-value
+EXTRA_CFLAGS += -Wno-unused-label
+EXTRA_CFLAGS += -Wno-unused-parameter
+EXTRA_CFLAGS += -Wno-unused-function
+EXTRA_CFLAGS += -Wno-unused
 
 #EXTRA_CFLAGS += -Wno-uninitialized
 
@@ -23,7 +23,6 @@ EXTRA_LDFLAGS += --strip-debug
 ########################## Features ###########################
 CONFIG_HW_PWRP_DETECTION = n
 CONFIG_INTEL_WIDI = n
-CONFIG_WAPI_SUPPORT = n
 CONFIG_EXT_CLK = n
 CONFIG_TRAFFIC_PROTECT = y
 CONFIG_LOAD_PHY_PARA_FROM_FILE = y
@@ -43,8 +42,6 @@ CONFIG_RTW_SDIO_PM_KEEP_POWER = y
 CONFIG_PLATFORM_I386_PC = y
 ###############################################################
 
-CONFIG_DRVEXT_MODULE = n
-
 ########### COMMON  #################################
 
 _OS_INTFS_FILES :=	os_dep/osdep_service.o \
@@ -63,14 +60,10 @@ _OS_INTFS_FILES :=	os_dep/osdep_service.
 _HAL_INTFS_FILES :=	hal/hal_intf.o \
 			hal/hal_com.o \
 			hal/hal_com_phycfg.o \
-			hal/hal_phy.o \
 			hal/hal_btcoex.o \
-			hal/hal_sdio.o \
-			hal/hal_sdio_led.o
+			hal/hal_sdio.o
 
 _OUTSRC_FILES := hal/odm_debug.o	\
-		hal/odm_AntDiv.o\
-		hal/odm_interface.o\
 		hal/odm_HWConfig.o\
 		hal/odm.o\
 		hal/HalPhyRf.o\
@@ -102,7 +95,6 @@ _HAL_INTFS_FILES +=	hal/rtl8723b_hal_ini
 
 _HAL_INTFS_FILES +=	\
 			hal/sdio_halinit.o \
-			hal/rtl8723bs_led.o \
 			hal/rtl8723bs_xmit.o \
 			hal/rtl8723bs_recv.o
 
@@ -127,11 +119,6 @@ ifeq ($(CONFIG_INTEL_WIDI), y)
 EXTRA_CFLAGS += -DCONFIG_INTEL_WIDI
 endif
 
-ifeq ($(CONFIG_WAPI_SUPPORT), y)
-EXTRA_CFLAGS += -DCONFIG_WAPI_SUPPORT
-endif
-
-
 ifeq ($(CONFIG_EXT_CLK), y)
 EXTRA_CFLAGS += -DCONFIG_EXT_CLK
 endif
@@ -221,9 +208,6 @@ $(MODULE_NAME)-y += $(rtk_core)
 
 $(MODULE_NAME)-$(CONFIG_INTEL_WIDI) += core/rtw_intel_widi.o
 
-$(MODULE_NAME)-$(CONFIG_WAPI_SUPPORT) += core/rtw_wapi.o	\
-					core/rtw_wapi_sms4.o
-
 $(MODULE_NAME)-y += $(_OS_INTFS_FILES)
 $(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
 $(MODULE_NAME)-y += $(_OUTSRC_FILES)
@@ -231,7 +215,7 @@ $(MODULE_NAME)-y += $(_PLATFORM_FILES)
 
 obj-$(CONFIG_RTL8723BS) := $(MODULE_NAME).o
 
-else
+endif
 
 export CONFIG_RTL8723BS = m
 
@@ -259,16 +243,9 @@ config_r:
 .PHONY: modules clean
 
 clean:
-	cd hal/ ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko
-	cd hal/ ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
-	cd hal ; rm -fr */*/*.mod.c */*/*.mod */*/*.o */*/.*.cmd */*/*.ko
-	cd hal ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko
-	cd hal ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
-	cd core ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
-	cd os_dep ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
-	cd platform ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
-	rm -fr Module.symvers ; rm -fr Module.markers ; rm -fr modules.order
-	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
-	rm -fr .tmp_versions
-endif
-
+	@rm -fr hal/*/*.mod.c hal/*/*.mod hal/*/*.o hal/*/.*.cmd hal/*/*.ko \
+		hal/*.mod.c hal/*.mod hal/*.o hal/.*.cmd hal/*.ko \
+		core/*.mod.c core/*.mod *.o core/.*.cmd core/*.ko \
+		os_dep/*.mod.c os_dep/*.mod os_dep/*.o os_dep/.*.cmd *.ko \
+		platform/*.mod.c platform/*.mod platform/*.o platform/.*.cmd platform/*.ko \
+		Module.symvers Module.markers modules.order *.mod.c *.mod *.o .*.cmd *.ko *~ .tmp_versions
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/ioctl_cfg80211.c linux/3rdparty/rtl8723bs/os_dep/ioctl_cfg80211.c
--- linux/3rdparty/rtl8723bs.old/os_dep/ioctl_cfg80211.c	2015-05-10 14:36:05.737668669 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/ioctl_cfg80211.c	2015-05-07 17:46:55.000000000 +0300
@@ -32,37 +32,12 @@
 
 #define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
 
-#ifdef CONFIG_WAPI_SUPPORT
-
-#ifndef WLAN_CIPHER_SUITE_SMS4
-#define WLAN_CIPHER_SUITE_SMS4          0x00147201
-#endif
-
-#ifndef WLAN_AKM_SUITE_WAPI_PSK
-#define WLAN_AKM_SUITE_WAPI_PSK         0x000FAC04
-#endif
-
-#ifndef WLAN_AKM_SUITE_WAPI_CERT
-#define WLAN_AKM_SUITE_WAPI_CERT        0x000FAC12
-#endif
-
-#ifndef NL80211_WAPI_VERSION_1
-#define NL80211_WAPI_VERSION_1          (1 << 2)
-#endif
-
-#endif
-
 static const u32 rtw_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,
 	WLAN_CIPHER_SUITE_WEP104,
 	WLAN_CIPHER_SUITE_TKIP,
 	WLAN_CIPHER_SUITE_CCMP,
-#ifdef CONFIG_WAPI_SUPPORT
-	WLAN_CIPHER_SUITE_SMS4,
-#endif // CONFIG_WAPI_SUPPORT
-#ifdef CONFIG_IEEE80211W
 	WLAN_CIPHER_SUITE_AES_CMAC,
-#endif //CONFIG_IEEE80211W
 };
 
 #define RATETAB_ENT(_rate, _rateid, _flags) \
@@ -81,15 +56,6 @@ static const u32 rtw_cipher_suites[] = {
 	.max_power		= 30,				\
 }
 
-#define CHAN5G(_channel, _flags) {				\
-	.band			= IEEE80211_BAND_5GHZ,		\
-	.center_freq		= 5000 + (5 * (_channel)),	\
-	.hw_value		= (_channel),			\
-	.flags			= (_flags),			\
-	.max_antenna_gain	= 0,				\
-	.max_power		= 30,				\
-}
-
 /* if wowlan is not supported, kernel generate a disconnect at each suspend
  * cf: /net/wireless/sysfs.c, so register a stub wowlan.
  * Moreover wowlan has to be enabled via a the nl80211_set_wowlan callback.
@@ -143,29 +109,6 @@ static struct ieee80211_channel rtw_2ghz
 	CHAN2G(14, 2484, 0),
 };
 
-static struct ieee80211_channel rtw_5ghz_a_channels[] = {
-	CHAN5G(34, 0),		CHAN5G(36, 0),
-	CHAN5G(38, 0),		CHAN5G(40, 0),
-	CHAN5G(42, 0),		CHAN5G(44, 0),
-	CHAN5G(46, 0),		CHAN5G(48, 0),
-	CHAN5G(52, 0),		CHAN5G(56, 0),
-	CHAN5G(60, 0),		CHAN5G(64, 0),
-	CHAN5G(100, 0),		CHAN5G(104, 0),
-	CHAN5G(108, 0),		CHAN5G(112, 0),
-	CHAN5G(116, 0),		CHAN5G(120, 0),
-	CHAN5G(124, 0),		CHAN5G(128, 0),
-	CHAN5G(132, 0),		CHAN5G(136, 0),
-	CHAN5G(140, 0),		CHAN5G(149, 0),
-	CHAN5G(153, 0),		CHAN5G(157, 0),
-	CHAN5G(161, 0),		CHAN5G(165, 0),
-	CHAN5G(184, 0),		CHAN5G(188, 0),
-	CHAN5G(192, 0),		CHAN5G(196, 0),
-	CHAN5G(200, 0),		CHAN5G(204, 0),
-	CHAN5G(208, 0),		CHAN5G(212, 0),
-	CHAN5G(216, 0),
-};
-
-
 static void rtw_2g_channels_init(struct ieee80211_channel *channels)
 {
 	memcpy((void*)channels, (void*)rtw_2ghz_channels,
@@ -173,13 +116,6 @@ static void rtw_2g_channels_init(struct
 	);
 }
 
-static void rtw_5g_channels_init(struct ieee80211_channel *channels)
-{
-	memcpy((void*)channels, (void*)rtw_5ghz_a_channels,
-		sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
-	);
-}
-
 static void rtw_2g_rates_init(struct ieee80211_rate *rates)
 {
 	memcpy(rates, rtw_g_rates,
@@ -187,13 +123,6 @@ static void rtw_2g_rates_init(struct iee
 	);
 }
 
-static void rtw_5g_rates_init(struct ieee80211_rate *rates)
-{
-	memcpy(rates, rtw_a_rates,
-		sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM
-	);
-}
-
 static struct ieee80211_supported_band *rtw_spt_band_alloc(
 	enum ieee80211_band band
 	)
@@ -206,11 +135,6 @@ static struct ieee80211_supported_band *
 		n_channels = RTW_2G_CHANNELS_NUM;
 		n_bitrates = RTW_G_RATES_NUM;
 	}
-	else if(band == IEEE80211_BAND_5GHZ)
-	{
-		n_channels = RTW_5G_CHANNELS_NUM;
-		n_bitrates = RTW_A_RATES_NUM;
-	}
 	else
 	{
 		goto exit;
@@ -235,11 +159,6 @@ static struct ieee80211_supported_band *
 		rtw_2g_channels_init(spt_band->channels);
 		rtw_2g_rates_init(spt_band->bitrates);
 	}
-	else if(band == IEEE80211_BAND_5GHZ)
-	{
-		rtw_5g_channels_init(spt_band->channels);
-		rtw_5g_rates_init(spt_band->bitrates);
-	}
 
 	//spt_band.ht_cap
 	
@@ -261,17 +180,7 @@ static void rtw_spt_band_free(struct iee
 			+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
 			+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;
 	}
-	else if(spt_band->band == IEEE80211_BAND_5GHZ)
-	{
-		size = sizeof(struct ieee80211_supported_band)
-			+ sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
-			+ sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM;		
-	}
-	else
-	{
-		
-	}
-	rtw_mfree((u8*)spt_band, size);
+	kfree((u8*)spt_band);
 }
 
 static const struct ieee80211_txrx_stypes
@@ -327,20 +236,14 @@ static int rtw_ieee80211_channel_to_freq
 {
 	/* see 802.11 17.3.8.3.2 and Annex J
 	* there are overlapping channel numbers in 5GHz and 2GHz bands */
-           
-	if (band == IEEE80211_BAND_5GHZ) {
-       	if (chan >= 182 && chan <= 196)
-			return 4000 + chan * 5;
-             else
-                    return 5000 + chan * 5;
-       } else { /* IEEE80211_BAND_2GHZ */
+	if (band == IEEE80211_BAND_2GHZ) {
 		if (chan == 14)
 			return 2484;
              else if (chan < 14)
 			return 2407 + chan * 5;
-             else
-			return 0; /* not supported */
 	}
+
+	return 0; /* not supported */
 }
 
 static u64 rtw_get_systime_us(void)
@@ -383,7 +286,6 @@ struct cfg80211_bss *rtw_cfg80211_inform
 		goto exit;
 	}
 
-#ifndef CONFIG_WAPI_SUPPORT
 	{
 		u16 wapi_len = 0;
 	
@@ -396,10 +298,9 @@ struct cfg80211_bss *rtw_cfg80211_inform
 			}	
 		}		
 	}	
-#endif //!CONFIG_WAPI_SUPPORT
 
 	//To reduce PBC Overlap rate
-	//_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	//spin_lock_bh(&pwdev_priv->scan_req_lock);
 	if(adapter_wdev_data(padapter)->scan_request != NULL)
 	{
 		u8 *psr=NULL, sr = 0;
@@ -435,15 +336,12 @@ struct cfg80211_bss *rtw_cfg80211_inform
 			}			
 		}		
 	}
-	//_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	//spin_unlock_bh(&pwdev_priv->scan_req_lock);
 	
 
 	channel = pnetwork->network.Configuration.DSConfig;
-	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
-	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
-	
+	freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 
 	notify_timestamp = rtw_get_systime_us();
@@ -499,23 +397,6 @@ struct cfg80211_bss *rtw_cfg80211_inform
 		goto exit;
 	}
 
-/*	
-	{
-		if( bss->information_elements == bss->proberesp_ies) 
-		{
-			if( bss->len_information_elements !=  bss->len_proberesp_ies)
-			{
-				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
-			}
-							
-		}
-		else if(bss->len_information_elements <  bss->len_beacon_ies)
-		{
-			bss->information_elements = bss->beacon_ies;			
-			bss->len_information_elements =  bss->len_beacon_ies;
-		}
-	}
-*/
 	cfg80211_put_bss(wiphy, bss);
 
 exit:	
@@ -539,10 +420,7 @@ int rtw_cfg80211_check_bss(_adapter *pad
 	if (!(pnetwork) || !(padapter->rtw_wdev))
 		return false;
 
-	if (pnetwork->Configuration.DSConfig <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, IEEE80211_BAND_2GHZ);
-	else
-		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, IEEE80211_BAND_5GHZ);
+	freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, IEEE80211_BAND_2GHZ);
 
 	notify_channel = ieee80211_get_channel(padapter->rtw_wdev->wiphy, freq);
 	bss = cfg80211_get_bss(padapter->rtw_wdev->wiphy, notify_channel,
@@ -579,18 +457,10 @@ void rtw_cfg80211_ibss_indicate_connect(
 		{
 			
 			memcpy(&cur_network->network, pnetwork, sizeof(WLAN_BSSID_EX));
-			if(cur_network)
-			{
-				if (!rtw_cfg80211_inform_bss(padapter,cur_network))
-					DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
-				else
-					DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
-			}
+			if (!rtw_cfg80211_inform_bss(padapter,cur_network))
+				DBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));
 			else
-			{
-				DBG_871X("cur_network is not exist!!!\n");
-				return ;
-			}
+				DBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));
 		}
 		else
 		{
@@ -674,10 +544,7 @@ check_bss:
 		u32 freq;
 		u16 channel = cur_network->network.Configuration.DSConfig;
 
-		if (channel <= RTW_CH_MAX_2G_CHANNEL)
-			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
-		else
-			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 
 		notify_channel = ieee80211_get_channel(wiphy, freq);
 
@@ -728,7 +595,6 @@ void rtw_cfg80211_indicate_disconnect(_a
 }
  	
 
-#ifdef CONFIG_AP_MODE
 static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
@@ -744,8 +610,6 @@ static int rtw_cfg80211_ap_set_encryptio
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
-	//sizeof(struct ieee_param) = 64 bytes;
-	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
 	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
 	{
 		ret =  -EINVAL;
@@ -1017,7 +881,6 @@ exit:
 	return ret;
 	
 }
-#endif
 
 static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
@@ -1045,18 +908,13 @@ _func_enter_;
 	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
 		if (param->u.crypt.idx >= WEP_KEYS
-#ifdef CONFIG_IEEE80211W
 			&& param->u.crypt.idx > BIP_MAX_KEYID
-#endif //CONFIG_IEEE80211W
 		)
 		{
 			ret = -EINVAL;
 			goto exit;
 		}
 	} else {
-#ifdef CONFIG_WAPI_SUPPORT
-		if (strcmp(param->u.crypt.alg, "SMS4"))
-#endif
 		{
 		ret = -EINVAL;
 		goto exit;
@@ -1168,7 +1026,6 @@ _func_enter_;
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1, true);
 					}
-#ifdef CONFIG_IEEE80211W
 					else if(strcmp(param->u.crypt.alg, "BIP") == 0)
 					{
 						int no;
@@ -1183,7 +1040,6 @@ _func_enter_;
 						padapter->securitypriv.binstallBIPkey = true;
 						DBG_871X(" ~~~~set sta key:IGKT\n");
 					}
-#endif //CONFIG_IEEE80211W
 				}
 			}
 
@@ -1210,73 +1066,6 @@ _func_enter_;
 		}			
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if (strcmp(param->u.crypt.alg, "SMS4") == 0)
-	{
-		PRT_WAPI_T			pWapiInfo = &padapter->wapiInfo;
-		PRT_WAPI_STA_INFO	pWapiSta;
-		u8					WapiASUEPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-		u8					WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-		u8 					WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-
-		if(param->u.crypt.set_tx == 1)
-		{
-			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-				if(!memcmp(pWapiSta->PeerMacAddr,param->sta_addr,6))
-				{
-					memcpy(pWapiSta->lastTxUnicastPN,WapiASUEPNInitialValueSrc,16);
-
-					pWapiSta->wapiUsk.bSet = true;
-					memcpy(pWapiSta->wapiUsk.dataKey,param->u.crypt.key,16);
-					memcpy(pWapiSta->wapiUsk.micKey,param->u.crypt.key+16,16);
-					pWapiSta->wapiUsk.keyId = param->u.crypt.idx ;
-					pWapiSta->wapiUsk.bTxEnable = true;
-
-					memcpy(pWapiSta->lastRxUnicastPNBEQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNBKQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNVIQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNVOQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPN,WapiAEPNInitialValueSrc,16);
-					pWapiSta->wapiUskUpdate.bTxEnable = false;
-					pWapiSta->wapiUskUpdate.bSet = false;
-
-					if (psecuritypriv->sw_encrypt== false || psecuritypriv->sw_decrypt == false)
-					{
-						//set unicast key for ASUE
-						rtw_wapi_set_key(padapter, &pWapiSta->wapiUsk, pWapiSta, false, false);
-					}
-				}
-			}
-		}
-		else
-		{
-			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-				if(!memcmp(pWapiSta->PeerMacAddr,get_bssid(pmlmepriv),6))
-				{
-					pWapiSta->wapiMsk.bSet = true;
-					memcpy(pWapiSta->wapiMsk.dataKey,param->u.crypt.key,16);
-					memcpy(pWapiSta->wapiMsk.micKey,param->u.crypt.key+16,16);
-					pWapiSta->wapiMsk.keyId = param->u.crypt.idx ;
-					pWapiSta->wapiMsk.bTxEnable = false;
-					if(!pWapiSta->bSetkeyOk)
-						pWapiSta->bSetkeyOk = true;
-					pWapiSta->bAuthenticateInProgress = false;
-
-					memcpy(pWapiSta->lastRxMulticastPN, WapiAEMultiCastPNInitialValueSrc, 16);
-
-					if (psecuritypriv->sw_decrypt == false)
-					{
-						//set rx broadcast key for ASUE
-						rtw_wapi_set_key(padapter, &pWapiSta->wapiMsk, pWapiSta, true, false);
-					}
-				}
-
-			}
-		}
-	}
-#endif
-
-
 exit:
 
 	DBG_8192C("%s, ret=%d\n", __func__, ret);
@@ -1331,28 +1120,10 @@ static int cfg80211_rtw_add_key(struct w
 	case WLAN_CIPHER_SUITE_CCMP:
 		alg_name = "CCMP";
 		break;
-#ifdef CONFIG_IEEE80211W
 	case WLAN_CIPHER_SUITE_AES_CMAC:
 		alg_name = "BIP";
 		break;
-#endif //CONFIG_IEEE80211W
-#ifdef CONFIG_WAPI_SUPPORT
-	case WLAN_CIPHER_SUITE_SMS4:
-		alg_name= "SMS4";
-		if(pairwise == NL80211_KEYTYPE_PAIRWISE) {
-			if (key_index != 0 && key_index != 1) {
-				ret = -ENOTSUPP;
-				goto addkey_end;
-			}
-			memcpy((void*)param->sta_addr, (void*)mac_addr, ETH_ALEN);
-		} else {
-			DBG_871X("mac_addr is null \n");
-		}
-		DBG_871X("rtw_wx_set_enc_ext: SMS4 case \n");
-		break;
-#endif
-
-	default:	
+	default:
 		ret = -ENOTSUPP;
 		goto addkey_end;
 	}
@@ -1366,11 +1137,9 @@ static int cfg80211_rtw_add_key(struct w
 	} else {
 		param->u.crypt.set_tx = 1; //for wpa/wpa2 pairwise key
 	}
-	
-	
-	//param->u.crypt.idx = key_index - 1;
+
 	param->u.crypt.idx = key_index;
-	
+
 	if (params->seq_len && params->seq) 
 	{	
 		memcpy(param->u.crypt.seq, (u8 *)params->seq, params->seq_len);
@@ -1388,12 +1157,10 @@ static int cfg80211_rtw_add_key(struct w
 	}
 	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
-#ifdef CONFIG_AP_MODE
 		if(mac_addr)
 			memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
-	
+
 		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
-#endif
 	}
         else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true
                 || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)
@@ -1410,7 +1177,7 @@ static int cfg80211_rtw_add_key(struct w
 addkey_end:
 	if(param)
 	{
-		rtw_mfree((u8*)param, param_len);
+		kfree((u8*)param);
 	}
 
 	return ret;
@@ -1522,16 +1289,16 @@ static int cfg80211_rtw_get_station(stru
 			goto exit;
 		}
 
-		sinfo->filled |= STATION_INFO_SIGNAL;
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
 		sinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
 
-		sinfo->filled |= STATION_INFO_TX_BITRATE;
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);
 		sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
 
-		sinfo->filled |= STATION_INFO_RX_PACKETS;
+		sinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);
 		sinfo->rx_packets = sta_rx_data_pkts(psta);
 
-		sinfo->filled |= STATION_INFO_TX_PACKETS;
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);
 		sinfo->tx_packets = psta->sta_stats.tx_pkts;
 
 	}
@@ -1552,23 +1319,6 @@ exit:
 
 extern int netdev_open(struct net_device *pnetdev);
 
-/*
-enum nl80211_iftype {
-	NL80211_IFTYPE_UNSPECIFIED,
-       NL80211_IFTYPE_ADHOC, //1
-       NL80211_IFTYPE_STATION, //2
-       NL80211_IFTYPE_AP, //3
-       NL80211_IFTYPE_AP_VLAN,
-       NL80211_IFTYPE_WDS,
-       NL80211_IFTYPE_MONITOR, //6
-       NL80211_IFTYPE_MESH_POINT,
-       NL80211_IFTYPE_P2P_CLIENT, //8
-	NL80211_IFTYPE_P2P_GO, //9
-       //keep last 
-       NUM_NL80211_IFTYPES,
-       NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
-};
-*/
 static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 				     struct net_device *ndev,
 				     enum nl80211_iftype type, u32 *flags,
@@ -1653,7 +1403,7 @@ void rtw_cfg80211_indicate_scan_done(_ad
 	struct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);
 	_irqL	irqL;
 
-	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	if (pwdev_priv->scan_request != NULL) {
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s with scan req\n", __FUNCTION__);
@@ -1675,7 +1425,7 @@ void rtw_cfg80211_indicate_scan_done(_ad
 		DBG_871X("%s without scan req\n", __FUNCTION__);
 		#endif
 	}
-	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
 }
 
 void rtw_cfg80211_unlink_bss(_adapter *padapter, struct wlan_network *pnetwork)
@@ -1714,14 +1464,14 @@ void rtw_cfg80211_surveydone_event_callb
 	DBG_8192C("%s\n", __func__);
 #endif
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
        
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -1740,7 +1490,7 @@ void rtw_cfg80211_surveydone_event_callb
 	
 	}
 	
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 }
 
 static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, int len)
@@ -1770,7 +1520,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
-				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
+				kfree(pmlmepriv->wps_probe_req_ie);
 				pmlmepriv->wps_probe_req_ie = NULL;			
 			}	
 
@@ -1783,12 +1533,6 @@ static int rtw_cfg80211_set_probe_req_wp
 			memcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
 		}
-
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
 	}
 
 	return ret;
@@ -1832,9 +1576,9 @@ static int cfg80211_rtw_scan(struct wiph
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 //#endif
 
-	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	pwdev_priv->scan_request = request;
-	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
@@ -1918,7 +1662,7 @@ static int cfg80211_rtw_scan(struct wiph
 		ch[i].flags = request->channels[i]->flags;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	if (request->n_channels == 1) {
 		for(i=1;i<survey_times_for_one_ch;i++)
 			memcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));
@@ -1933,7 +1677,7 @@ static int cfg80211_rtw_scan(struct wiph
 	} else {
 		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);
 	}
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 	if(_status == false)
@@ -1978,20 +1722,6 @@ static int rtw_cfg80211_set_wpa_version(
 		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;		
 	}
 
-/*
-	if (wpa_version & NL80211_WPA_VERSION_2)
-	{		
-		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
-	}
-*/
-
-	#ifdef CONFIG_WAPI_SUPPORT
-	if (wpa_version & NL80211_WAPI_VERSION_1)
-	{
-		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWAPI;
-	}
-	#endif
-
 	return 0;
 
 }
@@ -2014,11 +1744,6 @@ static int rtw_cfg80211_set_auth_type(st
 
 		if(psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
 			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
-		
-#ifdef CONFIG_WAPI_SUPPORT
-		if(psecuritypriv->ndisauthtype == Ndis802_11AuthModeWAPI)
-			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
-#endif
 
 		break;
 	case NL80211_AUTHTYPE_SHARED_KEY:
@@ -2058,12 +1783,6 @@ static int rtw_cfg80211_set_cipher(struc
 	case IW_AUTH_CIPHER_NONE:
 		*profile_cipher = _NO_PRIVACY_;
 		ndisencryptstatus = Ndis802_11EncryptionDisabled;
-#ifdef CONFIG_WAPI_SUPPORT
-		if(psecuritypriv->dot11PrivacyAlgrthm ==_SMS4_ )
-		{
-			*profile_cipher = _SMS4_;
-		}
-#endif
 		break;
 	case WLAN_CIPHER_SUITE_WEP40:
 		*profile_cipher = _WEP40_;
@@ -2081,12 +1800,6 @@ static int rtw_cfg80211_set_cipher(struc
 		*profile_cipher = _AES_;
 		ndisencryptstatus = Ndis802_11Encryption3Enabled;
 		break;
-#ifdef CONFIG_WAPI_SUPPORT
-	case WLAN_CIPHER_SUITE_SMS4:
-		*profile_cipher = _SMS4_;
-		ndisencryptstatus = Ndis802_11_EncrypteionWAPI;
-		break;
-#endif
 	default:
 		DBG_8192C("Unsupported cipher: 0x%x\n", cipher);
 		return -ENOTSUPP;
@@ -2113,16 +1826,6 @@ static int rtw_cfg80211_set_key_mgt(stru
 	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 	}
-#ifdef CONFIG_WAPI_SUPPORT
-	else if(key_mgt ==WLAN_AKM_SUITE_WAPI_PSK){
-		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
-	}
-	else if(key_mgt ==WLAN_AKM_SUITE_WAPI_CERT){
-		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_WAPI;
-	}
-#endif
-
-
 	else {
 		DBG_8192C("Invalid key mgt: 0x%x\n", key_mgt);
 		//return -EINVAL;
@@ -2288,7 +1991,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 
 exit:
 	if (buf)
-		rtw_mfree(buf, ielen);
+		kfree(buf);
 	if (ret)
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
 	return ret;
@@ -2398,8 +2101,6 @@ static int cfg80211_rtw_connect(struct w
 	NDIS_802_11_SSID ndis_ssid;	
 	u8 *dst_ssid, *src_ssid;
 	u8 *dst_bssid, *src_bssid;
-	//u8 matched_by_bssid=false;
-	//u8 matched_by_ssid=false;
 	u8 matched=false;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
@@ -2469,31 +2170,12 @@ static int cfg80211_rtw_connect(struct w
 	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
 	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
 
-#ifdef CONFIG_WAPI_SUPPORT
-	 padapter->wapiInfo.bWapiEnable = false;
-#endif
-
 	ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
 	if (ret < 0)
 		goto exit;
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if(sme->crypto.wpa_versions & NL80211_WAPI_VERSION_1)
-	{
-		padapter->wapiInfo.bWapiEnable = true;
-		padapter->wapiInfo.extra_prefix_len = WAPI_EXT_LEN;
-		padapter->wapiInfo.extra_postfix_len = SMS4_MIC_LEN;
-	}
-#endif
-
 	ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_WAPI)
-		padapter->mlmeextpriv.mlmext_info.auth_algo = psecuritypriv->dot11AuthAlgrthm;
-#endif
-
-
 	if (ret < 0)
 		goto exit;
 
@@ -2563,9 +2245,7 @@ static int cfg80211_rtw_connect(struct w
 			ret = -EOPNOTSUPP ;
 		}
 
-		if (pwep) {
-			rtw_mfree((u8 *)pwep,wep_total_len);		
-		}
+		kfree((u8 *)pwep);
 
 		if(ret < 0)
 			goto exit;
@@ -2581,15 +2261,6 @@ static int cfg80211_rtw_connect(struct w
 			goto exit;
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-      if(sme->crypto.akm_suites[0] ==WLAN_AKM_SUITE_WAPI_PSK){
-		padapter->wapiInfo.bWapiPSK = true;
-	}
-	else if(sme->crypto.akm_suites[0] ==WLAN_AKM_SUITE_WAPI_CERT){
-	      padapter->wapiInfo.bWapiPSK = false;
-	}
-#endif
-
 	authmode = psecuritypriv->ndisauthtype;
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 
@@ -2624,19 +2295,16 @@ static int cfg80211_rtw_disconnect(struc
 
 	rtw_set_to_roam(padapter, 0);
 
-	//if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))
-	{
-		rtw_scan_abort(padapter);
-		LeaveAllPowerSaveMode(padapter);
-		rtw_disassoc_cmd(padapter, 500, false);
-		
-		DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
-		
-		rtw_indicate_disconnect(padapter);
-		
-		rtw_free_assoc_resources(padapter, 1);
-		rtw_pwr_wakeup(padapter);		
-	}
+	rtw_scan_abort(padapter);
+	LeaveAllPowerSaveMode(padapter);
+	rtw_disassoc_cmd(padapter, 500, false);
+
+	DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
+
+	rtw_indicate_disconnect(padapter);
+
+	rtw_free_assoc_resources(padapter, 1);
+	rtw_pwr_wakeup(padapter);
 
 	padapter->mlmepriv.not_indic_disco = false;
 
@@ -2786,7 +2454,6 @@ static int cfg80211_rtw_flush_pmksa(stru
 	return 0;
 }
 
-#ifdef CONFIG_AP_MODE
 void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
 {
 	s32 freq;
@@ -2806,7 +2473,6 @@ void rtw_cfg80211_indicate_sta_assoc(_ad
 			ie_offset = _REASOCREQ_IE_OFFSET_;
 	
 		sinfo.filled = 0;
-		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
 		sinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;
 		sinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;
 		cfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);
@@ -2989,7 +2655,7 @@ static int rtw_cfg80211_monitor_if_xmit_
 	
 fail:
 	
-	rtw_skb_free(skb);
+	dev_kfree_skb_any(skb);
 
 	return 0;
 	
@@ -3073,7 +2739,7 @@ static int rtw_cfg80211_add_monitor_if(_
 
 out:
 	if (ret && mon_wdev) {
-		rtw_mfree((u8*)mon_wdev, sizeof(struct wireless_dev));
+		kfree((u8*)mon_wdev);
 		mon_wdev = NULL;
 	}
 
@@ -3167,30 +2833,19 @@ static int rtw_add_beacon(_adapter *adap
 	u8 *p2p_ie;
 	u8 got_p2p_ie = false;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-	//struct sta_priv *pstapriv = &padapter->stapriv;
-	
 
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __FUNCTION__, head_len, tail_len);
 
-	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	if(head_len<24)
 		return -EINVAL;
-	
 
 	pbuf = rtw_zmalloc(head_len+tail_len);
 	if(!pbuf)
 		return -ENOMEM;
-	
 
-	//memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
-
-	//if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
-	//	pstapriv->max_num_sta = NUM_STA;
-
-	
 	memcpy(pbuf, (void *)head+24, head_len-24);// 24=beacon header len.
 	memcpy(pbuf+head_len-24, (void *)tail, tail_len);
 
@@ -3214,7 +2869,7 @@ static int rtw_add_beacon(_adapter *adap
 	}	
 	
 
-	rtw_mfree(pbuf, head_len+tail_len);	
+	kfree(pbuf);
 	
 	return ret;	
 }
@@ -3284,16 +2939,8 @@ static int	cfg80211_rtw_add_station(stru
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
 static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
 				    struct station_del_parameters *params)
-#elif (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14, 0))
-static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
-			       const u8 *mac)
-#else
-static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
-			       u8 *mac)
-#endif
 {
 	int ret=0;	
 	_irqL irqL;
@@ -3303,9 +2950,7 @@ static int cfg80211_rtw_del_station(stru
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0))
 	const u8 *mac = params->mac;
-#endif
 
 	DBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
@@ -3338,13 +2983,13 @@ static int cfg80211_rtw_del_station(stru
 	}
 
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
 	//check asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == false)	
+	while (phead != plist)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		
@@ -3360,12 +3005,10 @@ static int cfg80211_rtw_del_station(stru
 			{
 				DBG_8192C("free psta=%p, aid=%d\n", psta, psta->aid);
 
-				rtw_list_delete(&psta->asoc_list);
+				list_del_init(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 
-				//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 				updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-				//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
 				psta = NULL;
 
@@ -3376,7 +3019,7 @@ static int cfg80211_rtw_del_station(stru
 		
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	associated_clients_update(padapter, updated);
 
@@ -3386,13 +3029,8 @@ static int cfg80211_rtw_del_station(stru
 
 }
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14, 0))
 static int cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
 				  const u8 *mac, struct station_parameters *params)
-#else
-static int cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
-				  u8 *mac, struct station_parameters *params)
-#endif
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	
@@ -3410,7 +3048,7 @@ static struct sta_info *rtw_sta_info_get
 	plist = get_next(phead);
 
 	//check asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == false)	
+	while (phead != plist)
 	{
 		if(idx == i) psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);	
@@ -3430,9 +3068,9 @@ static int	cfg80211_rtw_dump_station(str
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 	if(NULL == psta)
 	{
 		DBG_871X("Station is not found\n");
@@ -3440,8 +3078,7 @@ static int	cfg80211_rtw_dump_station(str
 		goto exit;
 	}
 	memcpy(mac, psta->hwaddr, ETH_ALEN);
-	sinfo->filled = 0;
-	sinfo->filled |= STATION_INFO_SIGNAL;
+	sinfo->filled = BIT(NL80211_STA_INFO_SIGNAL);
 	sinfo->signal = psta->rssi;
 	
 exit:
@@ -3451,70 +3088,8 @@ exit:
 static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
 			      struct bss_parameters *params)
 {
-	u8 i;
-
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-/*
-	DBG_8192C("use_cts_prot=%d\n", params->use_cts_prot);
-	DBG_8192C("use_short_preamble=%d\n", params->use_short_preamble);
-	DBG_8192C("use_short_slot_time=%d\n", params->use_short_slot_time);
-	DBG_8192C("ap_isolate=%d\n", params->ap_isolate);
-
-	DBG_8192C("basic_rates_len=%d\n", params->basic_rates_len);
-	for(i=0; i<params->basic_rates_len; i++)
-	{		
-		DBG_8192C("basic_rates=%d\n", params->basic_rates[i]);
-		
-	}	
-*/	
 	return 0;
-	
-}
-
-#endif //CONFIG_AP_MODE
-
-void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
-{
-	int type;
-	s32 freq;
-	int channel;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
-	u8 category, action;
-
-	channel = rtw_get_oper_ch(padapter);
-
-	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
-	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
-	DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
-
-	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
-	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
-
-	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
-}
-
-void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
-{
-	int type;
-	s32 freq;
-	int channel;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
-	u8 category, action;
-
-	channel = rtw_get_oper_ch(padapter);
-
-	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
-	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
-	DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
-
-	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
-	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
-
-	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
 }
 
 void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const char*msg)
@@ -3535,10 +3110,7 @@ void rtw_cfg80211_rx_action(_adapter *ad
 	else
 		DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
 
-	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
-	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+	freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 
 	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);
 }
@@ -3555,12 +3127,10 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	//struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	rtw_set_scan_deny(padapter, 1000);
 
 	rtw_scan_abort(padapter);
-	//if (tx_ch != pmlmeext->cur_channel) {
 	if(tx_ch != rtw_get_oper_ch(padapter)) {
 		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
 			pmlmeext->cur_channel = tx_ch;
@@ -3794,226 +3364,6 @@ static int cfg80211_rtw_sched_scan_stop(
 }
 #endif /* CONFIG_PNO_SUPPORT */
 
-static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
-{	
-	int ret = 0;
-	uint wps_ielen = 0;
-	u8 *wps_ie;
-	u32	p2p_ielen = 0;
-	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};	
-	u8 *p2p_ie;
-	u32	wfd_ielen = 0;	
-	u8 *wfd_ie;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
-
-	DBG_871X(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
-	
-	if(len>0)
-	{
-		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
-		{	
-			#ifdef CONFIG_DEBUG_CFG80211
-			DBG_8192C("bcn_wps_ielen=%d\n", wps_ielen);
-			#endif
-		
-			if(pmlmepriv->wps_beacon_ie)
-			{
-				u32 free_len = pmlmepriv->wps_beacon_ie_len;
-				pmlmepriv->wps_beacon_ie_len = 0;
-				rtw_mfree(pmlmepriv->wps_beacon_ie, free_len);
-				pmlmepriv->wps_beacon_ie = NULL;			
-			}	
-
-			pmlmepriv->wps_beacon_ie = rtw_malloc(wps_ielen);
-			if ( pmlmepriv->wps_beacon_ie == NULL) {
-				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
-				return -EINVAL;
-			
-			}
-			
-			memcpy(pmlmepriv->wps_beacon_ie, wps_ie, wps_ielen);
-			pmlmepriv->wps_beacon_ie_len = wps_ielen;
-	
-			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
-
-		}
-
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
-
-		pmlmeext->bstart_bss = true;		
-	}
-
-	return ret;
-	
-}
-
-static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *buf, int len)
-{
-	int ret = 0;
-	uint wps_ielen = 0;
-	u8 *wps_ie;
-	u32	p2p_ielen = 0;	
-	u8 *p2p_ie;
-	u32	wfd_ielen = 0;	
-	u8 *wfd_ie;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
-
-#ifdef CONFIG_DEBUG_CFG80211
-	DBG_8192C("%s, ielen=%d\n", __func__, len);
-#endif
-	
-	if(len>0)
-	{
-		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
-		{	
-			uint	attr_contentlen = 0;
-			u16	uconfig_method, *puconfig_method = NULL;
-
-			#ifdef CONFIG_DEBUG_CFG80211			
-			DBG_8192C("probe_resp_wps_ielen=%d\n", wps_ielen);
-			#endif
-		
-			if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
-			{
-				u8 sr = 0;
-				rtw_get_wps_attr_content(wps_ie,  wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (u8*)(&sr), NULL);
-
-				if (sr != 0)
-				{
-					DBG_871X("%s, got sr\n", __func__);
-				}	
-				else
-				{				
-					DBG_8192C("GO mode process WPS under site-survey,  sr no set\n");
-					return ret;
-				}	
-			}			
-		
-			if(pmlmepriv->wps_probe_resp_ie)
-			{
-				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
-				pmlmepriv->wps_probe_resp_ie_len = 0;
-				rtw_mfree(pmlmepriv->wps_probe_resp_ie, free_len);
-				pmlmepriv->wps_probe_resp_ie = NULL;			
-			}	
-
-			pmlmepriv->wps_probe_resp_ie = rtw_malloc(wps_ielen);
-			if ( pmlmepriv->wps_probe_resp_ie == NULL) {
-				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
-				return -EINVAL;
-			
-			}
-			
-			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode 
-			if ( (puconfig_method = (u16*)rtw_get_wps_attr_content( wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL )
-			{
-				//struct registry_priv *pregistrypriv = &padapter->registrypriv;
-				struct wireless_dev *wdev = padapter->rtw_wdev;
-				
-				#ifdef CONFIG_DEBUG_CFG80211		
-				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
-				#endif
-				
-				//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
-				if(wdev->iftype != NL80211_IFTYPE_P2P_GO) //for WIFI-DIRECT LOGO 4.2.2, AUTO GO can't set PUSH_BUTTON flags
-				{
-					uconfig_method = WPS_CM_PUSH_BUTTON;
-					uconfig_method = cpu_to_be16( uconfig_method );
-			
-					*puconfig_method |= uconfig_method;			
-				}	
-			}
-			
-			memcpy(pmlmepriv->wps_probe_resp_ie, wps_ie, wps_ielen);
-			pmlmepriv->wps_probe_resp_ie_len = wps_ielen;
-			
-		}
-
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
-	}
-
-	return ret;
-	
-}
-
-static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *buf, int len)
-{
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
-	DBG_8192C("%s, ielen=%d\n", __func__, len);
-	
-	if(len>0)
-	{
-		if(pmlmepriv->wps_assoc_resp_ie)
-		{
-			u32 free_len = pmlmepriv->wps_assoc_resp_ie_len;
-			pmlmepriv->wps_assoc_resp_ie_len = 0;
-			rtw_mfree(pmlmepriv->wps_assoc_resp_ie, free_len);
-			pmlmepriv->wps_assoc_resp_ie = NULL;
-		}	
-
-		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(len);
-		if ( pmlmepriv->wps_assoc_resp_ie == NULL) {
-			DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
-			return -EINVAL;
-			
-		}
-		memcpy(pmlmepriv->wps_assoc_resp_ie, buf, len);
-		pmlmepriv->wps_assoc_resp_ie_len = len;
-	}
-
-	return ret;
-	
-}
-
-int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
-	int type)
-{
-	int ret = 0;
-	uint wps_ielen = 0;
-	u32	p2p_ielen = 0;
-
-#ifdef CONFIG_DEBUG_CFG80211
-	DBG_8192C("%s, ielen=%d\n", __func__, len);
-#endif
-
-	if(	(rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
-	)		
-	{	
-		if (net != NULL) 
-		{
-			switch (type) 
-			{
-				case 0x1: //BEACON
-				ret = rtw_cfg80211_set_beacon_wpsp2pie(net, buf, len);
-				break;
-				case 0x2: //PROBE_RESP
-				ret = rtw_cfg80211_set_probe_resp_wpsp2pie(net, buf, len);
-				break;
-				case 0x4: //ASSOC_RESP
-				ret = rtw_cfg80211_set_assoc_resp_wpsp2pie(net, buf, len);
-				break;
-			}		
-		}
-	}	
-
-	return ret;
-	
-}
-
 static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
 {
 
@@ -4081,20 +3431,12 @@ void rtw_cfg80211_init_wiphy(_adapter *p
 
 	DBG_8192C("%s:rf_type=%d\n", __func__, rf_type);
 
-	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
 	{
 		bands = wiphy->bands[IEEE80211_BAND_2GHZ];
 		if(bands)
 			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, rf_type);
 	}
 
-	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
-	{
-		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
-		if(bands)
-			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
-	}
-
 	/* init regulary domain */
 	rtw_regd_init(padapter, rtw_reg_notifier);
 
@@ -4103,25 +3445,6 @@ void rtw_cfg80211_init_wiphy(_adapter *p
 
 }
 
-/*
-struct ieee80211_iface_limit rtw_limits[] = {
-	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION)
-					| BIT(NL80211_IFTYPE_ADHOC)
-#ifdef CONFIG_AP_MODE
-					| BIT(NL80211_IFTYPE_AP)
-#endif
-	},
-	{.max = 1, .types = BIT(NL80211_IFTYPE_MONITOR)},
-};
-
-struct ieee80211_iface_combination rtw_combinations = {
-	.limits = rtw_limits,
-	.n_limits = ARRAY_SIZE(rtw_limits),
-	.max_interfaces = 2,
-	.num_different_channels = 1,
-};
-*/
-
 static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 {
 
@@ -4135,31 +3458,20 @@ static void rtw_cfg80211_preinit_wiphy(_
 
 	wiphy->interface_modes =	BIT(NL80211_IFTYPE_STATION)
 								| BIT(NL80211_IFTYPE_ADHOC)
-#ifdef CONFIG_AP_MODE
 								| BIT(NL80211_IFTYPE_AP)
 								| BIT(NL80211_IFTYPE_MONITOR)
-#endif
 								;
 
-#ifdef CONFIG_AP_MODE
 	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
-#endif //CONFIG_AP_MODE	
 
 	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
 
-	/*
-	wiphy->iface_combinations = &rtw_combinations;
-	wiphy->n_iface_combinations = 1;
-	*/
-
 	wiphy->cipher_suites = rtw_cipher_suites;
 	wiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
 		wiphy->bands[IEEE80211_BAND_2GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_2GHZ);
-	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
-		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
-	
+
 	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;
 
@@ -4178,8 +3490,6 @@ static void rtw_cfg80211_preinit_wiphy(_
 		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
 	else 
 		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
-
-	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -4201,8 +3511,7 @@ static struct cfg80211_ops rtw_cfg80211_
 	.set_pmksa = cfg80211_rtw_set_pmksa,
 	.del_pmksa = cfg80211_rtw_del_pmksa,
 	.flush_pmksa = cfg80211_rtw_flush_pmksa,
-	
-#ifdef CONFIG_AP_MODE
+
 	.add_virtual_intf = cfg80211_rtw_add_virtual_intf,
 	.del_virtual_intf = cfg80211_rtw_del_virtual_intf,
 
@@ -4215,7 +3524,6 @@ static struct cfg80211_ops rtw_cfg80211_
 	.change_station = cfg80211_rtw_change_station,
 	.dump_station = cfg80211_rtw_dump_station,
 	.change_bss = cfg80211_rtw_change_bss,
-#endif //CONFIG_AP_MODE
 
 	.mgmt_tx = cfg80211_rtw_mgmt_tx,
 	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
@@ -4293,7 +3601,7 @@ int rtw_wdev_alloc(_adapter *padapter, s
 	
 	return ret;
 
-	rtw_mfree((u8*)wdev, sizeof(struct wireless_dev));
+	kfree((u8*)wdev);
 unregister_wiphy:
 	wiphy_unregister(wiphy);
  free_wiphy:
@@ -4311,11 +3619,10 @@ void rtw_wdev_free(struct wireless_dev *
 		return;
 
 	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_2GHZ]);
-	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_5GHZ]);
-	
+
 	wiphy_free(wdev->wiphy);
 
-	rtw_mfree((u8*)wdev, sizeof(struct wireless_dev));
+	kfree((u8*)wdev);
 }
 
 void rtw_wdev_unregister(struct wireless_dev *wdev)
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/ioctl_linux.c linux/3rdparty/rtl8723bs/os_dep/ioctl_linux.c
--- linux/3rdparty/rtl8723bs.old/os_dep/ioctl_linux.c	2015-05-10 14:36:05.739668691 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/ioctl_linux.c	2015-05-07 17:46:55.000000000 +0300
@@ -20,6 +20,7 @@
 #define _IOCTL_LINUX_C_
 
 #include <drv_types.h>
+#include <rtw_mp.h>
 #include <linux/jiffies.h>
 
 extern int rtw_ht_enable;
@@ -45,9 +46,6 @@ extern int rtw_ht_enable;
 
 
 extern u8 key_2char2num(u8 hch, u8 lch);
-extern u8 str_2char2num(u8 hch, u8 lch);
-extern void macstr2num(u8 *dst, u8 *src);
-extern u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
 
 static u32 rtw_rates[] = {1000000,2000000,5500000,11000000,
 	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
@@ -95,20 +93,6 @@ static int hwaddr_aton_i(const char *txt
 	return 0;
 }
 
-#ifdef CONFIG_SUPPORT_HW_WPS_PBC
-void rtw_request_wps_pbc_event(_adapter *padapter)
-{
-	if ( padapter->pid[0] == 0 )
-	{	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
-		return;
-	}
-
-	rtw_signal_process(padapter->pid[0], SIGUSR1);
-
-	rtw_led_control(padapter, LED_CTL_START_WPS_BOTTON);
-}
-#endif//#ifdef CONFIG_SUPPORT_HW_WPS_PBC
-
 void indicate_wx_scan_complete_event(_adapter *padapter)
 {	
 	union iwreq_data wrqu;
@@ -444,49 +428,6 @@ static char *translate_scan(_adapter *pa
 		}
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if (pnetwork->network.Reserved[0] != 2) // Probe Request
-	{
-		sint out_len_wapi=0;
-		/* here use static for stack size */
-		static u8 buf_wapi[MAX_WAPI_IE_LEN*2];
-		static u8 wapi_ie[MAX_WAPI_IE_LEN];
-		u16 wapi_len=0;
-		u16  i;
-
-		memset(buf_wapi, 0, MAX_WAPI_IE_LEN);
-		memset(wapi_ie, 0, MAX_WAPI_IE_LEN);
-
-		out_len_wapi=rtw_get_wapi_ie(pnetwork->network.IEs ,pnetwork->network.IELength,wapi_ie,&wapi_len);
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wapi_len=%d \n",wapi_len));
-
-		DBG_871X("rtw_wx_get_scan: %s ",pnetwork->network.Ssid.Ssid);
-		DBG_871X("rtw_wx_get_scan: ssid = %d ",wapi_len);
-
-
-		if (wapi_len > 0)
-		{
-			p=buf_wapi;
-			memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
-			p += sprintf(p, "wapi_ie=");
-			for (i = 0; i < wapi_len; i++) {
-				p += sprintf(p, "%02x", wapi_ie[i]);
-			}
-
-			memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd = IWEVCUSTOM;
-			iwe.u.data.length = strlen(buf_wapi);
-			start = iwe_stream_add_point(info, start, stop, &iwe,buf_wapi);
-
-			memset(&iwe, 0, sizeof(iwe));
-			iwe.cmd =IWEVGENIE;
-			iwe.u.data.length = wapi_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, wapi_ie);
-		}
-	}
-#endif
-
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 ss, sq;
@@ -635,9 +576,7 @@ _func_enter_;
 	{
 
 		if (param->u.crypt.idx >= WEP_KEYS
-#ifdef CONFIG_IEEE80211W
 			&& param->u.crypt.idx > BIP_MAX_KEYID
-#endif //CONFIG_IEEE80211W
 			)
 		{
 			ret = -EINVAL;
@@ -646,9 +585,6 @@ _func_enter_;
 	} 
 	else 
 	{
-#ifdef CONFIG_WAPI_SUPPORT
-		if (strcmp(param->u.crypt.alg, "SMS4"))
-#endif
 		{
 			ret = -EINVAL;
 			goto exit;
@@ -796,7 +732,6 @@ _func_enter_;
 	
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1, true);
 					}
-#ifdef CONFIG_IEEE80211W
 					else if(strcmp(param->u.crypt.alg, "BIP") == 0)
 					{
 						int no;
@@ -811,7 +746,6 @@ _func_enter_;
 						padapter->securitypriv.binstallBIPkey = true;
 						DBG_871X(" ~~~~set sta key:IGKT\n");
 					}
-#endif //CONFIG_IEEE80211W
 				}
 			}
 
@@ -838,76 +772,10 @@ _func_enter_;
 		}			
 	}
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if (strcmp(param->u.crypt.alg, "SMS4") == 0)
-	{
-		PRT_WAPI_T			pWapiInfo = &padapter->wapiInfo;
-		PRT_WAPI_STA_INFO	pWapiSta;
-		u8					WapiASUEPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-		u8					WapiAEPNInitialValueSrc[16] = {0x37,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-		u8 					WapiAEMultiCastPNInitialValueSrc[16] = {0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C,0x36,0x5C} ;
-
-		if(param->u.crypt.set_tx == 1)
-		{
-			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-				if(!memcmp(pWapiSta->PeerMacAddr,param->sta_addr,6))
-				{
-					memcpy(pWapiSta->lastTxUnicastPN,WapiASUEPNInitialValueSrc,16);
-
-					pWapiSta->wapiUsk.bSet = true;
-					memcpy(pWapiSta->wapiUsk.dataKey,param->u.crypt.key,16);
-					memcpy(pWapiSta->wapiUsk.micKey,param->u.crypt.key+16,16);
-					pWapiSta->wapiUsk.keyId = param->u.crypt.idx ;
-					pWapiSta->wapiUsk.bTxEnable = true;
-
-					memcpy(pWapiSta->lastRxUnicastPNBEQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNBKQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNVIQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPNVOQueue,WapiAEPNInitialValueSrc,16);
-					memcpy(pWapiSta->lastRxUnicastPN,WapiAEPNInitialValueSrc,16);
-					pWapiSta->wapiUskUpdate.bTxEnable = false;
-					pWapiSta->wapiUskUpdate.bSet = false;
-
-					if (psecuritypriv->sw_encrypt== false || psecuritypriv->sw_decrypt == false)
-					{
-						//set unicast key for ASUE
-						rtw_wapi_set_key(padapter, &pWapiSta->wapiUsk, pWapiSta, false, false);
-					}
-				}
-			}
-		}
-		else
-		{
-			list_for_each_entry(pWapiSta, &pWapiInfo->wapiSTAUsedList, list) {
-				if(!memcmp(pWapiSta->PeerMacAddr,get_bssid(pmlmepriv),6))
-				{
-					pWapiSta->wapiMsk.bSet = true;
-					memcpy(pWapiSta->wapiMsk.dataKey,param->u.crypt.key,16);
-					memcpy(pWapiSta->wapiMsk.micKey,param->u.crypt.key+16,16);
-					pWapiSta->wapiMsk.keyId = param->u.crypt.idx ;
-					pWapiSta->wapiMsk.bTxEnable = false;
-					if(!pWapiSta->bSetkeyOk)
-						pWapiSta->bSetkeyOk = true;
-					pWapiSta->bAuthenticateInProgress = false;
-
-					memcpy(pWapiSta->lastRxMulticastPN, WapiAEMultiCastPNInitialValueSrc, 16);
-
-					if (psecuritypriv->sw_decrypt == false)
-					{
-						//set rx broadcast key for ASUE
-						rtw_wapi_set_key(padapter, &pWapiSta->wapiMsk, pWapiSta, true, false);
-					}
-				}
-
-			}
-		}
-	}
-#endif
-
 exit:
 	
 	if (pwep) {
-		rtw_mfree((u8 *)pwep, wep_total_len);		
+		kfree((u8 *)pwep);
 	}	
 	
 _func_exit_;
@@ -1070,7 +938,7 @@ static int rtw_set_wpa_ie(_adapter *pada
  	
 exit:
 
-	if (buf) rtw_mfree(buf, ielen);
+	if (buf) kfree(buf);
 
 	return ret;
 }
@@ -1569,17 +1437,14 @@ static int rtw_wx_set_wap(struct net_dev
 	}
 
 	authmode = padapter->securitypriv.ndisauthtype;
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
        phead = get_list_head(queue);
        pmlmepriv->pscanned = get_next(phead);
 
 	while (1)
 	 {
-			
-		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == true)
-		{
+		if (phead == pmlmepriv->pscanned)
 			break;
-		}
 	
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 
@@ -1594,7 +1459,7 @@ static int rtw_wx_set_wap(struct net_dev
 			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode))
 			{
 				ret = -1;
-				_exit_critical_bh(&queue->lock, &irqL);
+				spin_unlock_bh(&queue->lock);
 				goto exit;
 			}
 
@@ -1602,7 +1467,7 @@ static int rtw_wx_set_wap(struct net_dev
 		}
 
 	}		
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 	
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
@@ -1766,11 +1631,11 @@ _func_enter_;
 
 			DBG_871X("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
 		
-			_enter_critical_bh(&pmlmepriv->lock, &irqL);				
+			spin_lock_bh(&pmlmepriv->lock);
 		
 			_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);
 		
-			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			spin_unlock_bh(&pmlmepriv->lock);
 			
 		}
 		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
@@ -1908,14 +1773,14 @@ static int rtw_wx_get_scan(struct net_de
 	{
 		return -EAGAIN;
 	}
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
        
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 
 		if((stop - ev) < SCAN_ITEM_SIZE) {
@@ -1938,7 +1803,7 @@ static int rtw_wx_get_scan(struct net_de
 	
 	}        
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
        wrqu->data.length = ev-extra;
 	wrqu->data.flags = 0;
@@ -2023,13 +1888,13 @@ static int rtw_wx_set_essid(struct net_d
 		src_ssid = ndis_ssid.Ssid;
 		
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid=[%s]\n", src_ssid));
-		_enter_critical_bh(&queue->lock, &irqL);
+		spin_lock_bh(&queue->lock);
 	       phead = get_list_head(queue);
               pmlmepriv->pscanned = get_next(phead);
 
 		while (1)
 		{			
-			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true)
+			if (phead == pmlmepriv->pscanned)
 			{
 			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
 					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
@@ -2062,14 +1927,14 @@ static int rtw_wx_set_essid(struct net_d
 				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 				{
 					ret = -1;
-					_exit_critical_bh(&queue->lock, &irqL);
+					spin_unlock_bh(&queue->lock);
 					goto exit;
 				}
 
 				break;			
 			}
 		}
-		_exit_critical_bh(&queue->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
 		rtw_set_802_11_authentication_mode(padapter, authmode);
@@ -2764,11 +2629,9 @@ static int rtw_wx_set_enc_ext(struct net
 	case IW_ENCODE_ALG_CCMP:
 		alg_name = "CCMP";
 		break;
-#ifdef CONFIG_IEEE80211W
 	case IW_ENCODE_ALG_AES_CMAC:
 		alg_name = "BIP";
 		break;
-#endif //CONFIG_IEEE80211W
 	default:
 		ret = -1;
 		goto exit;
@@ -2786,9 +2649,7 @@ static int rtw_wx_set_enc_ext(struct net
 	 */
 	if ((pext->alg != IW_ENCODE_ALG_WEP) &&
 		((pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
-#ifdef CONFIG_IEEE80211W
 		|| (pext->ext_flags & IW_ENCODE_ALG_AES_CMAC)
-#endif //CONFIG_IEEE80211W
 	))
 	{
 		param->u.crypt.set_tx = 0;
@@ -2819,7 +2680,7 @@ static int rtw_wx_set_enc_ext(struct net
 exit:
 	if(param)
 	{
-		rtw_mfree((u8*)param, param_len);
+		kfree((u8*)param);
 	}
 
 	return ret;
@@ -2919,7 +2780,7 @@ static int rtw_wx_read32(struct net_devi
 	DBG_871X(KERN_INFO "%s: addr=0x%08X data=%s\n", __func__, addr, extra);
 
 exit:
-	rtw_mfree(ptmp, len);
+	kfree(ptmp);
 
 	return 0;
 }
@@ -3128,14 +2989,14 @@ static int rtw_get_ap_info(struct net_de
 		goto exit;
 	}	
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	
 	phead = get_list_head(queue);
 	plist = get_next(phead);
        
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== true)
+		if (phead == plist)
 			break;
 
 
@@ -3145,7 +3006,7 @@ static int rtw_get_ap_info(struct net_de
 		if(hwaddr_aton_i(data, bssid)) 
 		{			
 			DBG_871X("Invalid BSSID '%s'.\n", (u8*)data);
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			return -EINVAL;
 		}		
 		
@@ -3174,7 +3035,7 @@ static int rtw_get_ap_info(struct net_de
 	
 	}        
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if(pdata->length>=34)
 	{
@@ -3246,19 +3107,6 @@ static int rtw_wps_start(struct net_devi
 
 	DBG_871X( "[%s] wps_start = %d\n", __FUNCTION__, u32wps_start );
 
-	if ( u32wps_start == 1 ) // WPS Start
-	{
-		rtw_led_control(padapter, LED_CTL_START_WPS);
-	}
-	else if ( u32wps_start == 2 ) // WPS Stop because of wps success
-	{
-		rtw_led_control(padapter, LED_CTL_STOP_WPS);
-	}
-	else if ( u32wps_start == 3 ) // WPS Stop because of wps fail
-	{
-		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
-	}
-
 #ifdef CONFIG_INTEL_WIDI
 	process_intel_widi_wps_status(padapter, u32wps_start);
 #endif //CONFIG_INTEL_WIDI
@@ -3337,12 +3185,6 @@ static int rtw_rereg_nd_name(struct net_
 		goto exit;
 	}
 
-	if(!memcmp(rereg_priv->old_ifname, "disable%d", 9)) {
-		padapter->ledpriv.bRegUseLed= rereg_priv->old_bRegUseLed;
-		rtw_hal_sw_led_init(padapter);
-		//rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode);
-	}
-
 	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
 	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 	
@@ -3351,13 +3193,7 @@ static int rtw_rereg_nd_name(struct net_
 		DBG_871X("%s disable\n", __FUNCTION__);
 		// free network queue for Android's timming issue
 		rtw_free_network_queue(padapter, true);
-		
-		// close led
-		rtw_led_control(padapter, LED_CTL_POWER_OFF);
-		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
-		padapter->ledpriv.bRegUseLed= false;
-		rtw_hal_sw_led_deinit(padapter);
-		
+
 		// the interface is being "disabled", we can do deeper IPS
 		//rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv);
 		//rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL);
@@ -3576,18 +3412,17 @@ static int rtw_dbg_port(struct net_devic
 						int i, j;
 						_list	*plist, *phead;
 						struct recv_reorder_ctrl *preorder_ctrl;
-						
-#ifdef CONFIG_AP_MODE
+
 						DBG_871X("sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
-#endif						
-						_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+						spin_lock_bh(&pstapriv->sta_hash_lock);
 
 						for(i=0; i< NUM_STA; i++)
 						{
 							phead = &(pstapriv->sta_hash[i]);
 							plist = get_next(phead);
 		
-							while ((rtw_end_of_queue_search(phead, plist)) == false)
+							while (phead != plist)
 							{
 								psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -3602,15 +3437,12 @@ static int rtw_dbg_port(struct net_devic
 									DBG_871X("bwmode=%d, ch_offset=%d, sgi_20m=%d,sgi_40m=%d\n", psta->bw_mode, psta->htpriv.ch_offset, psta->htpriv.sgi_20m, psta->htpriv.sgi_40m);
 									DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
 									DBG_871X("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
-
-#ifdef CONFIG_AP_MODE
 									DBG_871X("capability=0x%x\n", psta->capability);
 									DBG_871X("flags=0x%x\n", psta->flags);
 									DBG_871X("wpa_psk=0x%x\n", psta->wpa_psk);
 									DBG_871X("wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
 									DBG_871X("wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
 									DBG_871X("qos_info=0x%x\n", psta->qos_info);
-#endif
 									DBG_871X("dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
 									
 									
@@ -3629,7 +3461,7 @@ static int rtw_dbg_port(struct net_devic
 							}
 						}
 	
-						_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+						spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 					}
 					break;
@@ -4164,7 +3996,7 @@ static int wpa_supplicant_ioctl(struct n
 	
 	if (copy_from_user(param, p->pointer, p->length))
 	{
-		rtw_mfree((u8*)param, p->length);
+		kfree((u8*)param);
 		ret = -EFAULT;
 		goto out;
 	}
@@ -4198,7 +4030,7 @@ static int wpa_supplicant_ioctl(struct n
 	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
 		ret = -EFAULT;
 
-	rtw_mfree((u8 *)param, p->length);
+	kfree((u8 *)param);
 	
 out:
 	
@@ -4208,7 +4040,6 @@ out:
 	
 }
 
-#ifdef CONFIG_AP_MODE
 static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
@@ -4531,7 +4362,7 @@ exit:
 
 	if(pwep)
 	{
-		rtw_mfree((u8 *)pwep, wep_total_len);		
+		kfree((u8 *)pwep);
 	}	
 	
 	return ret;
@@ -4615,9 +4446,9 @@ static int rtw_add_sta(struct net_device
 	if(psta)
 	{
 		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(padapter,  psta);		
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		psta = NULL;
 	}	
@@ -4702,15 +4533,15 @@ static int rtw_del_sta(struct net_device
 	
 		//DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid);
 
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if(rtw_is_list_empty(&psta->asoc_list)==false)
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if(list_empty(&psta->asoc_list)==false)
 		{			
-			rtw_list_delete(&psta->asoc_list);
+			list_del_init(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 
 		}
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 		
 		associated_clients_update(padapter, updated);
 	
@@ -4871,7 +4702,7 @@ static int rtw_set_wps_beacon(struct net
 
 	if(pmlmepriv->wps_beacon_ie)
 	{
-		rtw_mfree(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
+		kfree(pmlmepriv->wps_beacon_ie);
 		pmlmepriv->wps_beacon_ie = NULL;			
 	}	
 
@@ -4914,7 +4745,7 @@ static int rtw_set_wps_probe_resp(struct
 
 	if(pmlmepriv->wps_probe_resp_ie)
 	{
-		rtw_mfree(pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
+		kfree(pmlmepriv->wps_probe_resp_ie);
 		pmlmepriv->wps_probe_resp_ie = NULL;			
 	}	
 
@@ -4951,7 +4782,7 @@ static int rtw_set_wps_assoc_resp(struct
 
 	if(pmlmepriv->wps_assoc_resp_ie)
 	{
-		rtw_mfree(pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
+		kfree(pmlmepriv->wps_assoc_resp_ie);
 		pmlmepriv->wps_assoc_resp_ie = NULL;			
 	}	
 
@@ -5118,7 +4949,7 @@ static int rtw_hostapd_ioctl(struct net_
 	
 	if (copy_from_user(param, p->pointer, p->length))
 	{
-		rtw_mfree((u8*)param, p->length);
+		kfree((u8*)param);
 		ret = -EFAULT;
 		goto out;
 	}
@@ -5222,14 +5053,13 @@ static int rtw_hostapd_ioctl(struct net_
 		ret = -EFAULT;
 
 
-	rtw_mfree((u8 *)param, p->length);
+	kfree((u8 *)param);
 	
 out:
 		
 	return ret;
 	
 }
-#endif
 
 static int rtw_wx_set_priv(struct net_device *dev,
 				struct iw_request_info *info,
@@ -5258,7 +5088,7 @@ static int rtw_wx_set_priv(struct net_de
 		return -ENOMEM;
 
 	if (copy_from_user(ext, dwrq->pointer, len)) {
-		rtw_vmfree(ext, len);
+		vfree(ext);
 		return -EFAULT;
 	}
 
@@ -5270,7 +5100,7 @@ static int rtw_wx_set_priv(struct net_de
 	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV	
 	if (!(ext_dbg = vmalloc(len)))
 	{
-		rtw_vmfree(ext, len);
+		vfree(ext, len);
 		return -ENOMEM;
 	}	
 	
@@ -5295,7 +5125,7 @@ static int rtw_wx_set_priv(struct net_de
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
-				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
+				kfree(pmlmepriv->wps_probe_req_ie);
 				pmlmepriv->wps_probe_req_ie = NULL;			
 			}	
 
@@ -5325,9 +5155,9 @@ static int rtw_wx_set_priv(struct net_de
 	
 FREE_EXT:
 
-	rtw_vmfree(ext, len);
+	vfree(ext);
 	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
-	rtw_vmfree(ext_dbg, len);
+	vfree(ext_dbg);
 	#endif
 
 	//DBG_871X("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n", 
@@ -5336,162 +5166,6 @@ FREE_EXT:
 	return ret;
 	
 }
-#ifdef CONFIG_WOWLAN
-static int rtw_wowlan_ctrl(struct net_device *dev,
-						struct iw_request_info *info,
-						union iwreq_data *wrqu, char *extra)
-{
-	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
-	struct wowlan_ioctl_param poidparam;
-	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct net_device *pnetdev = padapter->pnetdev;
-	struct sta_info	*psta = NULL;
-	int ret = 0;
-	unsigned long start_time = jiffies;
-	poidparam.subcode = 0;
-
-	DBG_871X("+rtw_wowlan_ctrl: %s\n", extra);
-	
-	if(pwrctrlpriv->bSupportRemoteWakeup==false){
-		ret = -EPERM;
-		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
-		goto _rtw_wowlan_ctrl_exit_free;
-	}
-
-	if (!check_fwstate(pmlmepriv, _FW_LINKED) && 
-			check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
-			DBG_871X("[%s] WARNING: Please Connect With AP First!!\n", __func__);
-			goto _rtw_wowlan_ctrl_exit_free;
-	}
-
-	if (!memcmp( extra, "enable", 6 )) {
-
-		padapter->registrypriv.mp_mode = 1;
-
-		while (pwrctrlpriv->bips_processing == true)
-			msleep(1);
-
-		rtw_ps_deny(padapter, PS_DENY_SUSPEND);
-
-		rtw_cancel_all_timer(padapter);
-
-		LeaveAllPowerSaveModeDirect(padapter);
-
-		rtw_stop_cmd_thread(padapter);
-
-		rtw_ps_deny_cancel(padapter, PS_DENY_SUSPEND);
-
-		rtw_suspend_wow(padapter);
-
-	} else if (!memcmp( extra, "disable", 6 )) {
-		rtw_resume_process_wow(padapter);
-		padapter->registrypriv.mp_mode = 0;
-	} else {
-		DBG_871X("[%s] Invalid Parameter.\n", __func__);
-		goto _rtw_wowlan_ctrl_exit_free;
-	}
-	//mutex_lock(&ioctl_mutex);
-_rtw_wowlan_ctrl_exit_free:
-	DBG_871X("-rtw_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
-	DBG_871X_LEVEL(_drv_always_, "%s in %d ms\n", __func__,
-			jiffies_to_msecs(jiffies - start_time));
-_rtw_wowlan_ctrl_exit:
-	return ret;
-}
-#endif //CONFIG_WOWLAN
-
-#ifdef CONFIG_AP_WOWLAN
-static int rtw_ap_wowlan_ctrl(struct net_device *dev,
-						struct iw_request_info *info,
-						union iwreq_data *wrqu, char *extra)
-{
-	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
-	struct wowlan_ioctl_param poidparam;
-	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct sta_info	*psta = NULL;
-	int ret = 0;
-	unsigned long start_time = jiffies;
-	poidparam.subcode = 0;
-
-	DBG_871X("+rtw_ap_wowlan_ctrl: %s\n", extra);
-
-	if(pwrctrlpriv->bSupportRemoteWakeup==false){
-		ret = -EPERM;
-		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
-		goto _rtw_ap_wowlan_ctrl_exit_free;
-	}
-
-	if (!check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
-		DBG_871X("[%s] It is not AP mode!!\n", __func__);
-		goto _rtw_ap_wowlan_ctrl_exit_free;
-	}
-
-	if (!memcmp( extra, "enable", 6 )) {
-		pwrctrlpriv->wowlan_ap_mode = true;
-		while (pwrctrlpriv->bips_processing == true)
-			msleep(1);
-
-		rtw_cancel_all_timer(padapter);
-
-		padapter->bDriverStopped = true;	//for stop thread
-		rtw_stop_drv_threads(padapter);
-		padapter->bDriverStopped = false;	//for 32k command
-
-		LeaveAllPowerSaveModeDirect(padapter);
-		rtw_hal_disable_interrupt(padapter); // It need wait for leaving 32K.
-
-		// 2.1 clean interupt
-		if (padapter->HalFunc.clear_interrupt)
-			padapter->HalFunc.clear_interrupt(padapter);
-
-		poidparam.subcode = WOWLAN_AP_ENABLE;
-
-		rtw_hal_set_hwreg(padapter, HW_VAR_AP_WOWLAN,(u8 *)&poidparam);
-	} else if (!memcmp( extra, "disable", 6 )) {
-		LeaveAllPowerSaveModeDirect(padapter);
-		pwrctrlpriv->bFwCurrentInPSMode = false;
-
-		rtw_hal_disable_interrupt(padapter);
-
-		if (padapter->HalFunc.clear_interrupt)
-			padapter->HalFunc.clear_interrupt(padapter);
-
-		poidparam.subcode = WOWLAN_AP_ENABLE;
-
-		rtw_hal_set_hwreg(padapter, HW_VAR_AP_WOWLAN,(u8 *)&poidparam);
-
-		pwrctrlpriv->wowlan_ap_mode = false;
-
-		psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
-		if (psta) {
-			set_sta_rate(padapter, psta);
-		}
-
-		padapter->bDriverStopped = false;
-		DBG_871X("%s: wowmode resuming, DriverStopped:%d\n", __func__, padapter->bDriverStopped);
-		rtw_start_drv_threads(padapter);
-
-		rtw_hal_enable_interrupt(padapter);
-
-		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
-		pwrctrlpriv->bips_processing = false;
-		rtw_set_pwr_state_check_timer(pwrctrlpriv);
-
-	} else {
-		DBG_871X("[%s] Invalid Parameter.\n", __func__);
-		goto _rtw_ap_wowlan_ctrl_exit_free;
-	}
-	//mutex_lock(&ioctl_mutex);
-_rtw_ap_wowlan_ctrl_exit_free:
-	DBG_871X("-rtw_ap_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
-	DBG_871X_LEVEL(_drv_always_, "%s in %d ms\n", __func__,
-			jiffies_to_msecs(jiffies - start_time));
-_rtw_ap_wowlan_ctrl_exit:
-	return ret;
-}
-#endif //CONFIG_AP_WOWLAN
 
 static int rtw_pm_set(struct net_device *dev,
                                struct iw_request_info *info,
@@ -5616,7 +5290,7 @@ static int rtw_test(
 	}
 
 	if (copy_from_user(pbuf, wrqu->data.pointer, len)) {
-		rtw_mfree(pbuf, len);
+		kfree(pbuf);
 		DBG_871X("%s: copy from user fail!\n", __func__);
 		return -EFAULT;
 	}
@@ -5625,7 +5299,7 @@ static int rtw_test(
 	ptmp = (char*)pbuf;
 	pch = strsep(&ptmp, delim);
 	if ((pch == NULL) || (strlen(pch) == 0)) {
-		rtw_mfree(pbuf, len);
+		kfree(pbuf);
 		DBG_871X("%s: parameter error(level 1)!\n", __func__);
 		return -EFAULT;
 	}
@@ -5660,7 +5334,7 @@ static int rtw_test(
 		} while (count < 8);
 
 		if (count == 0) {
-			rtw_mfree(pbuf, len);
+			kfree(pbuf);
 			DBG_871X("%s: parameter error(level 2)!\n", __func__);
 			return -EFAULT;
 		}
@@ -5678,7 +5352,7 @@ static int rtw_test(
 		wrqu->data.length = strlen(extra) + 1;
 	}
 
-	rtw_mfree(pbuf, len);
+	kfree(pbuf);
 	return 0;
 }
 
@@ -6230,7 +5904,7 @@ static int rtw_ioctl_wext_private(struct
 		}
 	}
 
-	rtw_mfree(input, input_len);
+	kfree(input);
 	input = NULL;
 
 	extra_size = 0;
@@ -6255,7 +5929,7 @@ static int rtw_ioctl_wext_private(struct
 
 	if (extra_size == 0) {
 		extra = (u8*)&wdata;
-		rtw_mfree(buffer, 4096);
+		kfree(buffer);
 		buffer = NULL;
 	} else
 		extra = buffer;
@@ -6341,11 +6015,11 @@ static int rtw_ioctl_wext_private(struct
 
 exit:
 	if (input)
-		rtw_mfree(input, input_len);
+		kfree(input);
 	if (buffer)
-		rtw_mfree(buffer, 4096);
+		kfree(buffer);
 	if (output)
-		rtw_mfree(output, 4096);
+		kfree(output);
 
 	return err;
 }
@@ -6360,11 +6034,9 @@ int rtw_ioctl(struct net_device *dev, st
 		case RTL_IOCTL_WPA_SUPPLICANT:
 			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
 			break;
-#ifdef CONFIG_AP_MODE
 		case RTL_IOCTL_HOSTAPD:
 			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
 			break;
-#endif // CONFIG_AP_MODE
 		case SIOCDEVPRIVATE:
 			ret = rtw_ioctl_wext_private(dev, &wrq->u);
 			break;
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/mlme_linux.c linux/3rdparty/rtl8723bs/os_dep/mlme_linux.c
--- linux/3rdparty/rtl8723bs.old/os_dep/mlme_linux.c	2015-05-10 14:36:05.740668702 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/mlme_linux.c	2015-05-07 17:46:55.000000000 +0300
@@ -23,32 +23,6 @@
 
 #include <drv_types.h>
 
-
-/*
-void sitesurvey_ctrl_handler(void *FunctionContext)
-{
-	_adapter *adapter = (_adapter *)FunctionContext;
-
-	_sitesurvey_ctrl_handler(adapter);
-
-	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
-}
-*/
-
-void rtw_join_timeout_handler (void *FunctionContext)
-{
-	_adapter *adapter = (_adapter *)FunctionContext;
-	_rtw_join_timeout_handler(adapter);
-}
-
-
-void _rtw_scan_timeout_handler (void *FunctionContext)
-{
-	_adapter *adapter = (_adapter *)FunctionContext;
-	rtw_scan_timeout_handler(adapter);
-}
-
-
 static void _dynamic_check_timer_handlder (void *FunctionContext)
 {
 	_adapter *adapter = (_adapter *)FunctionContext;
@@ -68,9 +42,9 @@ void rtw_init_mlme_timer(_adapter *padap
 {
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, rtw_join_timeout_handler, padapter);
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, _rtw_join_timeout_handler, padapter);
 	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, padapter);
-	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _rtw_scan_timeout_handler, padapter);
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, rtw_scan_timeout_handler, padapter);
 
 	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, padapter);
 
@@ -120,7 +94,7 @@ void rtw_reset_securitypriv( _adapter *a
 	_irqL irqL;
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	
-	_enter_critical_bh(&adapter->security_key_mutex, &irqL);
+	spin_lock_bh(&adapter->security_key_mutex);
 	
 	if(adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
 	{		 
@@ -136,12 +110,11 @@ void rtw_reset_securitypriv( _adapter *a
 		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
 		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
 		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;		
-#ifdef CONFIG_IEEE80211W
+
 		//reset RX BIP packet number
 		pmlmeext->mgnt_80211w_IPN_rx = 0;
-#endif //CONFIG_IEEE80211W
+
 		memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
-		//_init_timer(&(adapter->securitypriv.tkip_timer),adapter->pnetdev, rtw_use_tkipkey_handler, adapter);
 
 		// Added by Albert 2009/02/18
 		// Restore the PMK information to securitypriv structure for the following connection.
@@ -172,7 +145,7 @@ void rtw_reset_securitypriv( _adapter *a
 		//}
 	}
 	// add for CONFIG_IEEE80211W, none 11w also can use
-	_exit_critical_bh(&adapter->security_key_mutex, &irqL);
+	spin_unlock_bh(&adapter->security_key_mutex);
 }
 
 void rtw_os_indicate_disconnect( _adapter *adapter )
@@ -234,118 +207,26 @@ _func_enter_;
 
 		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
 
-		rtw_mfree(buff, IW_CUSTOM_MAX);
+		kfree(buff);
 	}
 
 _func_exit_;
 }
 
-static void _survey_timer_hdl (void *FunctionContext)
-{
-	_adapter *padapter = (_adapter *)FunctionContext;
-	
-	survey_timer_hdl(padapter);
-}
-
-static void _link_timer_hdl (void *FunctionContext)
-{
-	_adapter *padapter = (_adapter *)FunctionContext;
-	link_timer_hdl(padapter);
-}
-
-static void _addba_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *psta = (struct sta_info *)FunctionContext;
-	addba_timer_hdl(psta);
-}
-
-#ifdef CONFIG_IEEE80211W
-void _sa_query_timer_hdl (void *FunctionContext)
-{
-	_adapter *padapter = (_adapter *)FunctionContext;
-	sa_query_timer_hdl(padapter);
-}
-#endif //CONFIG_IEEE80211W
-
 void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta)
 {
-
-	_init_timer(&psta->addba_retry_timer, padapter->pnetdev, _addba_timer_hdl, psta);
-}
-
-/*
-void _reauth_timer_hdl(void *FunctionContext)
-{
-	_adapter *padapter = (_adapter *)FunctionContext;
-	reauth_timer_hdl(padapter);
+	_init_timer(&psta->addba_retry_timer, padapter->pnetdev, addba_timer_hdl, psta);
 }
 
-void _reassoc_timer_hdl(void *FunctionContext)
-{
-	_adapter *padapter = (_adapter *)FunctionContext;
-	reassoc_timer_hdl(padapter);
-}
-*/
-
 void init_mlme_ext_timer(_adapter *padapter)
 {	
 	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
-	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
-#ifdef CONFIG_IEEE80211W
-	_init_timer(&pmlmeext->sa_query_timer, padapter->pnetdev, _sa_query_timer_hdl, padapter);
-#endif //CONFIG_IEEE80211W
-	//_init_timer(&pmlmeext->ADDBA_timer, padapter->pnetdev, _addba_timer_hdl, padapter);
+	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, survey_timer_hdl, padapter);
+	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, link_timer_hdl, padapter);
+	_init_timer(&pmlmeext->sa_query_timer, padapter->pnetdev, sa_query_timer_hdl, padapter);
+	//_init_timer(&pmlmeext->ADDBA_timer, padapter->pnetdev, addba_timer_hdl, padapter);
 
 	//_init_timer(&pmlmeext->reauth_timer, padapter->pnetdev, _reauth_timer_hdl, padapter);
 	//_init_timer(&pmlmeext->reassoc_timer, padapter->pnetdev, _reassoc_timer_hdl, padapter);
 }
-
-#ifdef CONFIG_AP_MODE
-
-void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta)
-{
-	union iwreq_data wrqu;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-
-	if(psta==NULL)
-		return;
-
-	if(psta->aid > NUM_STA)
-		return;
-
-	if(pstapriv->sta_aid[psta->aid - 1] != psta)
-		return;
-	
-	
-	wrqu.addr.sa_family = ARPHRD_ETHER;	
-	
-	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
-
-	DBG_871X("+rtw_indicate_sta_assoc_event\n");
-}
-
-void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta)
-{
-	union iwreq_data wrqu;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-
-	if(psta==NULL)
-		return;
-
-	if(psta->aid > NUM_STA)
-		return;
-
-	if(pstapriv->sta_aid[psta->aid - 1] != psta)
-		return;
-	
-	
-	wrqu.addr.sa_family = ARPHRD_ETHER;	
-	
-	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
-
-	DBG_871X("+rtw_indicate_sta_disassoc_event\n");
-}
-
-#endif
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/osdep_service.c linux/3rdparty/rtl8723bs/os_dep/osdep_service.c
--- linux/3rdparty/rtl8723bs.old/os_dep/osdep_service.c	2015-05-10 14:36:05.740668702 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/osdep_service.c	2015-05-07 17:46:55.000000000 +0300
@@ -27,30 +27,11 @@
 * Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
 * @return: one of RTW_STATUS_CODE
 */
-inline int RTW_STATUS_CODE(int error_code){
+inline int RTW_STATUS_CODE(int error_code)
+{
 	if(error_code >=0)
 		return _SUCCESS;
-
-	switch(error_code) {
-		//case -ETIMEDOUT:
-		//	return RTW_STATUS_TIMEDOUT;
-		default:
-			return _FAIL;
-	}
-}
-
-inline u8* _rtw_zvmalloc(u32 sz)
-{
-	u8 	*pbuf;
-	pbuf = vmalloc(sz);
-	if (pbuf != NULL)
-		memset(pbuf, 0, sz);
-	return pbuf;	
-}
-
-inline void _rtw_vmfree(u8 *pbuf, u32 sz)
-{
-	vfree(pbuf);
+	return _FAIL;
 }
 
 u8* _rtw_malloc(u32 sz)
@@ -73,21 +54,11 @@ u8* _rtw_zmalloc(u32 sz)
 	return pbuf;	
 }
 
-void	_rtw_mfree(u8 *pbuf, u32 sz)
-{
-	kfree(pbuf);
-}
-
 inline struct sk_buff *_rtw_skb_alloc(u32 sz)
 {
 	return __dev_alloc_skb(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 }
 
-inline void _rtw_skb_free(struct sk_buff *skb)
-{
-	dev_kfree_skb_any(skb);
-}
-
 inline struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb)
 {
 	return skb_copy(skb, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
@@ -104,46 +75,6 @@ inline int _rtw_netif_rx(_nic_hdl ndev,
 	return netif_rx(skb);
 }
 
-void _rtw_skb_queue_purge(struct sk_buff_head *list)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(list)) != NULL)
-		_rtw_skb_free(skb);
-}
-
-void _rtw_init_listhead(_list *list)
-{
-
-        INIT_LIST_HEAD(list);
-}
-
-
-/*
-For the following list_xxx operations, 
-caller must guarantee the atomic context.
-Otherwise, there will be racing condition.
-*/
-u32	rtw_is_list_empty(_list *phead)
-{
-
-	if (list_empty(phead))
-		return true;
-	else
-		return false;
-}
-
-void rtw_list_insert_head(_list *plist, _list *phead)
-{
-	list_add(plist, phead);
-}
-
-void rtw_list_insert_tail(_list *plist, _list *phead)
-{
-
-	list_add_tail(plist, phead);
-}
-
 void rtw_init_timer(_timer *ptimer, void *padapter, void *pfunc)
 {
 	_adapter *adapter = (_adapter *)padapter;	
@@ -151,111 +82,13 @@ void rtw_init_timer(_timer *ptimer, void
 	_init_timer(ptimer, adapter->pnetdev, pfunc, adapter);
 }
 
-/*
-
-Caller must check if the list is empty before calling rtw_list_delete
-
-*/
-
-
 void	_rtw_init_queue(_queue	*pqueue)
 {
-	_rtw_init_listhead(&(pqueue->queue));
+	INIT_LIST_HEAD(&(pqueue->queue));
 
 	spin_lock_init(&(pqueue->lock));
 }
 
-u32	  _rtw_queue_empty(_queue	*pqueue)
-{
-	return (rtw_is_list_empty(&(pqueue->queue)));
-}
-
-
-u32 rtw_end_of_queue_search(_list *head, _list *plist)
-{
-	if (head == plist)
-		return true;
-	else
-		return false;
-}
-
-inline u32 rtw_systime_to_ms(u32 systime)
-{
-	return systime * 1000 / HZ;
-}
-
-inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
-{
-	return rtw_systime_to_ms(end-start);
-}
-
-void rtw_sleep_schedulable(int ms)	
-{
-    u32 delta;
-    
-    delta = (ms * HZ)/1000;//(ms)
-    if (delta == 0) {
-        delta = 1;// 1 ms
-    }
-    set_current_state(TASK_INTERRUPTIBLE);
-    if (schedule_timeout(delta) != 0) {
-        return ;
-    }
-    return;
-}
-
-#define RTW_SUSPEND_LOCK_NAME "rtw_wifi"
-#define RTW_SUSPEND_EXT_LOCK_NAME "rtw_wifi_ext"
-#define RTW_SUSPEND_RX_LOCK_NAME "rtw_wifi_rx"
-#define RTW_SUSPEND_TRAFFIC_LOCK_NAME "rtw_wifi_traffic"
-#define RTW_SUSPEND_RESUME_LOCK_NAME "rtw_wifi_resume"
-#define RTW_RESUME_SCAN_LOCK_NAME "rtw_wifi_scan"
-
-inline void rtw_suspend_lock_init(void)
-{
-}
-
-inline void rtw_suspend_lock_uninit(void)
-{
-}
-
-inline void rtw_lock_suspend(void)
-{
-}
-
-inline void rtw_unlock_suspend(void)
-{
-}
-
-inline void rtw_resume_lock_suspend(void)
-{
-}
-
-inline void rtw_resume_unlock_suspend(void)
-{
-}
-
-inline void rtw_lock_suspend_timeout(u32 timeout_ms)
-{
-}
-
-inline void rtw_lock_ext_suspend_timeout(u32 timeout_ms)
-{
-}
-
-inline void rtw_lock_rx_suspend_timeout(u32 timeout_ms)
-{
-}
-
-
-inline void rtw_lock_traffic_suspend_timeout(u32 timeout_ms)
-{
-}
-
-inline void rtw_lock_resume_scan_timeout(u32 timeout_ms)
-{
-}
-
 /*
 * Open a file with the specific @param path, @param flag, @param mode
 * @param fpp the pointer of struct file pointer to get struct file pointer while file opening is success
@@ -311,27 +144,6 @@ static int readFile(struct file *fp,char
 
 }
 
-static int writeFile(struct file *fp,char *buf,int len) 
-{ 
-	int wlen=0, sum=0;
-	
-	if (!fp->f_op || !fp->f_op->write) 
-		return -EPERM; 
-
-	while(sum<len) {
-		wlen=fp->f_op->write(fp,(char __force __user *)buf+sum,len-sum, &fp->f_pos);
-		if(wlen>0)
-			sum+=wlen;
-		else if(0 != wlen)
-			return wlen;
-		else
-			break;
-	}
-
-	return sum;
-
-}
-
 /*
 * Test if the specifi @param path is a file and readable
 * @param path the path of the file to test
@@ -395,40 +207,6 @@ static int retriveFromFile(char *path, u
 }
 
 /*
-* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
-* @param path the path of the file to open and write
-* @param buf the starting address of the data to write into file
-* @param sz how many bytes to write at most
-* @return the byte we've written, or Linux specific error code
-*/
-static int storeToFile(char *path, u8* buf, u32 sz)
-{
-	int ret =0;
-	mm_segment_t oldfs;
-	struct file *fp;
-	
-	if(path && buf) {
-		if( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
-			DBG_871X("%s openFile path:%s fp=%p\n",__FUNCTION__, path ,fp);
-
-			oldfs = get_fs(); set_fs(get_ds());
-			ret=writeFile(fp, buf, sz);
-			set_fs(oldfs);
-			closeFile(fp);
-
-			DBG_871X("%s writeFile, ret:%d\n",__FUNCTION__, ret);
-			
-		} else {
-			DBG_871X("%s openFile path:%s Fail, ret:%d\n",__FUNCTION__, path, ret);
-		}	
-	} else {
-		DBG_871X("%s NULL pointer\n",__FUNCTION__);
-		ret =  -EINVAL;
-	}
-	return ret;
-}
-
-/*
 * Test if the specifi @param path is a file and readable
 * @param path the path of the file to test
 * @return true or false
@@ -454,19 +232,6 @@ int rtw_retrive_from_file(char *path, u8
 	return ret>=0?ret:0;
 }
 
-/*
-* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
-* @param path the path of the file to open and write
-* @param buf the starting address of the data to write into file
-* @param sz how many bytes to write at most
-* @return the byte we've written
-*/
-int rtw_store_to_file(char *path, u8* buf, u32 sz)
-{
-	int ret =storeToFile(path, buf, sz);
-	return ret>=0?ret:0;
-}
-
 struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv)
 {
 	struct net_device *pnetdev;
@@ -495,7 +260,7 @@ struct net_device *rtw_alloc_etherdev(in
 	
 	pnpi = netdev_priv(pnetdev);
 	
-	pnpi->priv = rtw_zvmalloc(sizeof_priv);
+	pnpi->priv = vzalloc(sizeof_priv);
 	if (!pnpi->priv) {
 		free_netdev(pnetdev);
 		pnetdev = NULL;
@@ -519,7 +284,7 @@ void rtw_free_netdev(struct net_device *
 	if(!pnpi->priv)
 		goto RETURN;
 
-	rtw_vmfree(pnpi->priv, pnpi->sizeof_priv);
+	vfree(pnpi->priv);
 	free_netdev(netdev);
 
 RETURN:
@@ -587,17 +352,6 @@ u64 rtw_modular64(u64 x, u64 y)
 	return do_div(x, y);
 }
 
-u64 rtw_division64(u64 x, u64 y)
-{
-	do_div(x, y);
-	return x;
-}
-
-inline u32 rtw_random32(void)
-{
-	return prandom_u32();
-}
-
 void rtw_buf_free(u8 **buf, u32 *buf_len)
 {
 	u32 ori_len;
@@ -610,7 +364,7 @@ void rtw_buf_free(u8 **buf, u32 *buf_len
 	if (*buf) {
 		u32 tmp_buf_len = *buf_len;
 		*buf_len = 0;
-		rtw_mfree(*buf, tmp_buf_len);
+		kfree(*buf);
 		*buf = NULL;
 	}
 }
@@ -645,7 +399,7 @@ keep_ori:
 
 	/* free ori */
 	if (ori && ori_len > 0)
-		rtw_mfree(ori, ori_len);
+		kfree(ori);
 }
 
 
@@ -730,13 +484,3 @@ struct rtw_cbuf *rtw_cbuf_alloc(u32 size
 
 	return cbuf;
 }
-
-/**
- * rtw_cbuf_free - free the given rtw_cbuf
- * @cbuf: pointer of struct rtw_cbuf to free
- */
-void rtw_cbuf_free(struct rtw_cbuf *cbuf)
-{
-	rtw_mfree((u8*)cbuf, sizeof(*cbuf) + sizeof(void*)*cbuf->size);
-}
-
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/os_intfs.c linux/3rdparty/rtl8723bs/os_dep/os_intfs.c
--- linux/3rdparty/rtl8723bs.old/os_dep/os_intfs.c	2015-05-10 14:36:05.741668714 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/os_intfs.c	2015-05-07 17:46:55.000000000 +0300
@@ -85,9 +85,8 @@ int rtw_ht_enable = 1;
 // 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
 // 0x21 means enable 2.4G 40MHz & 5G 80MHz
 static int rtw_bw_mode = 0x21;
-static int rtw_cbw40_enable = 3; // 0 :diable, bit(0): enable 2.4g, bit(1): enable 5g
 static int rtw_ampdu_enable = 1;//for enable tx_ampdu ,// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
-static int rtw_rx_stbc = 1;// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
+static int rtw_rx_stbc = 1;// 0: disable, 1:enable 2.4g
 static int rtw_ampdu_amsdu = 0;// 0: disabled, 1:enabled, 2:auto . There is an IOT issu with DLINK DIR-629 when the flag turn on
 // Short GI support Bit Map
 // BIT0 - 20MHz, 0: non-support, 1: support
@@ -138,13 +137,9 @@ static int rtw_hwpwrp_detect = 0; //HW p
 
 static int rtw_hw_wps_pbc = 0;
 
-#ifdef CONFIG_TX_MCAST2UNI
 int rtw_mc2u_disable = 0;
-#endif	// CONFIG_TX_MCAST2UNI
 
-#ifdef CONFIG_80211D
 static int rtw_80211d = 0;
-#endif
 
 #ifdef CONFIG_QOS_OPTIMIZATION
 static int rtw_qos_opt_enable=1;//0: disable,1:enable
@@ -199,11 +194,9 @@ module_param(rtw_hwpwrp_detect, int, 064
 
 module_param(rtw_hw_wps_pbc, int, 0644);
 
-#ifdef CONFIG_LAYER2_ROAMING
 static uint rtw_max_roaming_times=2;
 module_param(rtw_max_roaming_times, uint, 0644);
 MODULE_PARM_DESC(rtw_max_roaming_times,"The max roaming times to try");
-#endif //CONFIG_LAYER2_ROAMING
 
 #ifdef CONFIG_FILE_FWIMG
 static char *rtw_fw_file_path = "/system/etc/firmware/rtlwifi/FW_NIC.BIN";
@@ -216,19 +209,17 @@ MODULE_PARM_DESC(rtw_fw_wow_file_path, "
 
 #endif // CONFIG_FILE_FWIMG
 
-#ifdef CONFIG_TX_MCAST2UNI
 module_param(rtw_mc2u_disable, int, 0644);
-#endif	// CONFIG_TX_MCAST2UNI
 
-#ifdef CONFIG_80211D
 module_param(rtw_80211d, int, 0644);
 MODULE_PARM_DESC(rtw_80211d, "Enable 802.11d mechanism");
-#endif
 
-static uint rtw_notch_filter = RTW_NOTCH_FILTER;
+static uint rtw_notch_filter = 0;
 module_param(rtw_notch_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
 
+#define CONFIG_RTW_HIQ_FILTER 1
+
 static uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;
 module_param(rtw_hiq_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_hiq_filter, "0:allow all, 1:allow special, 2:deny all");
@@ -295,15 +286,9 @@ _func_enter_;
 	registry_par->channel = (u8)rtw_channel;
 	registry_par->wireless_mode = (u8)rtw_wireless_mode;
 
-	if (IsSupported24G(registry_par->wireless_mode) && (!IsSupported5G(registry_par->wireless_mode))
-		&& (registry_par->channel > 14)) {
+	if (registry_par->channel > 14)
 		registry_par->channel = 1;
-	}
-	else if (IsSupported5G(registry_par->wireless_mode) && (!IsSupported24G(registry_par->wireless_mode))
-		&& (registry_par->channel <= 14)) {
-		registry_par->channel = 36;
-	}
-	
+
 	registry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense ;
 	registry_par->vcs_type = (u8)rtw_vcs_type;
 	registry_par->rts_thresh=(u16)rtw_rts_thresh;
@@ -370,16 +355,12 @@ _func_enter_;
 
 	registry_par->hw_wps_pbc = (u8)rtw_hw_wps_pbc;
 
-#ifdef CONFIG_LAYER2_ROAMING
 	registry_par->max_roaming_times = (u8)rtw_max_roaming_times;
 #ifdef CONFIG_INTEL_WIDI
 	registry_par->max_roaming_times = (u8)rtw_max_roaming_times + 2;
 #endif // CONFIG_INTEL_WIDI
-#endif
 
-#ifdef CONFIG_80211D
 	registry_par->enable80211d = (u8)rtw_80211d;
-#endif
 
 	snprintf(registry_par->ifname, 16, "%s", ifname);
 	snprintf(registry_par->if2name, 16, "%s", if2name);
@@ -697,8 +678,7 @@ void rtw_stop_drv_threads (_adapter *pad
 	rtw_hal_stop_thread(padapter);
 }
 
-u8 rtw_init_default_value(_adapter *padapter);
-u8 rtw_init_default_value(_adapter *padapter)
+static u8 rtw_init_default_value(_adapter *padapter)
 {
 	u8 ret  = _SUCCESS;
 	struct registry_priv* pregistrypriv = &padapter->registrypriv;
@@ -808,7 +788,7 @@ void devobj_deinit(struct dvobj_priv *pd
 	mutex_destroy(&pdvobj->setch_mutex);
 	mutex_destroy(&pdvobj->setbw_mutex);
 
-	rtw_mfree((u8*)pdvobj, sizeof(*pdvobj));
+	kfree((u8*)pdvobj);
 }	
 
 u8 rtw_reset_drv_sw(_adapter *padapter)
@@ -907,11 +887,9 @@ _func_enter_;
 	// add for CONFIG_IEEE80211W, none 11w also can use
 	spin_lock_init(&padapter->security_key_mutex);
 	
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
+	// We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc().
 	//memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));
 
-	//_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pifp, rtw_use_tkipkey_handler, padapter);
-
 	if(_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
 	{
 		DBG_871X("Can't _rtw_init_sta_priv\n");
@@ -929,7 +907,6 @@ _func_enter_;
 	//memset((u8 *)&padapter->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv
 
 	rtw_hal_dm_init(padapter);
-	rtw_hal_sw_led_init(padapter);
 
 #ifdef CONFIG_INTEL_WIDI
 	if(rtw_init_intel_widi(padapter) == _FAIL)
@@ -940,11 +917,6 @@ _func_enter_;
 	}
 #endif //CONFIG_INTEL_WIDI
 
-#ifdef CONFIG_WAPI_SUPPORT
-	padapter->WapiSupport = true; //set true temp, will revise according to Efuse or Registry value later.
-	rtw_wapi_init(padapter);
-#endif
-
 exit:
 
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_init_drv_sw\n"));
@@ -955,14 +927,6 @@ exit:
 
 }
 
-#ifdef CONFIG_WOWLAN
-void rtw_cancel_dynamic_chk_timer(_adapter *padapter)
-{
-	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel dynamic_chk_timer! \n"));
-}
-#endif
-
 void rtw_cancel_all_timer(_adapter *padapter)
 {
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_cancel_all_timer\n"));
@@ -979,10 +943,6 @@ void rtw_cancel_all_timer(_adapter *pada
 	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel dynamic_chk_timer! \n"));
 
-	// cancel sw led timer
-	rtw_hal_sw_led_deinit(padapter);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel DeInitSwLeds! \n"));
-
 	_cancel_timer_ex(&(adapter_to_pwrctl(padapter)->pwr_state_check_timer));
 
 	_cancel_timer_ex(&padapter->mlmepriv.set_scan_deny_timer);
@@ -1001,10 +961,6 @@ u8 rtw_free_drv_sw(_adapter *padapter)
 
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("==>rtw_free_drv_sw"));
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_wapi_free(padapter);
-#endif
-
 #ifdef CONFIG_INTEL_WIDI
 	rtw_free_intel_widi(padapter);
 #endif //CONFIG_INTEL_WIDI
@@ -1027,7 +983,7 @@ u8 rtw_free_drv_sw(_adapter *padapter)
 
 	rtw_free_pwrctrl_priv(padapter);
 
-	//rtw_mfree((void *)padapter, sizeof (padapter));
+	//kfree((void *)padapter);
 
 	rtw_hal_free_data(padapter);
 
@@ -1160,8 +1116,6 @@ int _netdev_open(struct net_device *pnet
 
 		rtw_cfg80211_init_wiphy(padapter);
 
-		rtw_led_control(padapter, LED_CTL_NO_LINK);
-
 		padapter->bup = true;
 		pwrctrlpriv->bips_processing = false;
 	}
@@ -1208,9 +1162,11 @@ int netdev_open(struct net_device *pnetd
 		return 0;
 	}
 
-	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	if (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->hw_init_mutex)))
+		return -1;
+
 	ret = _netdev_open(pnetdev);
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+	mutex_unlock(&(adapter_to_dvobj(padapter)->hw_init_mutex));
 
 	return ret;
 }
@@ -1262,8 +1218,6 @@ int rtw_ips_pwr_up(_adapter *padapter)
 
 	result = ips_netdrv_open(padapter);
 
-	rtw_led_control(padapter, LED_CTL_NO_LINK);
-
  	DBG_871X("<===  rtw_ips_pwr_up.............. in %dms\n", jiffies_to_msecs(jiffies - start_time));
 	return result;
 
@@ -1300,15 +1254,16 @@ void rtw_ips_dev_unload(_adapter *padapt
 
 static int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
 {
-	int status = 0;
+	int status = -1;
 
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 
 	if (true == bnormal)
 	{
-		_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
-		status = _netdev_open(pnetdev);
-		_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
+		if (mutex_lock_interruptible(&(adapter_to_dvobj(padapter)->hw_init_mutex)) == 0) {
+			status = _netdev_open(pnetdev);
+			mutex_unlock(&(adapter_to_dvobj(padapter)->hw_init_mutex));
+		}
 	}	
 	else
 		status =  (_SUCCESS == ips_netdrv_open(padapter))?(0):(-1);
@@ -1360,18 +1315,12 @@ static int netdev_close(struct net_devic
 		rtw_free_assoc_resources(padapter, 1);
 		//s2-4.
 		rtw_free_network_queue(padapter,true);
-		// Close LED
-		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 	}
 
 	rtw_scan_abort(padapter);
 	adapter_wdev_data(padapter)->bandroid_scan = false;
 	//padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; //set this at the end
 
-#ifdef CONFIG_WAPI_SUPPORT
-	rtw_wapi_disable_tx(padapter);
-#endif
-
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
 	DBG_871X("-871x_drv - drv_close, bup=%d\n", padapter->bup);
 
@@ -1384,7 +1333,7 @@ void rtw_ndev_destructor(struct net_devi
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (ndev->ieee80211_ptr)
-		rtw_mfree((u8 *)ndev->ieee80211_ptr, sizeof(struct wireless_dev));
+		kfree((u8 *)ndev->ieee80211_ptr);
 
 	free_netdev(ndev);
 }
@@ -1494,13 +1443,11 @@ static int rtw_suspend_free_assoc_resour
 		//s2-2.  indicate disconnect to os
 		rtw_indicate_disconnect(padapter);
 	}
-	#ifdef CONFIG_AP_MODE
 	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE))	
 	{
 		rtw_sta_flush(padapter);
 	}
-	#endif
-		
+
 	//s2-3.
 	rtw_free_assoc_resources(padapter, 1);
 
@@ -1680,8 +1627,6 @@ static int rtw_suspend_normal(_adapter *
 
 	rtw_suspend_free_assoc_resource(padapter);
 
-	rtw_led_control(padapter, LED_CTL_POWER_OFF);
-
 	if ((rtw_hal_check_ips_status(padapter) == true)
 		|| (adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))
 	{
@@ -1894,20 +1839,6 @@ _func_enter_;
 		}
 	}
 
-	if (pwrpriv->wowlan_wake_reason == FWDecisionDisconnect) {
-		rtw_lock_ext_suspend_timeout(2000);
-	}
-
-	if (pwrpriv->wowlan_wake_reason == Rx_GTK ||
-		pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
-		pwrpriv->wowlan_wake_reason == Rx_DeAuth) {
-		rtw_lock_ext_suspend_timeout(8000);
-	}
-
-	if (pwrpriv->wowlan_wake_reason == RX_PNOWakeUp) {
-		rtw_lock_ext_suspend_timeout(15000);
-	}
-
 	if (pwrpriv->wowlan_mode == true) {
 		pwrpriv->bips_processing = false;
 		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
@@ -1994,9 +1925,6 @@ _func_enter_;
 		rtw_signal_process(padapter->pid[1], SIGUSR2);
 	}	
 
-	if (pwrpriv->wowlan_wake_reason == AP_WakeUp)
-		rtw_lock_ext_suspend_timeout(8000);
-
 	pwrpriv->bips_processing = false;
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/recv_linux.c linux/3rdparty/rtl8723bs/os_dep/recv_linux.c
--- linux/3rdparty/rtl8723bs.old/os_dep/recv_linux.c	2015-05-10 14:36:05.741668714 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/recv_linux.c	2015-05-07 17:46:55.000000000 +0300
@@ -22,112 +22,16 @@
 #include <drv_types.h>
 #include <linux/jiffies.h>
 
-int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb)
-{
-	int res = _SUCCESS;
-	u8	shift_sz = 0;
-	u32	skb_len, alloc_sz;
-	_pkt	 *pkt_copy = NULL;	
-	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;
-
-
-	if(pdata == NULL)
-	{		
-		precvframe->u.hdr.pkt = NULL;
-		res = _FAIL;
-		return res;
-	}	
-
-
-	//	Modified by Albert 20101213
-	//	For 8 bytes IP header alignment.
-	shift_sz = pattrib->qos ? 6:0;//	Qos data, wireless lan header length is 26
-
-	skb_len = pattrib->pkt_len;
-
-	// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
-	// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-	if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0))
-	{
-		//alloc_sz = 1664;	//1664 is 128 alignment.
-		alloc_sz = (skb_len <= 1650) ? 1664:(skb_len + 14);		
-	}
-	else 
-	{
-		alloc_sz = skb_len;
-		//	6 is for IP header 8 bytes alignment in QoS packet case.
-		//	8 is for skb->data 4 bytes alignment.
-		alloc_sz += 14;
-	}	
-
-	pkt_copy = rtw_skb_alloc(alloc_sz);
-
-	if(pkt_copy)
-	{
-		pkt_copy->dev = padapter->pnetdev;
-		precvframe->u.hdr.pkt = pkt_copy;
-		precvframe->u.hdr.rx_head = pkt_copy->data;
-		precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-		skb_reserve(pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data) & 7 ));//force pkt_copy->data at 8-byte alignment address
-		skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
-		memcpy(pkt_copy->data, pdata, skb_len);
-		precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
-	}
-	else
-	{
-		if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0))
-		{				
-			DBG_871X("%s: alloc_skb fail , drop frag frame \n", __FUNCTION__);
-			//rtw_free_recvframe(precvframe, pfree_recv_queue);
-			res = _FAIL;
-			goto exit_rtw_os_recv_resource_alloc;
-		}
-
-		if(pskb == NULL)
-		{
-			res = _FAIL;
-			goto exit_rtw_os_recv_resource_alloc;
-		}
-			
-		precvframe->u.hdr.pkt = rtw_skb_clone(pskb);
-		if(precvframe->u.hdr.pkt)
-		{
-			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pdata;
-			precvframe->u.hdr.rx_end =  pdata + alloc_sz;
-		}
-		else
-		{
-			DBG_871X("%s: rtw_skb_clone fail\n", __FUNCTION__);
-			//rtw_free_recvframe(precvframe, pfree_recv_queue);
-			//goto _exit_recvbuf2recvframe;
-			res = _FAIL;
-		}
-	}		
-
-exit_rtw_os_recv_resource_alloc:
-
-	return res;
-
-}
-
 void rtw_os_free_recvframe(union recv_frame *precvframe)
 {
 	if(precvframe->u.hdr.pkt)
 	{
-		rtw_skb_free(precvframe->u.hdr.pkt);//free skb by driver
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);//free skb by driver
 
 		precvframe->u.hdr.pkt = NULL;
 	}
 }
 
-//init os related resource in struct recv_priv
-int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter)
-{
-	int	res=_SUCCESS;
-
-	return res;
-}
-
 //alloc os related resource in union recv_frame
 int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe)
 {
@@ -149,21 +53,13 @@ void rtw_os_recv_resource_free(struct re
 	{
 		if(precvframe->u.hdr.pkt)
 		{
-			rtw_skb_free(precvframe->u.hdr.pkt);//free skb by driver
+			dev_kfree_skb_any(precvframe->u.hdr.pkt);//free skb by driver
 			precvframe->u.hdr.pkt = NULL;
 		}
 		precvframe++;
 	}
 }
 
-//alloc os related resource in struct recv_buf
-int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf)
-{
-	int res=_SUCCESS;
-
-	return res;
-}
-
 //free os related resource in struct recv_buf
 int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
 {
@@ -171,7 +67,7 @@ int rtw_os_recvbuf_resource_free(_adapte
 
 	if(precvbuf->pskb)
 	{
-		rtw_skb_free(precvbuf->pskb);
+		dev_kfree_skb_any(precvbuf->pskb);
 	}
 	return ret;
 
@@ -366,10 +262,6 @@ void rtw_handle_tkip_mic_err(_adapter *p
 	wrqu.data.length = sizeof( ev );
 }
 
-void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame)
-{
-}
-
 #ifdef CONFIG_AUTO_AP_MODE
 static void rtw_os_ksocket_send(_adapter *padapter, union recv_frame *precv_frame)
 {	
@@ -424,14 +316,6 @@ _func_enter_;
 	precvpriv = &(padapter->recvpriv);
 	pfree_recv_queue = &(precvpriv->free_recv_queue);
 
-#ifdef CONFIG_WAPI_SUPPORT
-	if (rtw_wapi_check_for_drop(padapter,precv_frame))
-	{
-		WAPI_TRACE(WAPI_ERR, "%s(): Rx Reorder Drop case!!\n", __FUNCTION__);
-		goto _recv_indicatepkt_drop;
-	}
-#endif
-
 	skb = precv_frame->u.hdr.pkt;
 	if(skb == NULL)
 	{
@@ -485,24 +369,11 @@ _func_exit_;
 
 }
 
-void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
-{
-	struct recv_priv *precvpriv = &padapter->recvpriv;
-
-	precvbuf->pskb = NULL;
-}
-void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext);
-void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
-{
-	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
-	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
-}
-
 void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
 {
 	_adapter *padapter = preorder_ctrl->padapter;
 
-	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
 
 }
 
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/rtw_proc.c linux/3rdparty/rtl8723bs/os_dep/rtw_proc.c
--- linux/3rdparty/rtl8723bs.old/os_dep/rtw_proc.c	2015-05-10 14:36:05.742668725 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/rtw_proc.c	2015-05-07 17:46:55.000000000 +0300
@@ -25,12 +25,7 @@
 
 static struct proc_dir_entry *rtw_proc = NULL;
 
-inline struct proc_dir_entry *get_rtw_drv_proc(void)
-{
-	return rtw_proc;
-}
-
-#define RTW_PROC_NAME DRV_NAME
+#define RTW_PROC_NAME "rtl8723bs"
 
 #define get_proc_net init_net.proc_net
 
@@ -324,7 +319,7 @@ static ssize_t proc_set_cam(struct file
 		/* c <id>: clear specific cam entry */
 		/* wfc <id>: write specific cam entry from cam cache */
 
-		int num = sscanf(tmp, "%s %hhu", cmd, &id);
+		int num = sscanf(tmp, "%4s %hhu", cmd, &id);
 
 		if (num < 2)
 			return count;
@@ -399,11 +394,9 @@ static const struct rtw_proc_hdl adapter
 	{"suspend_info", proc_get_suspend_resume_info, NULL},
 	{"rx_info", proc_get_rx_info, proc_reset_rx_info},
 
-#ifdef CONFIG_LAYER2_ROAMING
 	{"roam_flags", proc_get_roam_flags, proc_set_roam_flags},
 	{"roam_param", proc_get_roam_param, proc_set_roam_param},
 	{"roam_tgt_addr", proc_get_dummy, proc_set_roam_tgt_addr},
-#endif /* CONFIG_LAYER2_ROAMING */
 
 	{"sd_f0_reg_dump", proc_get_sd_f0_reg_dump, NULL},
 
@@ -413,10 +406,8 @@ static const struct rtw_proc_hdl adapter
 	{"mac_reg_dump", proc_get_mac_reg_dump, NULL},
 	{"bb_reg_dump", proc_get_bb_reg_dump, NULL},
 	{"rf_reg_dump", proc_get_rf_reg_dump, NULL},
-	
-#ifdef CONFIG_AP_MODE
+
 	{"all_sta_info", proc_get_all_sta_info, NULL},
-#endif /* CONFIG_AP_MODE */
 
 	{"rx_signal", proc_get_rx_signal, proc_set_rx_signal},
 	{"hw_info", proc_get_hw_status, NULL},
@@ -716,7 +707,7 @@ static void rtw_odm_proc_deinit(_adapter
 
 struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev)
 {
-	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *drv_proc = rtw_proc;
 	struct proc_dir_entry *dir_dev = NULL;
 	struct proc_dir_entry *entry = NULL;
 	_adapter *adapter = rtw_netdev_priv(dev);
@@ -757,7 +748,7 @@ exit:
 
 void rtw_adapter_proc_deinit(struct net_device *dev)
 {
-	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *drv_proc = rtw_proc;
 	struct proc_dir_entry *dir_dev = NULL;
 	_adapter *adapter = rtw_netdev_priv(dev);
 	int i;
@@ -781,7 +772,7 @@ void rtw_adapter_proc_deinit(struct net_
 
 void rtw_adapter_proc_replace(struct net_device *dev)
 {
-	struct proc_dir_entry *drv_proc = get_rtw_drv_proc();
+	struct proc_dir_entry *drv_proc = rtw_proc;
 	struct proc_dir_entry *dir_dev = NULL;
 	_adapter *adapter = rtw_netdev_priv(dev);
 	int i;
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/rtw_proc.h linux/3rdparty/rtl8723bs/os_dep/rtw_proc.h
--- linux/3rdparty/rtl8723bs.old/os_dep/rtw_proc.h	2015-05-10 14:36:05.742668725 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/rtw_proc.h	2015-05-07 17:46:55.000000000 +0300
@@ -31,7 +31,6 @@ struct rtw_proc_hdl {
 
 #ifdef CONFIG_PROC_DEBUG
 
-struct proc_dir_entry *get_rtw_drv_proc(void);
 int rtw_drv_proc_init(void);
 void rtw_drv_proc_deinit(void);
 struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev);
@@ -40,7 +39,6 @@ void rtw_adapter_proc_replace(struct net
 
 #else //!CONFIG_PROC_DEBUG
 
-struct proc_dir_entry *get_rtw_drv_proc(void) {return NULL;}
 int rtw_drv_proc_init(void) {return 0;}
 void rtw_drv_proc_deinit(void) {}
 struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev){return NULL;}
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/sdio_intf.c linux/3rdparty/rtl8723bs/os_dep/sdio_intf.c
--- linux/3rdparty/rtl8723bs.old/os_dep/sdio_intf.c	2015-05-10 14:36:05.742668725 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/sdio_intf.c	2015-05-07 17:46:55.000000000 +0300
@@ -62,7 +62,7 @@ struct sdio_drv_priv {
 static struct sdio_drv_priv sdio_drvpriv = {
 	.r871xs_drv.probe = rtw_drv_init,
 	.r871xs_drv.remove = rtw_dev_remove,
-	.r871xs_drv.name = (char*)DRV_NAME,
+	.r871xs_drv.name = "rtl8723bs",
 	.r871xs_drv.id_table = sdio_ids,
 	.r871xs_drv.drv = {
 		.pm = &rtw_sdio_pm_ops,
@@ -349,7 +349,7 @@ static _adapter *rtw_sdio_if1_init(struc
 	struct net_device *pnetdev;
 	PADAPTER padapter = NULL;
 	
-	if ((padapter = (_adapter *)rtw_zvmalloc(sizeof(*padapter))) == NULL) {
+	if ((padapter = (_adapter *)vzalloc(sizeof(*padapter))) == NULL) {
 		goto exit;
 	}
 
@@ -427,7 +427,7 @@ static _adapter *rtw_sdio_if1_init(struc
 	
 free_hal_data:
 	if(status != _SUCCESS && padapter->HalData)
-		rtw_mfree(padapter->HalData, sizeof(padapter->HalData));
+		kfree(padapter->HalData);
 
 	if(status != _SUCCESS) {
 		rtw_wdev_unregister(padapter->rtw_wdev);
@@ -439,7 +439,7 @@ free_adapter:
 		if (pnetdev)
 			rtw_free_netdev(pnetdev);
 		else
-			rtw_vmfree((u8*)padapter, sizeof(*padapter));
+			vfree((u8*)padapter);
 		padapter = NULL;
 	}
 exit:
@@ -454,9 +454,7 @@ static void rtw_sdio_if1_deinit(_adapter
 	if(check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_disassoc_cmd(if1, 0, false);
 
-#ifdef CONFIG_AP_MODE
 	free_mlme_ap_info(if1);
-#endif
 
 #ifdef CONFIG_GPIO_WAKEUP
 	gpio_hostwakeup_free_irq(if1);
@@ -673,15 +671,11 @@ static int rtw_sdio_resume(struct device
 	{
 		if(pwrpriv->wowlan_mode || pwrpriv->wowlan_ap_mode)
 		{
-			rtw_resume_lock_suspend();			
 			ret = rtw_resume_process(padapter);
-			rtw_resume_unlock_suspend();
 		}
 		else
 		{
-			rtw_resume_lock_suspend();
 			ret = rtw_resume_process(padapter);
-			rtw_resume_unlock_suspend();
 		}
 	}
 	pmlmeext->last_scan_time = jiffies;
@@ -697,11 +691,10 @@ static int __init rtw_drv_entry(void)
 	DBG_871X_LEVEL(_drv_always_, "module init start\n");
 	dump_drv_version(RTW_DBGDUMP);
 #ifdef BTCOEXVERSION
-	DBG_871X_LEVEL(_drv_always_, DRV_NAME" BT-Coex version = %s\n", BTCOEXVERSION);
+	DBG_871X_LEVEL(_drv_always_, "rtl8723bs BT-Coex version = %s\n", BTCOEXVERSION);
 #endif // BTCOEXVERSION
 
 	sdio_drvpriv.drv_registered = true;
-	rtw_suspend_lock_init();
 	rtw_drv_proc_init();
 	rtw_ndev_notifier_register();
 
@@ -709,7 +702,6 @@ static int __init rtw_drv_entry(void)
 	if (ret != 0)
 	{
 		sdio_drvpriv.drv_registered = false;
-		rtw_suspend_lock_uninit();
 		rtw_drv_proc_deinit();
 		rtw_ndev_notifier_unregister();
 		DBG_871X("%s: register driver failed!!(%d)\n", __FUNCTION__, ret);
@@ -731,7 +723,6 @@ static void __exit rtw_drv_halt(void)
 
 	sdio_unregister_driver(&sdio_drvpriv.r871xs_drv);
 
-	rtw_suspend_lock_uninit();
 	rtw_drv_proc_deinit();
 	rtw_ndev_notifier_unregister();
 
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/sdio_ops_linux.c linux/3rdparty/rtl8723bs/os_dep/sdio_ops_linux.c
--- linux/3rdparty/rtl8723bs.old/os_dep/sdio_ops_linux.c	2015-05-10 14:36:05.743668736 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/sdio_ops_linux.c	2015-05-07 17:46:55.000000000 +0300
@@ -74,39 +74,6 @@ _func_exit_;
 	return v;
 }
 
-void sd_f0_write8(struct intf_hdl *pintfhdl, u32 addr, u8 v, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-	
-	struct sdio_func *func;
-	bool claim_needed;
-	
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return;
-	}	
-	
-	func = psdio->func;
-	claim_needed = rtw_sdio_claim_host_needed(func);
-
-	if (claim_needed)
-		sdio_claim_host(func);
-	sdio_f0_writeb(func, v, addr, err);
-	if (claim_needed)
-		sdio_release_host(func);
-	if (err && *err)
-		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%02x\n", __func__, *err, addr, v);
-
-_func_exit_;
-}
-
 /*
  * Return:
  *	0		Success
@@ -263,37 +230,6 @@ _func_exit_;
 	return err;
 }
 
-u8 _sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-
-	u8 v=0;
-	struct sdio_func *func;
-
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return v;
-	}
-	
-	func = psdio->func;
-
-	v = sdio_readb(func, addr, err);
-
-	if (err && *err)
-		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
-
-_func_exit_;
-
-	return v;
-}
-
 u8 sd_read8(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
 {
 	PADAPTER padapter;
@@ -330,108 +266,6 @@ _func_exit_;
 	return v;
 }
 
-u16 sd_read16(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-	
-	u16 v=0;
-	struct sdio_func *func;
-	bool claim_needed;
-
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return v;
-	}
-		
-	func = psdio->func;
-	claim_needed = rtw_sdio_claim_host_needed(func);
-
-	if (claim_needed)
-		sdio_claim_host(func);
-	v = sdio_readw(func, addr, err);
-	if (claim_needed)
-		sdio_release_host(func);
-	if (err && *err)
-		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x\n", __func__, *err, addr);
-
-_func_exit_;
-
-	return  v;
-}
-
-u32 _sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-	
-	u32 v=0;
-	struct sdio_func *func;
-
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return v;
-	}
-		
-	func = psdio->func;
-
-	v = sdio_readl(func, addr, err);
-
-	if (err && *err)
-	{
-		int i;
-
-		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x\n", __func__, *err, addr, v);
-
-		*err = 0;
-		for(i=0; i<SD_IO_TRY_CNT; i++)
-		{
-			//sdio_claim_host(func);
-			v = sdio_readl(func, addr, err);
-			//sdio_release_host(func);
-			if (*err == 0){
-				rtw_reset_continual_io_error(psdiodev);
-				break;
-			}
-			else{
-				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
-				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err))
-				{			
-					padapter->bSurpriseRemoved = true;
-				}
-
-				if(rtw_inc_and_chk_continual_io_error(psdiodev) == true ){
-					padapter->bSurpriseRemoved = true;
-					break;
-				}						
-					
-			}
-		}
-
-		if (i==SD_IO_TRY_CNT)
-			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
-		else
-			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
-
-	}
-
-_func_exit_;
-
-	return  v;
-}
-
 u32 sd_read32(struct intf_hdl *pintfhdl, u32 addr, s32 *err)
 {
 	PADAPTER padapter;
@@ -535,97 +369,6 @@ _func_enter_;
 
 _func_exit_;
 }
-
-void sd_write16(struct intf_hdl *pintfhdl, u32 addr, u16 v, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-	
-	struct sdio_func *func;
-	bool claim_needed;
-
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return ;
-	}
-	
-	func = psdio->func;
-	claim_needed = rtw_sdio_claim_host_needed(func);
-
-	if (claim_needed)
-		sdio_claim_host(func);
-	sdio_writew(func, v, addr, err);
-	if (claim_needed)
-		sdio_release_host(func);
-	if (err && *err)
-		DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%04x\n", __func__, *err, addr, v);
-
-_func_exit_;
-}
-
-void _sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err)
-{
-	PADAPTER padapter;
-	struct dvobj_priv *psdiodev;
-	PSDIO_DATA psdio;
-	
-	struct sdio_func *func;
-
-_func_enter_;
-	padapter = pintfhdl->padapter;
-	psdiodev = pintfhdl->pintf_dev;
-	psdio = &psdiodev->intf_data;
-
-	if(padapter->bSurpriseRemoved){
-		//DBG_871X(" %s (padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n",__FUNCTION__);
-		return ;
-	}
-	
-	func = psdio->func;
-
-	sdio_writel(func, v, addr, err);
-
-	if (err && *err)
-	{
-		int i;
-
-		DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x\n", __func__, *err, addr, v);
-
-		*err = 0;
-		for(i=0; i<SD_IO_TRY_CNT; i++)
-		{
-			sdio_writel(func, v, addr, err);
-			if (*err == 0){
-				rtw_reset_continual_io_error(psdiodev);
-				break;
-			}else{				
-				DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x, val=0x%x, try_cnt=%d\n", __func__, *err, addr, v, i);
-				if(( -ESHUTDOWN == *err ) || ( -ENODEV == *err)){			
-					padapter->bSurpriseRemoved = true;
-				}
-
-				if(rtw_inc_and_chk_continual_io_error(psdiodev) == true ){
-					padapter->bSurpriseRemoved = true;
-					break;
-				}
-			}
-		}
-
-		if (i==SD_IO_TRY_CNT)
-			DBG_871X(KERN_ERR "%s: FAIL!(%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
-		else
-			DBG_871X(KERN_ERR "%s: (%d) addr=0x%05x val=0x%08x, try_cnt=%d\n", __func__, *err, addr, v, i);
-
-	}
-
-_func_exit_;
-}
 
 void sd_write32(struct intf_hdl *pintfhdl, u32 addr, u32 v, s32 *err)
 {
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/wifi_regd.c linux/3rdparty/rtl8723bs/os_dep/wifi_regd.c
--- linux/3rdparty/rtl8723bs.old/os_dep/wifi_regd.c	2015-05-10 14:36:05.743668736 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/wifi_regd.c	2015-05-07 17:46:55.000000000 +0300
@@ -164,48 +164,12 @@ static void _rtw_reg_apply_flags(struct
 	}
 }
 
-static void _rtw_reg_apply_world_flags(struct wiphy *wiphy,
-				       enum nl80211_reg_initiator initiator,
-				       struct rtw_regulatory *reg)
-{
-	//_rtw_reg_apply_beaconing_flags(wiphy, initiator);
-	//_rtw_reg_apply_active_scan_flags(wiphy, initiator);
-	return;
-}
-
 static int _rtw_reg_notifier_apply(struct wiphy *wiphy,
 				   struct regulatory_request *request,
 				   struct rtw_regulatory *reg)
 {
-
 	/* Hard code flags */
 	_rtw_reg_apply_flags(wiphy);
-
-	switch (request->initiator) {
-	case NL80211_REGDOM_SET_BY_DRIVER:
-		DBG_8192C("%s: %s\n", __func__, "NL80211_REGDOM_SET_BY_DRIVER");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_CORE:
-		DBG_8192C("%s: %s\n", __func__,
-			  "NL80211_REGDOM_SET_BY_CORE to DRV");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_USER:
-		DBG_8192C("%s: %s\n", __func__,
-			  "NL80211_REGDOM_SET_BY_USER to DRV");
-		_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER,
-					   reg);
-		break;
-	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
-		DBG_8192C("%s: %s\n", __func__,
-			  "NL80211_REGDOM_SET_BY_COUNTRY_IE");
-		_rtw_reg_apply_world_flags(wiphy, request->initiator, reg);
-		break;
-	}
-
 	return 0;
 }
 
@@ -235,7 +199,6 @@ static void _rtw_regd_init_wiphy(struct
 
 	/* Hard code flags */
 	_rtw_reg_apply_flags(wiphy);
-	_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
 }
 
 int rtw_regd_init(_adapter * padapter,
diff -Nurp linux/3rdparty/rtl8723bs.old/os_dep/xmit_linux.c linux/3rdparty/rtl8723bs/os_dep/xmit_linux.c
--- linux/3rdparty/rtl8723bs.old/os_dep/xmit_linux.c	2015-05-10 14:36:05.743668736 +0300
+++ linux/3rdparty/rtl8723bs/os_dep/xmit_linux.c	2015-05-07 17:46:55.000000000 +0300
@@ -98,7 +98,7 @@ void rtw_os_xmit_resource_free(_adapter
 {
 	if (free_sz > 0 ) {
 		if(pxmitbuf->pallocated_buf)
-			rtw_mfree(pxmitbuf->pallocated_buf, free_sz);
+			kfree(pxmitbuf->pallocated_buf);
 	}
 }
 
@@ -121,7 +121,7 @@ void rtw_os_pkt_complete(_adapter *padap
 			netif_wake_subqueue(padapter->pnetdev, queue);
 	}
 
-	rtw_skb_free(pkt);
+	dev_kfree_skb_any(pkt);
 }
 
 void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe)
@@ -139,7 +139,7 @@ void rtw_os_xmit_schedule(_adapter *pada
 	if(!padapter)
 		return;
 
-	if (_rtw_queue_empty(&padapter->xmitpriv.pending_xmitbuf_queue) == false)
+	if (!list_empty(&padapter->xmitpriv.pending_xmitbuf_queue.queue))
 		up(&pri_adapter->xmitpriv.xmit_sema);
 }
 
@@ -163,7 +163,6 @@ static void rtw_check_xmit_resource(_ada
 	}
 }
 
-#ifdef CONFIG_TX_MCAST2UNI
 static int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 {
 	struct	sta_priv *pstapriv = &padapter->stapriv;
@@ -182,12 +181,12 @@ static int rtw_mlcst2unicst(_adapter *pa
 
 	DBG_COUNTER(padapter->tx_logs.os_tx_m2u);
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 	
 	//free sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+	while (phead != plist) {
 		int stainfo_offset;
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
@@ -197,7 +196,7 @@ static int rtw_mlcst2unicst(_adapter *pa
 			chk_alive_list[chk_alive_num++] = stainfo_offset;
 		}
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	for (i = 0; i < chk_alive_num; i++) {
 		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
@@ -228,31 +227,27 @@ static int rtw_mlcst2unicst(_adapter *pa
 				DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_xmit);
 				DBG_871X("%s()-%d: rtw_xmit() return error!\n", __FUNCTION__, __LINE__);
 				pxmitpriv->tx_drop++;
-				rtw_skb_free(newskb);
+				dev_kfree_skb_any(newskb);
 			}
 		} else {
 			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_skb);
 			DBG_871X("%s-%d: rtw_skb_copy() failed!\n", __FUNCTION__, __LINE__);
 			pxmitpriv->tx_drop++;
-			//rtw_skb_free(skb);
+			//dev_kfree_skb_any(skb);
 			return false;	// Caller shall tx this multicast frame via normal way.
 		}
 	}
 
-	rtw_skb_free(skb);
+	dev_kfree_skb_any(skb);
 	return true;
 }
-#endif	// CONFIG_TX_MCAST2UNI
-
 
 int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-#ifdef CONFIG_TX_MCAST2UNI
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	extern int rtw_mc2u_disable;
-#endif	// CONFIG_TX_MCAST2UNI	
 	s32 res = 0;
 	u16 queue;
 
@@ -277,7 +272,6 @@ _func_enter_;
 
 	rtw_check_xmit_resource(padapter, pkt);
 
-#ifdef CONFIG_TX_MCAST2UNI
 	if ( !rtw_mc2u_disable
 		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& ( IP_MCAST_MAC(pkt->data)
@@ -299,8 +293,7 @@ _func_enter_;
 			//DBG_871X("!m2u );
 			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_stop);
 		}
-	}	
-#endif	// CONFIG_TX_MCAST2UNI	
+	}
 
 	res = rtw_xmit(padapter, &pkt);
 	if (res < 0) {
@@ -315,7 +308,7 @@ _func_enter_;
 
 drop_packet:
 	pxmitpriv->tx_drop++;
-	rtw_skb_free(pkt);
+	dev_kfree_skb_any(pkt);
 	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));
 
 exit:
