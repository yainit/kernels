diff -uNr linux-3.16.7-dxen/arch/x86/Makefile linux-3.16.7/arch/x86/Makefile
--- linux-3.16.7-dxen/arch/x86/Makefile	2014-08-03 22:25:02.000000000 +0000
+++ linux-3.16.7/arch/x86/Makefile	2015-04-19 20:52:58.162897542 +0000
@@ -217,8 +217,29 @@
 
 BOOT_TARGETS = bzlilo bzdisk fdimage fdimage144 fdimage288 isoimage
 
-PHONY += bzImage $(BOOT_TARGETS)
+PHONY += bzImage vmlinuz $(BOOT_TARGETS)
 
+ifdef CONFIG_XEN
+LINUXINCLUDE := -D__XEN_INTERFACE_VERSION__=$(CONFIG_XEN_INTERFACE_VERSION) \
+	-I$(srctree)/arch/x86/include/mach-xen $(LINUXINCLUDE)
+
+ifdef CONFIG_X86_64
+LDFLAGS_vmlinux := -e startup_64
+endif
+endif
+
+ifeq ($(CONFIG_XEN)-$(CONFIG_XEN_BZIMAGE),y-)
+# Default kernel to build
+all: vmlinuz
+
+# KBUILD_IMAGE specifies the target image being built
+KBUILD_IMAGE := $(boot)/vmlinuz
+
+vmlinuz: vmlinux
+	$(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)
+	$(Q)mkdir -p $(objtree)/arch/$(UTS_MACHINE)/boot
+	$(Q)ln -fsn ../../x86/boot/$@ $(objtree)/arch/$(UTS_MACHINE)/boot/$@
+else
 # Default kernel to build
 all: bzImage
 
@@ -232,6 +253,7 @@
 	$(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)
 	$(Q)mkdir -p $(objtree)/arch/$(UTS_MACHINE)/boot
 	$(Q)ln -fsn ../../x86/boot/bzImage $(objtree)/arch/$(UTS_MACHINE)/boot/$@
+endif
 
 $(BOOT_TARGETS): vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $@
diff -uNr linux-3.16.7-dxen/arch/x86/include/mach-xen/asm/dma-mapping.h linux-3.16.7/arch/x86/include/mach-xen/asm/dma-mapping.h
--- linux-3.16.7-dxen/arch/x86/include/mach-xen/asm/dma-mapping.h	2015-04-19 20:50:02.757883399 +0000
+++ linux-3.16.7/arch/x86/include/mach-xen/asm/dma-mapping.h	2015-04-19 20:52:58.171897543 +0000
@@ -8,6 +8,11 @@
 #undef phys_to_dma
 #undef dma_to_phys
 
+#ifndef _LINUX_DMA_MAPPING_H
+# error Must include linux/dma-mapping.h instead!
+#endif
+#define ARCH_HAS_DMA_GET_REQUIRED_MASK
+
 static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
 	return phys_to_machine(paddr);
diff -uNr linux-3.16.7-dxen/arch/x86/include/mach-xen/asm/hypercall.h linux-3.16.7/arch/x86/include/mach-xen/asm/hypercall.h
--- linux-3.16.7-dxen/arch/x86/include/mach-xen/asm/hypercall.h	2015-04-19 20:50:02.758883399 +0000
+++ linux-3.16.7/arch/x86/include/mach-xen/asm/hypercall.h	2015-04-19 20:52:58.172897543 +0000
@@ -160,6 +160,11 @@
 	__res;							\
 })
 
+#if CONFIG_XEN_COMPAT <= 0x030002
+int __must_check HYPERVISOR_event_channel_op_compat(int, void *);
+int __must_check HYPERVISOR_physdev_op_compat(int, void *);
+#endif
+
 #ifdef CONFIG_X86_32
 # include "hypercall_32.h"
 #else
@@ -262,13 +267,13 @@
 	return _hypercall1(unsigned long, get_debugreg, reg);
 }
 
-static inline int __must_check
+static inline long __must_check
 HYPERVISOR_memory_op(
 	unsigned int cmd, void *arg)
 {
 	if (arch_use_lazy_mmu_mode())
 		xen_multicall_flush();
-	return _hypercall2(int, memory_op, cmd, arg);
+	return _hypercall2(long, memory_op, cmd, arg);
 }
 
 static inline int __must_check
@@ -285,13 +290,8 @@
 	int rc = _hypercall2(int, event_channel_op, cmd, arg);
 
 #if CONFIG_XEN_COMPAT <= 0x030002
-	if (unlikely(rc == -ENOSYS)) {
-		struct evtchn_op op;
-		op.cmd = cmd;
-		memcpy(&op.u, arg, sizeof(op.u));
-		rc = _hypercall1(int, event_channel_op_compat, &op);
-		memcpy(arg, &op.u, sizeof(op.u));
-	}
+	if (unlikely(rc == -ENOSYS))
+		rc = HYPERVISOR_event_channel_op_compat(cmd, arg);
 #endif
 
 	return rc;
@@ -318,13 +318,8 @@
 	int rc = _hypercall2(int, physdev_op, cmd, arg);
 
 #if CONFIG_XEN_COMPAT <= 0x030002
-	if (unlikely(rc == -ENOSYS)) {
-		struct physdev_op op;
-		op.cmd = cmd;
-		memcpy(&op.u, arg, sizeof(op.u));
-		rc = _hypercall1(int, physdev_op_compat, &op);
-		memcpy(arg, &op.u, sizeof(op.u));
-	}
+	if (unlikely(rc == -ENOSYS))
+		rc = HYPERVISOR_physdev_op_compat(cmd, arg);
 #endif
 
 	return rc;
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/cpu/common-xen.c linux-3.16.7/arch/x86/kernel/cpu/common-xen.c
--- linux-3.16.7-dxen/arch/x86/kernel/cpu/common-xen.c	2015-04-19 20:50:02.773883400 +0000
+++ linux-3.16.7/arch/x86/kernel/cpu/common-xen.c	2015-04-19 20:52:58.186897544 +0000
@@ -1020,7 +1020,7 @@
 }
 
 /* May not be __init: called during resume */
-void syscall32_cpu_init(void)
+static void syscall32_cpu_init(void)
 {
 	static const struct callback_register cstar = {
 		.type = CALLBACKTYPE_syscall32,
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/cpu/mcheck/mce_dom0.c linux-3.16.7/arch/x86/kernel/cpu/mcheck/mce_dom0.c
--- linux-3.16.7-dxen/arch/x86/kernel/cpu/mcheck/mce_dom0.c	2015-04-19 20:50:02.775883400 +0000
+++ linux-3.16.7/arch/x86/kernel/cpu/mcheck/mce_dom0.c	2015-04-19 20:52:58.187897544 +0000
@@ -55,8 +55,8 @@
 			m.addr = mc_bank->mc_addr;
 			m.tsc = mc_bank->mc_tsc;
 			m.bank = mc_bank->mc_bank;
-			printk(KERN_DEBUG "[CPU%d, BANK%d, addr %llx, state %llx]\n", 
-						m.bank, m.cpu, m.addr, m.status);
+			printk(KERN_DEBUG "[CPU %d bank %d addr %Lx state %Lx]\n",
+			       m.cpu, m.bank, m.addr, m.status);
 			/*log this record*/
 			mce_log(&m);
 		}
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/entry_64-xen.S linux-3.16.7/arch/x86/kernel/entry_64-xen.S
--- linux-3.16.7-dxen/arch/x86/kernel/entry_64-xen.S	2015-04-19 20:50:02.850883406 +0000
+++ linux-3.16.7/arch/x86/kernel/entry_64-xen.S	2015-04-19 20:52:58.192897545 +0000
@@ -792,37 +792,6 @@
 	CFI_ENDPROC
 END(retint_check)
 
-	/*
-	 * If IRET takes a fault on the espfix stack, then we
-	 * end up promoting it to a doublefault.  In that case,
-	 * modify the stack to make it look like we just entered
-	 * the #GP handler from user space, similar to bad_iret.
-	 */
-#ifdef CONFIG_X86_ESPFIX64
-	ALIGN
-__do_double_fault:
-	XCPT_FRAME 1 RDI+8
-	movq RSP(%rdi),%rax		/* Trap on the espfix stack? */
-	sarq $PGDIR_SHIFT,%rax
-	cmpl $ESPFIX_PGD_ENTRY,%eax
-	jne do_double_fault		/* No, just deliver the fault */
-	cmpl $__KERNEL_CS,CS(%rdi)
-	jne do_double_fault
-	movq RIP(%rdi),%rax
-	cmpq $native_irq_return_iret,%rax
-	jne do_double_fault		/* This shouldn't happen... */
-	movq PER_CPU_VAR(kernel_stack),%rax
-	subq $(6*8-KERNEL_STACK_OFFSET),%rax	/* Reset to original stack */
-	movq %rax,RSP(%rdi)
-	movq $0,(%rax)			/* Missing (lost) #GP error code */
-	movq $general_protection,RIP(%rdi)
-	retq
-	CFI_ENDPROC
-END(__do_double_fault)
-#else
-# define __do_double_fault do_double_fault
-#endif
-
 /*
  * Exception entry points.
  */
@@ -947,7 +916,7 @@
 	jz   error_exit
 	cmpl $0,PER_CPU_VAR(__preempt_count)
 	jnz  error_exit
-	bt   $9,EFLAGS-ARGOFFSET(%rsp)
+	bt   $9,EFLAGS(%rsp)
 	jnc  error_exit
 	movb $0,PER_CPU_VAR(privcmd_hcall)
 	call preempt_schedule_irq
@@ -1211,17 +1180,16 @@
 #ifndef CONFIG_XEN
 /*
  * There are two places in the kernel that can potentially fault with
- * usergs. Handle them here. The exception handlers after iret run with
- * kernel gs again, so don't set the user space flag. B stepping K8s
- * sometimes report an truncated RIP for IRET exceptions returning to
- * compat mode. Check for these here too.
+ * usergs. Handle them here.  B stepping K8s sometimes report a
+ * truncated RIP for IRET exceptions returning to compat mode. Check
+ * for these here too.
  */
 error_kernelspace:
 	CFI_REL_OFFSET rcx, RCX+8
 	incl %ebx
 	leaq native_irq_return_iret(%rip),%rcx
 	cmpq %rcx,RIP+8(%rsp)
-	je error_swapgs
+	je error_bad_iret
 	movl %ecx,%eax	/* zero extend */
 	cmpq %rax,RIP+8(%rsp)
 	je bstep_iret
@@ -1232,7 +1200,15 @@
 bstep_iret:
 	/* Fix truncated RIP */
 	movq %rcx,RIP+8(%rsp)
-	jmp error_swapgs
+	/* fall through */
+
+error_bad_iret:
+	SWAPGS
+	mov %rsp,%rdi
+	call fixup_bad_iret
+	mov %rax,%rsp
+	decl %ebx	/* Return to usergs */
+	jmp error_sti
 #endif
 	CFI_ENDPROC
 END(error_entry)
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/pci-dma-xen.c linux-3.16.7/arch/x86/kernel/pci-dma-xen.c
--- linux-3.16.7-dxen/arch/x86/kernel/pci-dma-xen.c	2015-04-19 20:50:02.856883407 +0000
+++ linux-3.16.7/arch/x86/kernel/pci-dma-xen.c	2015-04-19 20:52:58.197897545 +0000
@@ -6,6 +6,8 @@
 #include <linux/pci.h>
 #include <linux/kmemleak.h>
 
+#include <xen/interface/memory.h>
+
 #include <asm/proto.h>
 #include <asm/dma.h>
 #include <asm/iommu.h>
@@ -266,6 +268,15 @@
 }
 early_param("iommu", iommu_setup);
 
+u64 dma_get_required_mask(struct device *dev)
+{
+	unsigned long max_mfn = HYPERVISOR_memory_op(XENMEM_maximum_ram_page,
+						     NULL);
+
+	return DMA_BIT_MASK(__fls(max_mfn - 1) + 1 + PAGE_SHIFT);
+}
+EXPORT_SYMBOL_GPL(dma_get_required_mask);
+
 static int check_pages_physically_contiguous(unsigned long pfn,
 					     unsigned int offset,
 					     size_t length)
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/process_64-xen.c linux-3.16.7/arch/x86/kernel/process_64-xen.c
--- linux-3.16.7-dxen/arch/x86/kernel/process_64-xen.c	2015-04-19 20:50:02.858883407 +0000
+++ linux-3.16.7/arch/x86/kernel/process_64-xen.c	2015-04-19 20:52:58.199897545 +0000
@@ -304,17 +304,15 @@
 
 	fpu = xen_switch_fpu_prepare(prev_p, next_p, cpu, &mcl);
 
-	/*
-	 * Reload sp0.
-	 * This is load_sp0(tss, next) with a multicall.
-	 */
+	/* Reload sp0. This is load_sp0(tss, next) with a multicall. */
 	mcl->op      = __HYPERVISOR_stack_switch;
 	mcl->args[0] = __KERNEL_DS;
 	mcl->args[1] = next->sp0;
 	mcl++;
 
 	/*
-	 * Load the per-thread Thread-Local Storage descriptor.
+	 * Load TLS before restoring any segments so that segment loads
+	 * reference the correct GDT entries.
 	 * This is load_TLS(next, cpu) with multicalls.
 	 */
 #define C(i) do {							\
@@ -379,9 +377,19 @@
 		xen_clear_cr0_upd();
 	}
 
-	/*
-	 * Switch DS and ES.
-	 * This won't pick up thread selector changes, but I guess that is ok.
+	/* Switch DS and ES.
+	 *
+	 * Reading them only returns the selectors, but writing them (if
+	 * nonzero) loads the full descriptor from the GDT or LDT.  The
+	 * LDT for next is loaded in switch_mm, and the GDT is loaded
+	 * above.
+	 *
+	 * We therefore need to write new values to the segment
+	 * registers on every context switch unless both the new and old
+	 * values are zero.
+	 *
+	 * Note that we don't need to do anything for CS and SS, as
+	 * those are saved and restored as part of pt_regs.
 	 */
 	if (unlikely(next->es))
 		loadsegment(es, next->es);
@@ -390,20 +398,48 @@
 		loadsegment(ds, next->ds);
 
 	/*
-	 * Leave lazy mode, flushing any hypercalls made here.
-	 * This must be done before restoring TLS segments so
-	 * the GDT and LDT are properly updated, and must be
-	 * done before math_state_restore, so the TS bit is up
-	 * to date.
+	 * Leave lazy mode, flushing any hypercalls made here.  This
+	 * must be done after loading TLS entries in the GDT but before
+	 * loading segments that might reference them, and and it must
+	 * be done before math_state_restore, so the TS bit is up to
+	 * date.
 	 */
 	arch_end_context_switch(next_p);
 
 	/*
 	 * Switch FS and GS.
 	 *
-	 * Segment register != 0 always requires a reload.  Also
-	 * reload when it has changed.  When prev process used 64bit
-	 * base always reload to avoid an information leak.
+	 * These are even more complicated than FS and GS: they have
+	 * 64-bit bases are that controlled by arch_prctl.  Those bases
+	 * only differ from the values in the GDT or LDT if the selector
+	 * is 0.
+	 *
+	 * Loading the segment register resets the hidden base part of
+	 * the register to 0 or the value from the GDT / LDT.  If the
+	 * next base address zero, writing 0 to the segment register is
+	 * much faster than using wrmsr to explicitly zero the base.
+	 *
+	 * The thread_struct.fs and thread_struct.gs values are 0
+	 * if the fs and gs bases respectively are not overridden
+	 * from the values implied by fsindex and gsindex.  They
+	 * are nonzero, and store the nonzero base addresses, if
+	 * the bases are overridden.
+	 *
+	 * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should
+	 * be impossible.
+	 *
+	 * Therefore we need to reload the segment registers if either
+	 * the old or new selector is nonzero, and we need to override
+	 * the base address if next thread expects it to be overridden.
+	 *
+	 * This code is unnecessarily slow in the case where the old and
+	 * new indexes are zero and the new base is nonzero -- it will
+	 * unnecessarily write 0 to the selector before writing the new
+	 * base address.
+	 *
+	 * Note: This all depends on arch_prctl being the only way that
+	 * user code can override the segment base.  Once wrfsbase and
+	 * wrgsbase are enabled, most of this code will need to change.
 	 */
 	if (unlikely(next->fsindex))
 		loadsegment(fs, next->fsindex);
diff -uNr linux-3.16.7-dxen/arch/x86/kernel/traps-xen.c linux-3.16.7/arch/x86/kernel/traps-xen.c
--- linux-3.16.7-dxen/arch/x86/kernel/traps-xen.c	2015-04-19 20:50:02.862883407 +0000
+++ linux-3.16.7/arch/x86/kernel/traps-xen.c	2015-04-19 20:52:58.202897545 +0000
@@ -239,32 +239,40 @@
 DO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  "coprocessor segment overrun",coprocessor_segment_overrun)
 DO_ERROR(X86_TRAP_TS,     SIGSEGV, "invalid TSS",		invalid_TSS)
 DO_ERROR(X86_TRAP_NP,     SIGBUS,  "segment not present",	segment_not_present)
-#ifdef CONFIG_X86_32
 DO_ERROR(X86_TRAP_SS,     SIGBUS,  "stack segment",		stack_segment)
-#endif
 DO_ERROR(X86_TRAP_AC,     SIGBUS,  "alignment check",		alignment_check)
 
 #ifdef CONFIG_X86_64
 /* Runs on IST stack */
-dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)
-{
-	enum ctx_state prev_state;
-
-	prev_state = exception_enter();
-	if (notify_die(DIE_TRAP, "stack segment", regs, error_code,
-		       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {
-		preempt_conditional_sti(regs);
-		do_trap(X86_TRAP_SS, SIGBUS, "stack segment", regs, error_code, NULL);
-		preempt_conditional_cli(regs);
-	}
-	exception_exit(prev_state);
-}
-
 dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
 {
 	static const char str[] = "double fault";
 	struct task_struct *tsk = current;
 
+#ifdef CONFIG_X86_ESPFIX64
+	extern unsigned char native_irq_return_iret[];
+
+	/*
+	 * If IRET takes a non-IST fault on the espfix64 stack, then we
+	 * end up promoting it to a doublefault.  In that case, modify
+	 * the stack to make it look like we just entered the #GP
+	 * handler from user space, similar to bad_iret.
+	 */
+	if (((long)regs->sp >> PGDIR_SHIFT) == ESPFIX_PGD_ENTRY &&
+		regs->cs == __KERNEL_CS &&
+		regs->ip == (unsigned long)native_irq_return_iret)
+	{
+		struct pt_regs *normal_regs = task_pt_regs(current);
+
+		/* Fake a #GP(0) from userspace. */
+		memmove(&normal_regs->ip, (void *)regs->sp, 5*8);
+		normal_regs->orig_ax = 0;  /* Missing (lost) #GP error code */
+		regs->ip = (unsigned long)general_protection;
+		regs->sp = (unsigned long)&normal_regs->orig_ax;
+		return;
+	}
+#endif
+
 	exception_enter();
 	/* Return not checked because double check cannot be ignored */
 	notify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_DF, SIGSEGV);
@@ -405,6 +413,35 @@
 	return regs;
 }
 NOKPROBE_SYMBOL(sync_regs);
+
+struct bad_iret_stack {
+	void *error_entry_ret;
+	struct pt_regs regs;
+};
+
+asmlinkage __visible
+struct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s)
+{
+	/*
+	 * This is called from entry_64.S early in handling a fault
+	 * caused by a bad iret to user mode.  To handle the fault
+	 * correctly, we want move our stack frame to task_pt_regs
+	 * and we want to pretend that the exception came from the
+	 * iret target.
+	 */
+	struct bad_iret_stack *new_stack =
+		container_of(task_pt_regs(current),
+			     struct bad_iret_stack, regs);
+
+	/* Copy the IRET target to the new stack. */
+	memmove(&new_stack->regs.ip, (void *)s->regs.sp, 5*8);
+
+	/* Copy the remainder of the stack from the current stack. */
+	memmove(new_stack, s, offsetof(struct bad_iret_stack, regs.ip));
+
+	BUG_ON(!user_mode_vm(&new_stack->regs));
+	return new_stack;
+}
 #endif
 
 /*
diff -uNr linux-3.16.7-dxen/arch/x86/platform/efi/efi-bgrt.c linux-3.16.7/arch/x86/platform/efi/efi-bgrt.c
--- linux-3.16.7-dxen/arch/x86/platform/efi/efi-bgrt.c	2014-08-03 22:25:02.000000000 +0000
+++ linux-3.16.7/arch/x86/platform/efi/efi-bgrt.c	2015-04-19 20:52:58.213897546 +0000
@@ -16,6 +16,11 @@
 #include <linux/efi.h>
 #include <linux/efi-bgrt.h>
 
+#ifdef CONFIG_XEN
+#define early_memremap early_ioremap
+#define early_memunmap early_iounmap
+#endif
+
 struct acpi_table_bgrt *bgrt_tab;
 void *__initdata bgrt_image;
 size_t __initdata bgrt_image_size;
diff -uNr linux-3.16.7-dxen/drivers/Makefile linux-3.16.7/drivers/Makefile
--- linux-3.16.7-dxen/drivers/Makefile	2015-04-19 20:50:02.876883408 +0000
+++ linux-3.16.7/drivers/Makefile	2015-04-19 20:52:58.215897546 +0000
@@ -63,6 +63,7 @@
 obj-y				+= base/ block/ misc/ mfd/ nfc/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-y				+= macintosh/
+obj-$(CONFIG_XEN)		+= xen/
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
diff -uNr linux-3.16.7-dxen/drivers/pci/msi-xen.c linux-3.16.7/drivers/pci/msi-xen.c
--- linux-3.16.7-dxen/drivers/pci/msi-xen.c	2015-04-19 20:50:04.464883536 +0000
+++ linux-3.16.7/drivers/pci/msi-xen.c	2015-04-19 20:52:58.245897549 +0000
@@ -226,7 +226,9 @@
 	bar = reg & PCI_MSIX_PBA_BIR;
 
 	flags = pci_resource_flags(dev, bar);
-	if (flags & (IORESOURCE_DISABLED | IORESOURCE_UNSET | IORESOURCE_BUSY))
+	if (!flags ||
+	     (flags & (IORESOURCE_DISABLED | IORESOURCE_UNSET |
+		       IORESOURCE_BUSY)))
 		return 0;
 
 	return pci_resource_start(dev, bar);
diff -uNr linux-3.16.7-dxen/drivers/powercap/Kconfig linux-3.16.7/drivers/powercap/Kconfig
--- linux-3.16.7-dxen/drivers/powercap/Kconfig	2014-08-03 22:25:02.000000000 +0000
+++ linux-3.16.7/drivers/powercap/Kconfig	2015-04-19 20:52:58.248897549 +0000
@@ -17,7 +17,7 @@
 # Client driver configurations go here.
 config INTEL_RAPL
 	tristate "Intel RAPL Support"
-	depends on X86
+	depends on X86 && !XEN
 	default n
 	---help---
 	  This enables support for the Intel Running Average Power Limit (RAPL)
diff -uNr linux-3.16.7-dxen/drivers/xen/core/spinlock.c linux-3.16.7/drivers/xen/core/spinlock.c
--- linux-3.16.7-dxen/drivers/xen/core/spinlock.c	2015-04-19 20:50:04.679883554 +0000
+++ linux-3.16.7/drivers/xen/core/spinlock.c	2015-04-19 20:52:58.272897551 +0000
@@ -297,11 +297,9 @@
 		}
 
 #if CONFIG_XEN_SPINLOCK_ACQUIRE_NESTING
-		if (upcall_mask > flags) {
-			spinning.irq_count = __this_cpu_read(_irq_count);
-			smp_wmb();
-			arch_local_irq_restore(flags);
-		}
+		spinning.irq_count = __this_cpu_read(_irq_count);
+		smp_wmb();
+		arch_local_irq_restore(flags);
 #endif
 
 		if (!test_evtchn(__this_cpu_read(poll_evtchn)) &&
diff -uNr linux-3.16.7-dxen/drivers/xen/scsifront/common.h linux-3.16.7/drivers/xen/scsifront/common.h
--- linux-3.16.7-dxen/drivers/xen/scsifront/common.h	2015-04-19 20:50:04.692883555 +0000
+++ linux-3.16.7/drivers/xen/scsifront/common.h	2015-04-19 20:52:58.284897552 +0000
@@ -112,8 +112,8 @@
 	struct task_struct *kthread;
 	wait_queue_head_t wq;
 	wait_queue_head_t wq_sync;
-	unsigned int waiting_resp:1;
-	unsigned int waiting_sync:1;
+	unsigned char waiting_resp;
+	unsigned char waiting_sync;
 
 	struct {
 		struct scsi_cmnd *sc;
diff -uNr linux-3.16.7-dxen/drivers/xen/scsifront/scsifront.c linux-3.16.7/drivers/xen/scsifront/scsifront.c
--- linux-3.16.7-dxen/drivers/xen/scsifront/scsifront.c	2015-04-19 20:50:04.692883555 +0000
+++ linux-3.16.7/drivers/xen/scsifront/scsifront.c	2015-04-19 20:52:58.285897552 +0000
@@ -480,12 +480,10 @@
 	uint16_t rqid;
 	int err = 0;
 
-	for (;;) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
-		spin_lock_irq(host->host_lock);
+	spin_lock_irq(host->host_lock);
 #endif
-		if (!RING_FULL(&info->ring))
-			break;
+	while (RING_FULL(&info->ring)) {
 		if (err) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
 			spin_unlock_irq(host->host_lock);
diff -uNr linux-3.16.7-dxen/drivers/xen/usbback/usbback.c linux-3.16.7/drivers/xen/usbback/usbback.c
--- linux-3.16.7-dxen/drivers/xen/usbback/usbback.c	2015-04-19 20:50:04.711883556 +0000
+++ linux-3.16.7/drivers/xen/usbback/usbback.c	2015-04-19 20:52:58.304897554 +0000
@@ -198,16 +198,29 @@
 }
 
 static void copy_buff_to_pages(void *buff, pending_req_t *pending_req,
-		int start, int nr_pages)
+			       unsigned int start, unsigned int nr_pages,
+			       unsigned int offset, unsigned int length)
 {
-	unsigned long copied = 0;
-	int i;
+	const struct pending_req_segment *seg = pending_req->seg + start;
+	unsigned int i, off, len, buf_off = 0;
 
-	for (i = start; i < start + nr_pages; i++) {
-		memcpy((void *) vaddr(pending_req, i) + pending_req->seg[i].offset,
-			buff + copied,
-			pending_req->seg[i].length);
-		copied += pending_req->seg[i].length;
+	for (i = start; i < start + nr_pages; i++, seg++) {
+		len = seg->length;
+		off = seg->offset;
+		if (buf_off + len > offset) {
+			if (buf_off < offset) {
+				len -= offset - buf_off;
+				off += offset - buf_off;
+				buf_off += offset - buf_off;
+			}
+			if (buf_off + len > offset + length)
+				len -= offset + length - buf_off;
+			memcpy((void *)vaddr(pending_req, i) + off,
+			       buff + buf_off, len);
+		}
+		buf_off += len;
+		if (buf_off >= offset + length)
+			break;
 	}
 }
 
@@ -353,17 +366,39 @@
 		notify_remote_via_irq(usbif->irq);
 }
 
+static void usbbk_copy_isoc_to_pages(struct urb *urb)
+{
+	pending_req_t *pending_req = urb->context;
+	struct usb_iso_packet_descriptor *isoc = &urb->iso_frame_desc[0];
+	unsigned int n_isoc = urb->number_of_packets;
+
+	copy_buff_to_pages(isoc, pending_req,
+			   pending_req->nr_buffer_segs,
+			   pending_req->nr_extra_segs, 0,
+			   n_isoc * sizeof(*isoc));
+
+	if (!usb_pipein(urb->pipe))
+		return;
+
+	while (n_isoc--) {
+		copy_buff_to_pages(pending_req->buffer,
+				   pending_req, 0,
+				   pending_req->nr_buffer_segs,
+				   isoc->offset, isoc->actual_length);
+		isoc++;
+	}
+}
+
 static void usbbk_urb_complete(struct urb *urb)
 {
 	pending_req_t *pending_req = (pending_req_t *)urb->context;
 
-	if (usb_pipein(urb->pipe) && urb->status == 0 && urb->actual_length > 0)
-		copy_buff_to_pages(pending_req->buffer, pending_req,
-					0, pending_req->nr_buffer_segs);
-
 	if (usb_pipeisoc(urb->pipe))
-		copy_buff_to_pages(&urb->iso_frame_desc[0], pending_req,
-					pending_req->nr_buffer_segs, pending_req->nr_extra_segs);
+		usbbk_copy_isoc_to_pages(urb);
+	else if (usb_pipein(urb->pipe) && urb->actual_length > 0)
+		copy_buff_to_pages(pending_req->buffer, pending_req,
+				   0, pending_req->nr_buffer_segs,
+				   0, urb->actual_length);
 
 	barrier();
 
diff -uNr linux-3.16.7-dxen/drivers/xen/usbfront/usbfront-q.c linux-3.16.7/drivers/xen/usbfront/usbfront-q.c
--- linux-3.16.7-dxen/drivers/xen/usbfront/usbfront-q.c	2015-04-19 20:50:04.713883556 +0000
+++ linux-3.16.7/drivers/xen/usbfront/usbfront-q.c	2015-04-19 20:52:58.306897554 +0000
@@ -221,6 +221,7 @@
 __acquires(info->lock)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;
+	int urbp_status = urbp->status;
 
 	list_del_init(&urbp->list);
 	free_urb_priv(urbp);
@@ -237,7 +238,7 @@
 	}
 	spin_unlock(&info->lock);
 	usb_hcd_giveback_urb(info_to_hcd(info), urb,
-			     urbp->status <= 0 ? urbp->status : urb->status);
+			     urbp_status <= 0 ? urbp_status : urb->status);
 	spin_lock(&info->lock);
 }
 
