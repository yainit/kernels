diff -uNr linux-3.16.7-60.1/arch/x86/kernel/ftrace.c linux-3.16.7-69.1/arch/x86/kernel/ftrace.c
--- linux-3.16.7-60.1/arch/x86/kernel/ftrace.c	2014-08-03 22:25:02.000000000 +0000
+++ linux-3.16.7-69.1/arch/x86/kernel/ftrace.c	2015-05-01 14:19:21.110231929 +0000
@@ -84,12 +84,20 @@
 	 * CONFIG_DEBUG_RODATA. So we use the kernel identity mapping instead
 	 * of the kernel text mapping to modify the kernel text.
 	 *
+	 * This is not needed when the kernel is not set read only. In fact,
+	 * the kernel text mapping might be read only when this function is
+	 * called from ftrace_init() and the kernel was loaded under
+	 * Xen hypervisor. In this situation, we could safely use the
+	 * kernel text mapping.
+	 *
 	 * For 32bit kernels, these mappings are same and we can use
 	 * kernel identity mapping to modify code.
 	 */
-	if (within(ip, (unsigned long)_text, (unsigned long)_etext))
+#ifdef CONFIG_DEBUG_RODATA
+	if (kernel_set_to_readonly &&
+	    within(ip, (unsigned long)_text, (unsigned long)_etext))
 		ip = (unsigned long)__va(__pa_symbol(ip));
-
+#endif
 	return ip;
 }
 
diff -uNr linux-3.16.7-60.1/drivers/ata/libata-core.c linux-3.16.7-69.1/drivers/ata/libata-core.c
--- linux-3.16.7-60.1/drivers/ata/libata-core.c	2015-04-10 13:17:21.000000000 +0000
+++ linux-3.16.7-69.1/drivers/ata/libata-core.c	2015-05-01 14:19:21.144231927 +0000
@@ -4228,6 +4228,7 @@
 	{ "Crucial_CT???M500SSD*",	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ "Micron_M550*",		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ "Crucial_CT*M550SSD*",	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
+	{ "Samsung SSD 850 PRO*",	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
diff -uNr linux-3.16.7-60.1/drivers/cpufreq/cpufreq.c linux-3.16.7-69.1/drivers/cpufreq/cpufreq.c
--- linux-3.16.7-60.1/drivers/cpufreq/cpufreq.c	2015-04-10 13:17:21.000000000 +0000
+++ linux-3.16.7-69.1/drivers/cpufreq/cpufreq.c	2015-05-01 14:19:21.151231927 +0000
@@ -2002,6 +2002,12 @@
 	/* Don't start any governor operations if we are entering suspend */
 	if (cpufreq_suspended)
 		return 0;
+	/*
+	 * Governor might not be initiated here if ACPI _PPC changed
+	 * notification happened, so check it.
+	 */
+	if (!policy->governor)
+		return -EINVAL;
 
 	if (policy->governor->max_transition_latency &&
 	    policy->cpuinfo.transition_latency >
diff -uNr linux-3.16.7-60.1/drivers/thermal/step_wise.c linux-3.16.7-69.1/drivers/thermal/step_wise.c
--- linux-3.16.7-60.1/drivers/thermal/step_wise.c	2014-08-03 22:25:02.000000000 +0000
+++ linux-3.16.7-69.1/drivers/thermal/step_wise.c	2015-05-01 14:19:21.225231924 +0000
@@ -146,9 +146,6 @@
 		dev_dbg(&instance->cdev->device, "old_target=%d, target=%d\n",
 					old_target, (int)instance->target);
 
-		if (old_target == instance->target)
-			continue;
-
 		/* Activate a passive thermal instance */
 		if (old_target == THERMAL_NO_TARGET &&
 			instance->target != THERMAL_NO_TARGET)
diff -uNr linux-3.16.7-60.1/fs/btrfs/ioctl.c linux-3.16.7-69.1/fs/btrfs/ioctl.c
--- linux-3.16.7-60.1/fs/btrfs/ioctl.c	2015-05-01 14:18:49.464233234 +0000
+++ linux-3.16.7-69.1/fs/btrfs/ioctl.c	2015-05-01 14:19:21.299231921 +0000
@@ -3676,6 +3676,11 @@
 	if (off + len == src->i_size)
 		len = ALIGN(src->i_size, bs) - off;
 
+	if (len == 0) {
+		ret = 0;
+		goto out_unlock;
+	}
+
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
diff -uNr linux-3.16.7-60.1/fs/ext4/extents.c linux-3.16.7-69.1/fs/ext4/extents.c
--- linux-3.16.7-60.1/fs/ext4/extents.c	2015-05-01 14:18:49.473233234 +0000
+++ linux-3.16.7-69.1/fs/ext4/extents.c	2015-05-01 14:19:21.309231920 +0000
@@ -4793,11 +4793,6 @@
 	else
 		max_blocks -= lblk;
 
-	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
-		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN;
-	if (mode & FALLOC_FL_KEEP_SIZE)
-		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
-
 	mutex_lock(&inode->i_mutex);
 
 	/*
@@ -4814,15 +4809,28 @@
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
-		/*
-		 * If we have a partial block after EOF we have to allocate
-		 * the entire block.
-		 */
-		if (partial_end)
-			max_blocks += 1;
 	}
 
+	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
+	if (mode & FALLOC_FL_KEEP_SIZE)
+		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
+
+	/* Preallocate the range including the unaligned edges */
+	if (partial_begin || partial_end) {
+		ret = ext4_alloc_file_blocks(file,
+				round_down(offset, 1 << blkbits) >> blkbits,
+				(round_up((offset + len), 1 << blkbits) -
+				 round_down(offset, 1 << blkbits)) >> blkbits,
+				new_size, flags, mode);
+		if (ret)
+			goto out_mutex;
+
+	}
+
+	/* Zero range excluding the unaligned edges */
 	if (max_blocks > 0) {
+		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
+			  EXT4_EX_NOCACHE);
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
@@ -4832,15 +4840,21 @@
 		ext4_inode_block_unlocked_dio(inode);
 		inode_dio_wait(inode);
 
+		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
+					     flags, mode);
+		if (ret)
+			goto out_dio;
 		/*
 		 * Remove entire range from the extent status tree.
+		 *
+		 * ext4_es_remove_extent(inode, lblk, max_blocks) is
+		 * NOT sufficient.  I'm not sure why this is the case,
+		 * but let's be conservative and remove the extent
+		 * status tree for the entire inode.  There should be
+		 * no outstanding delalloc extents thanks to the
+		 * filemap_write_and_wait_range() call above.
 		 */
-		ret = ext4_es_remove_extent(inode, lblk, max_blocks);
-		if (ret)
-			goto out_dio;
-
-		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
-					     flags, mode);
+		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
 		if (ret)
 			goto out_dio;
 	}
