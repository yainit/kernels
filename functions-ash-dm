#
# functions necessary for all my scripts
#  (copy) Dieter Miosga, 2012-02-01 through 2015-05-30
#
echo "[ $0 ] : Reading functions ...."
#
PROCNUM=""
STARTTIME=""
STARTTIMENS=""
HR=""
MIN=""
SEC=""
HRSEC=""
MINSEC=""
STRT=""
NANOS=0
MOUNTDIR="/var/run/media/root"
#
echoconsole()
{
  local  SCRIPT
  # the //scriptname form of scriptname remained
  # for some kernel internal reason
  SCRIPT=""
  #SCRIPT="$(echo $1 | /bin/busybox tr -d "\/" 2>/dev/null)"
  [ "$SCRIPT" = "" ] && SCRIPT="$1"
  shift
  [ "$SCRIPT" = "" ] && SCRIPT="$0"
  # set quiet parameter on cmdline to stop any system messages from init script
  if [ "$QUIET" = "" ]; then
    echo "[ $SCRIPT ]: $@ "
    #echo "[ $SCRIPT ]: $@ "  >> init.log  2>&1
  fi
}
#
startts()
{
  echoconsole "$0" "$(/bin/busybox uname -a )"
  echoconsole "$0"  "$(/bin/busybox grep -m1 'model name' /proc/cpuinfo | /bin/busybox cut -f2 -d ':' )"
  echoconsole "$0" "processor family : level" "$(/bin/busybox grep -E -m1 'cpu family' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" ":" "$(/bin/busybox grep  -m1 'cpuid level' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " at " "$(/bin/busybox grep -E -m1 'cpu MHz' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " MHz"
  echoconsole "$0" " with " "$(/bin/busybox grep -m1 'cpu cores' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  " cpu cores and each " "$(/bin/busybox grep  -m1 'cache size' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " of L2-Cache"
  PROCNUM=$(/bin/busybox grep -m1 "cpu cores" /proc/cpuinfo | /bin/busybox cut -f2 -d: | /bin/busybox tr -d " " 2>/dev/null )
  # yet no nanosecond display of date with busybox exists
  #STRT="$(/bin/busybox date -Ins )"
  STRT="$(/bin/busybox date -Is )"
  #if [ "$STRT" = "" ]; then STRT="$(/bin/busybox date -Is )" ; fi
  echoconsole "$0" "$STRT"
  HR="$(echo "$STRT" | /bin/busybox cut -f1 -d ':' | /bin/busybox cut -f2 -d 'T')"
  # remove leading zeros
  NANOS="$HR"
  local ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1  )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    HR=$NANOS
  fi 
  #echo "$MIN minuten ...."
  HRSEC=$(( $HR * 3600 ))
  MIN="$(echo "$STRT" | /bin/busybox cut -f2 -d ':' )"
  # remove leading zeros
  NANOS="$MIN"
  ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    MIN=$NANOS
  fi 
  #echo "$MIN minuten ...."
  MINSEC=$(( $MIN * 60 ))
  SEC="$(echo "$STRT" | /bin/busybox cut -f3 -d ':' | /bin/busybox cut -f1 -d '+' )"
  #echo "$SEC sekunden ...."
  # remove leading zeros
  NANOS="$SEC"
  ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    SEC=$NANOS
  fi 
  STARTTIMENS="$(echo "$STRT"  | /bin/busybox cut -f2 -d ',' | /bin/busybox cut -f1 -d '+' 2>/dev/null )"
  #STARTTIMENS=$STARTTIMENS
  STARTTIME=$(( $MINSEC + $SEC ))
  STARTTIME=$(( $HRSEC + $STARTTIME))
  if [ "$1" != "" ]; then
    echoconsole "$0" "$(/bin/busybox uname -a )" >> $1 2>&1
    echoconsole "$0" "$(/bin/busybox grep -m1 'model name' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  >> $1 2>&1
    echoconsole "$0" "processor family:level " "$(/bin/busybox grep  -m1 'cpu family' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" ":" "$(/bin/busybox grep -E -m1 'cpuid level' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " at " "$(/bin/busybox grep -m1 'cpu MHz' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " MHz"  >> $1 2>&1
    echoconsole "$0" " with " "$(/bin/busybox grep -m1 'cpu cores' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " cpu cores and " "$(/bin/busybox grep -m1 'cache size' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " of L2-Cache " >> $1 2>&1
    echoconsole "$0" " and instruction set " >> $1 2>&1
    echoconsole "$0" "$(/bin/busybox grep  -m1 'flags' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  >> $1 2>&1
    echoconsole "$0" "$START"  >> $1 2>&1
    echoconsole "$0" "Beginning : $STARTTIME ./. $STRT " >> $1 2>&1
  fi
  echoconsole "$0" "Beginning: $STARTTIME ./. $STRT"
}

localmachine_values()
{
   [ "$1" ] &&
   {
    echoconsole "$0" "$(/bin/busybox uname -a )" >> $1 2>&1
    echoconsole "$0" "$(/bin/busybox grep -m1 'model name' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  >> $1 2>&1
    echoconsole "$0" "processor family:level " "$(/bin/busybox grep  -m1 'cpu family' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" ":" "$(/bin/busybox grep -E -m1 'cpuid level' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " at " "$(/bin/busybox grep -m1 'cpu MHz' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " MHz"  >> $1 2>&1
    echoconsole "$0" " with " "$(/bin/busybox grep -m1 'cpu cores' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " cpu cores and " "$(/bin/busybox grep -m1 'cache size' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " of L2-Cache " >> $1 2>&1
    echoconsole "$0" " and instruction set " >> $1 2>&1
    echoconsole "$0" "$(/bin/busybox grep  -m1 'flags' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  >> $1 2>&1
   }
   {
    echoconsole "$0" "$(/bin/busybox uname -a )"  2>&1
    echoconsole "$0" "$(/bin/busybox grep -m1 'model name' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  2>&1
    echoconsole "$0" "processor family:level " "$(/bin/busybox grep  -m1 'cpu family' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" ":" "$(/bin/busybox grep -E -m1 'cpuid level' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " at " "$(/bin/busybox grep -m1 'cpu MHz' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " MHz"  2>&1
    echoconsole "$0" " with " "$(/bin/busybox grep -m1 'cpu cores' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " cpu cores and " "$(/bin/busybox grep -m1 'cache size' /proc/cpuinfo | /bin/busybox cut -f2 -d: )" " of L2-Cache "  2>&1
    echoconsole "$0" " and instruction set "  2>&1
    echoconsole "$0" "$(/bin/busybox grep  -m1 'flags' /proc/cpuinfo | /bin/busybox cut -f2 -d: )"  2>&1
   }
   
}

timestamp_begin()
{
  STRT="$(/bin/busybox date +%s%N 2>/dev/null)"
  NANOS=${STRT}
  export STARTTIME=${NANOS}
  echoconsole "$0" "Beginning: '$STARTTIME' nanoseconds of Epoch (since 1/1/1970) "
  echoconsole "$0" "Start Timestamp ISOsec.: '`/bin/busybox date -Is --date=@${STARTTIME:0:10}`' "
  [ "$1" != "" ] && echoconsole "$0" "Beginning: '$STARTTIME' nanoseconds of Epoch (since 1/1/1970) " >> $1 2>&1
  [ "$1" != "" ] && echoconsole "$0" "Start Timestamp ISOsec.: '`/bin/busybox date -Is --date=@${STARTTIME:0:10}`' " >> $1 2>&1

}
#
STOPTIME=""
STOPTIMENS=""
STOP=""
stopts()
{

  # yet no nanoseconds date in busybox exist
  #STOP="$(date -Ins )"
  STOP="$(/bin/busybox date -Is )"
  #if [ "$STOP" = "" ]; then STOP="$(/bin/busybox date -Is )" ; fi
  echoconsole "$0" "$STOP"
  HR="$(echo "$STOP" | /bin/busybox cut -f1 -d ':' | /bin/busybox cut -f2 -d 'T' )"
  # remove leading zeros
  NANOS="$HR"
  local ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    HR=$NANOS
  fi
  HRSEC=$(( $HR * 3600 )) 
  MIN="$(echo "$STOP" | /bin/busybox cut -f2 -d ':' )"
  # remove leading zeros
  NANOS="$MIN"
  ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    MIN=$NANOS
  fi 
  MINSEC=$(( $MIN * 60 ))
  SEC="$(echo "$STOP" | /bin/busybox cut -f3 -d ':' | /bin/busybox cut -f1 -d '+' )"
  NANOS="$SEC"
  ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
  if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
  if [ $NANOS -lt 10 ]; then
    SEC=$NANOS
  fi 
  STOPTIMENS="$(echo "$STOP" |  /bin/busybox cut -f2 -d ',' | /bin/busybox cut -f1 -d '+' )"
  #STOPTIMENS=$STOPTIMENS
  STOPTIME=$(( $MINSEC + $SEC ))
  STOPTIME=$(( $HRSEC + $STOPTIME ))
  if [ "$1" != "" ]; then
     echoconsole "$0" "$STOP"  >> $1 2>&1
#     echoconsole "$0" "Ended(sec): $STOPTIME ./. $STOP" >> $1 2>&1
     echoconsole "$0" "Ended(sec): $STOPTIME" >> $1 2>&1
  fi
  echoconsole "$0" "Ended(sec): $STOPTIME"
#  echoconsole "$0" "Ended(sec): $STOPTIME ./. $STOPT"
  
}
#
timestamp_stop()
{
  STRT="$(/bin/busybox date +%s%N 2>/dev/null)"
  NANOS=${STRT}
  export STOPTIME=${NANOS}
  echoconsole "$0" "Ending: '$STOPTIME' nanoseconds of Epoch (since 1/1/1970) "
  echoconsole "$0" "Stop Timestamp ISOsec.: `/bin/busybox date -Is --date=@${STOPTIME:0:10}` "
  [ "$1" != "" ] && echoconsole "$0" "Ending: '$STOPTIME' nanoseconds of Epoch (since 1/1/1970) " >> $1 2>&1
  [ "$1" != "" ] && echoconsole "$0" "Start Timestamp ISOsec.: `/bin/busybox date -Is --date=@${STOPTIME:0:10}` " >> $1 2>&1
  
}
#
#
DIFFTIME=""
DIFFTIMEHR=""
DIFFTIMENS=""
DIFFTIMEMIN=""
DIFFTIMESEC=""

#
timediff()
{
  # we measure upto minutes
  #if [ $STOPTIME -lt $STARTTIME ]; then
  #  STOPTIME=$(( $STOPTIME + 3600 ))
  #fi
  DIFFTIME=$(( $STOPTIME - $STARTTIME ))
  local STARTNS STOPNS ZERO
#  STARTNS=$STARTTIMENS
#  STOPNS=$STOPTIMENS
  # remove leading zeros
#  NANOS="$STARTTIMENS"
#  for i in 1 2 3 4 5 6 7 8 9; do
#    ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
#    if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
#  done
#  if [ $NANOS -lt 1000000000 ]; then
#    STARTNS=$NANOS
#  fi 
#  NANOS="$STOPTIMENS"
#  for i in 1 2 3 4 5 6 7 8 9; do
#    ZERO="$(echo "$NANOS" | /bin/busybox cut -c 1 )"
#    if [ "$ZERO" = "0" ]; then NANOS="$(echo "$NANOS" | /bin/busybox cut -c 2- )"; fi
#  done
#  if [ $NANOS -lt 1000000000 ]; then
#    STOPNS=$NANOS
#  fi 
  
#  for now busybox does not allow to display date to ns  
#  adjust the nanoseconds with sign
#  if [ $STOPNS -lt $STARTNS ]; then
#    DIFFTIME=$(( $DIFFTIME - 1 ))
#    DIFFTIMENS=$(( $STARTNS - $STOPNS ))
#  else
#    DIFFTIMENS=$(( $STOPNS - $STARTNS ))
#  fi

  DIFFTIMEHR=$(( $DIFFTIME / 3600 ))
  DIFFTIMEMIN=$(( $DIFFTIME / 60 ))
  DIFFTIMESEC=$(( $DIFFTIMEMIN * 60 ))
  DIFFTIMESEC=$(( $DIFFTIME - $DIFFTIMESEC ))
  STARTTIMENS=0
  STOPTIMENS=0
  if [ "$1" != "" ]; then
     echoconsole "$0" "Endured: $DIFFTIMEHR : $DIFFTIMEMIN : $DIFFTIMESEC (hour:min:sec)  $DIFFTIME.$DIFFTIMENS (sec.ns)" >> $1 2>&1
     echoconsole "$0" "    started-->$STARTTIME.$STARTTIMENS ./. $STOPTIME.$STOPTIMENS<--stopped "  >> $1 2>&1
  fi
  echoconsole "$0" "Endured: $DIFFTIMEHR : $DIFFTIMEMIN : $DIFFTIMESEC (hour:min:sec)  $DIFFTIME./.$DIFFTIMENS (sec.ns)"
  echoconsole "$0" "    started-->$STARTTIME.$STARTTIMENS ./. $STOPTIME.$STOPTIMENS<--stopped "

}
#
timestamp_diff()
{
  DIFFTIME=$(( $STOPTIME - $STARTTIME ))
  if [ "$1" != "" ]; then
     echoconsole "$0" " Difference: $DIFFTIME =  $STOPTIME - $STARTTIME " >> $1 2>&1
  fi
  echoconsole "$0" " Difference: $DIFFTIME =  $STOPTIME \- $STARTTIME "
  DIFFTIMESEC=$(( $DIFFTIME   / 1000000000 ))
  DIFFTIMENS=$(( $DIFFTIMESEC * 1000000000 ))
  DIFFTIMENS=$(( $DIFFTIME - $DIFFTIMENS ))
  # hours days years
  DIFFTIMEHR=$(( $DIFFTIMESEC / 3600 ))
  echoconsole "$0" " Difference hours:  $DIFFTIMEHR "
  local DIFFTIMEDAY=$(( $DIFFTIMEHR / 24 ))
  echoconsole "$0" " Difference days: $DIFFTIMEDAY "
  local DIFFTIMEYEAR=$(( $DIFFTIMEDAY / 365 ))
  echoconsole "$0" " Difference years: $DIFFTIMEYEAR"
  # hourseconds
  DIFFTIMEMIN=$(( $DIFFTIMEHR * 3600 ))  
  # remaining seconds after hourseconds
  DIFFTIMESEC=$(( $DIFFTIMESEC - $DIFFTIMEMIN ))  
  # minutes
  DIFFTIMEMIN=$(( $DIFFTIMESEC / 60 ))  
  echoconsole "$0" " Difference minutes:  $DIFFTIMEMIN "
  # minuteseconds
  DIFFTIME=$(( $DIFFTIMEMIN * 60 ))
  # remaining seconds
  DIFFTIMESEC=$(( $DIFFTIMESEC - $DIFFTIME ))
    

  STARTTIMENS=0
  STOPTIMENS=0
  if [ "$1" != "" ]; then
     echoconsole "$0" " Endured: $DIFFTIMEHR : $DIFFTIMEMIN : $DIFFTIMESEC (hour:min:sec)  $DIFFTIMESEC.$DIFFTIMENS (sec.ns)" >> $1 2>&1
     echoconsole "$0" " started-->$STARTTIME./. $STOPTIME<--stopped "  >> $1 2>&1
     echoconsole "$0" " Starttime--> `/bin/busybox date -Is --date=@${STARTTIME:0:10}`  ./.  `/bin/busybox date -Is --date=@${STOPTIME:0:10}` <--Stoptime" >> $1 2>&1
  fi
  echoconsole "$0" " Endured: $DIFFTIMEHR : $DIFFTIMEMIN : $DIFFTIMESEC (hour:min:sec)  $DIFFTIMESEC.$DIFFTIMENS (sec.ns)"
  echoconsole "$0" " started-->$STARTTIME <-> $STOPTIME<--stopped "
  echoconsole "$0" " Starttime--> `/bin/busybox date -Is --date=@${STARTTIME:0:10}`  ./.  `/bin/busybox date -Is --date=@${STOPTIME:0:10}` <--Stoptime" 
}
#
exitfunc()
{
  timestamp_stop $2
  timestamp_diff $2
  exit $1
}
#
RAMDISKFS=""
RAMDISKDIR="/ramdisk"
RAMSIZE=""
RAMFREE=""
RC=""
MOUNTED=""
ONEGB=""
MAXRAM=""
#
mkramdisk()
{

  ONEGB=$(( 1024 * 1024 *1024 ))
  MAXRAM=$(( 10 * $ONEGB ))
  RAMFREE="$(/bin/busybox grep 'MemFree' /proc/meminfo | /bin/busybox cut -f2 -d: | /bin/busybox tr -d " "[:alpha:] )"
  RAMFREE=$(( $RAMFREE * 1024 ))
  if [ "$RAMFREE" != "" ]; then
    if [ $RAMFREE -gt $ONEGB ]; then
      if [ $RAMFREE -gt $MAXRAM ]; then
        RAMFREE=$MAXRAM
      fi
    fi
    mkdir -p $RAMDISKDIR
    MOUNTED="$(/bin/busybox grep "ramfs $RAMDISKDIR"  /proc/mounts 2>/dev/null )"
    if [ "$MOUNTED" = "" ]; then
      mount -t ramfs -o size=$RAMFREE ramfs /ramdisk  2>/dev/null
      RC=$?
       if [ $RC -eq 0 ]; then
         RAMDISKFS="$RAMDISKDIR"
       fi
    else
       RAMDISKFS="$RAMDISKDIR"
    fi
  fi

}
#
is_string_in_file()
{
  case "$(/bin/busybox cat $2 2>/dev/null)" in 
    *$1*) 
      return 0
    ;; 
  esac
  return 1
}
#
is_not_string_in_file()
{
  case "$(/bin/busybox cat $2 2>/dev/null)" in 
    *$1*) 
      return 1
    ;; 
  esac
  return 0
}
#
# thanks to R.Shingledecker/TinyCore
# this is a faster solution than with grep
is_substring_of()
{
  case "$2" in
     *$1*) 
       return 0
     ;; 
  esac
  return 1
}
#
is_not_substring_of()
{
  case "$2" in
     *$1*) 
       return 1
     ;; 
  esac
  return 0
}
#
remove_duplicates_from_string()
{

  local STRINGVAR STRING DRV
  if [ "$1" != "" ]; then
    #eval STRINGVAR="\$$1"
    STRING=""
    STRINGVAR="$1"
    for DRV in $STRINGVAR; do
      if `is_not_substring_of  " $DRV " " $STRING "`; then 
        STRING="$STRING $DRV "
      fi
    done
    #if [ "$STRING" != "" ]; then
    #  STRINGVAR="$1=\" $STRING \""
    #  eval "$STRINGVAR"
    #fi
    echo "$STRING"
    return 0
  else
    echo ""
    return 127
  fi
}
#
remove_duplicate_tokens_from_global_string()
{

  local localSTRINGVAR localSTRING tok
  if [ "$1" != "" ]; then
    eval localSTRINGVAR="\$$1"
    localSTRING=""
    for tok in $localSTRINGVAR; do
      if `is_not_substring_of  " $tok " " $localSTRING "`; then 
        localSTRING="$localSTRING $tok"
      fi
    done
    if [ "$localSTRING" != "" ]; then
      localSTRINGVAR="$1=\"`echo $localSTRING`\""
      eval "$localSTRINGVAR"
      #export "$1"
    fi
    return $?
  else
    return 127
  fi
}


#
echo "[ $0 ] : .... all functions read in !"
#
