diff -uNr linux-4.3.3-5.16nodeb/arch/powerpc/kernel/eeh.c linux-4.3.3-6.17nodeb/arch/powerpc/kernel/eeh.c
--- linux-4.3.3-5.16nodeb/arch/powerpc/kernel/eeh.c	2015-12-02 01:21:06.000000000 +0000
+++ linux-4.3.3-6.17nodeb/arch/powerpc/kernel/eeh.c	2016-01-11 21:15:50.000000000 +0000
@@ -1071,7 +1071,13 @@
 	struct pci_controller *phb;
 	struct eeh_dev *edev = pdn_to_eeh_dev(pdn);
 
-	if (!edev || !eeh_enabled())
+	if (!edev)
+		return;
+
+	/* Some platforms (like Cell) don't have EEH capabilities, so we
+	 * need to abort here. In case of pseries or powernv, we have EEH
+	 * so we can continue. */
+	if (!machine_is(pseries) && !machine_is(powernv))
 		return;
 
 	if (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))
diff -uNr linux-4.3.3-5.16nodeb/fs/overlayfs/inode.c linux-4.3.3-6.17nodeb/fs/overlayfs/inode.c
--- linux-4.3.3-5.16nodeb/fs/overlayfs/inode.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/fs/overlayfs/inode.c	2016-01-11 21:15:50.000000000 +0000
@@ -49,13 +49,13 @@
 	if (err)
 		goto out;
 
-	upperdentry = ovl_dentry_upper(dentry);
-	if (upperdentry) {
+	err = ovl_copy_up(dentry);
+	if (!err) {
+		upperdentry = ovl_dentry_upper(dentry);
+
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
-	} else {
-		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
diff -uNr linux-4.3.3-5.16nodeb/include/net/dst.h linux-4.3.3-6.17nodeb/include/net/dst.h
--- linux-4.3.3-5.16nodeb/include/net/dst.h	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/include/net/dst.h	2016-01-11 21:15:50.000000000 +0000
@@ -322,6 +322,39 @@
 	}
 }
 
+/**
+ * dst_hold_safe - Take a reference on a dst if possible
+ * @dst: pointer to dst entry
+ *
+ * This helper returns false if it could not safely
+ * take a reference on a dst.
+ */
+static inline bool dst_hold_safe(struct dst_entry *dst)
+{
+	if (dst->flags & DST_NOCACHE)
+		return atomic_inc_not_zero(&dst->__refcnt);
+	dst_hold(dst);
+	return true;
+}
+
+/**
+ * skb_dst_force_safe - makes sure skb dst is refcounted
+ * @skb: buffer
+ *
+ * If dst is not yet refcounted and not destroyed, grab a ref on it.
+ */
+static inline void skb_dst_force_safe(struct sk_buff *skb)
+{
+	if (skb_dst_is_noref(skb)) {
+		struct dst_entry *dst = skb_dst(skb);
+
+		if (!dst_hold_safe(dst))
+			dst = NULL;
+
+		skb->_skb_refdst = (unsigned long)dst;
+	}
+}
+
 
 /**
  *	__skb_tunnel_rx - prepare skb for rx reinsert
diff -uNr linux-4.3.3-5.16nodeb/include/net/sock.h linux-4.3.3-6.17nodeb/include/net/sock.h
--- linux-4.3.3-5.16nodeb/include/net/sock.h	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/include/net/sock.h	2016-01-11 21:15:50.000000000 +0000
@@ -798,7 +798,7 @@
 static inline void __sk_add_backlog(struct sock *sk, struct sk_buff *skb)
 {
 	/* dont let skb dst not refcounted, we are going to leave rcu lock */
-	skb_dst_force(skb);
+	skb_dst_force_safe(skb);
 
 	if (!sk->sk_backlog.tail)
 		sk->sk_backlog.head = skb;
diff -uNr linux-4.3.3-5.16nodeb/kernel/fork.c linux-4.3.3-6.17nodeb/kernel/fork.c
--- linux-4.3.3-5.16nodeb/kernel/fork.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/kernel/fork.c	2016-01-11 21:15:50.000000000 +0000
@@ -87,6 +87,11 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
+#ifdef CONFIG_USER_NS
+extern int unprivileged_userns_clone;
+#else
+#define unprivileged_userns_clone 0
+#endif
 
 /*
  * Minimum number of threads to boot the kernel
@@ -1259,6 +1264,10 @@
 	if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
 		return ERR_PTR(-EINVAL);
 
+	if ((clone_flags & CLONE_NEWUSER) && !unprivileged_userns_clone)
+		if (!capable(CAP_SYS_ADMIN))
+			return ERR_PTR(-EPERM);
+
 	/*
 	 * Thread groups must share signals as well, and detached threads
 	 * can only be started up within the thread group.
@@ -1988,6 +1997,12 @@
 	if (unshare_flags & CLONE_NEWNS)
 		unshare_flags |= CLONE_FS;
 
+	if ((unshare_flags & CLONE_NEWUSER) && !unprivileged_userns_clone) {
+		err = -EPERM;
+		if (!capable(CAP_SYS_ADMIN))
+			goto bad_unshare_out;
+	}
+
 	err = check_unshare_flags(unshare_flags);
 	if (err)
 		goto bad_unshare_out;
diff -uNr linux-4.3.3-5.16nodeb/kernel/ptrace.c linux-4.3.3-6.17nodeb/kernel/ptrace.c
--- linux-4.3.3-5.16nodeb/kernel/ptrace.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/kernel/ptrace.c	2016-01-11 21:15:50.000000000 +0000
@@ -207,12 +207,32 @@
 	return ret;
 }
 
-static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)
+static bool ptrace_has_cap(const struct cred *tcred, unsigned int mode)
 {
+	struct user_namespace *tns = tcred->user_ns;
+	struct user_namespace *curns = current_cred()->user_ns;
+
+	/* When a root-owned process enters a user namespace created by a
+	 * malicious user, the user shouldn't be able to execute code under
+	 * uid 0 by attaching to the root-owned process via ptrace.
+	 * Therefore, similar to the capable_wrt_inode_uidgid() check,
+	 * verify that all the uids and gids of the target process are
+	 * mapped into the current namespace.
+	 * No fsuid/fsgid check because __ptrace_may_access doesn't do it
+	 * either.
+	 */
+	if (!kuid_has_mapping(curns, tcred->euid) ||
+			!kuid_has_mapping(curns, tcred->suid) ||
+			!kuid_has_mapping(curns, tcred->uid)  ||
+			!kgid_has_mapping(curns, tcred->egid) ||
+			!kgid_has_mapping(curns, tcred->sgid) ||
+			!kgid_has_mapping(curns, tcred->gid))
+		return false;
+
 	if (mode & PTRACE_MODE_NOAUDIT)
-		return has_ns_capability_noaudit(current, ns, CAP_SYS_PTRACE);
+		return has_ns_capability_noaudit(current, tns, CAP_SYS_PTRACE);
 	else
-		return has_ns_capability(current, ns, CAP_SYS_PTRACE);
+		return has_ns_capability(current, tns, CAP_SYS_PTRACE);
 }
 
 /* Returns 0 on success, -errno on denial. */
@@ -241,7 +261,7 @@
 	    gid_eq(cred->gid, tcred->sgid) &&
 	    gid_eq(cred->gid, tcred->gid))
 		goto ok;
-	if (ptrace_has_cap(tcred->user_ns, mode))
+	if (ptrace_has_cap(tcred, mode))
 		goto ok;
 	rcu_read_unlock();
 	return -EPERM;
@@ -252,7 +272,7 @@
 		dumpable = get_dumpable(task->mm);
 	rcu_read_lock();
 	if (dumpable != SUID_DUMP_USER &&
-	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
+	    !ptrace_has_cap(__task_cred(task), mode)) {
 		rcu_read_unlock();
 		return -EPERM;
 	}
diff -uNr linux-4.3.3-5.16nodeb/kernel/sysctl.c linux-4.3.3-6.17nodeb/kernel/sysctl.c
--- linux-4.3.3-5.16nodeb/kernel/sysctl.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/kernel/sysctl.c	2016-01-11 21:15:50.000000000 +0000
@@ -102,6 +102,9 @@
 extern char core_pattern[];
 extern unsigned int core_pipe_limit;
 #endif
+#ifdef CONFIG_USER_NS
+extern int unprivileged_userns_clone;
+#endif
 extern int pid_max;
 extern int pid_max_min, pid_max_max;
 extern int percpu_pagelist_fraction;
@@ -480,6 +483,15 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#endif
+#ifdef CONFIG_USER_NS
+	{
+		.procname	= "unprivileged_userns_clone",
+		.data		= &unprivileged_userns_clone,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
 #endif
 #ifdef CONFIG_PROC_SYSCTL
 	{
diff -uNr linux-4.3.3-5.16nodeb/kernel/user_namespace.c linux-4.3.3-6.17nodeb/kernel/user_namespace.c
--- linux-4.3.3-5.16nodeb/kernel/user_namespace.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/kernel/user_namespace.c	2016-01-11 21:15:50.000000000 +0000
@@ -23,6 +23,12 @@
 #include <linux/projid.h>
 #include <linux/fs_struct.h>
 
+/*
+ * sysctl determining whether unprivileged users may unshare a new
+ * userns.  Allowed by default
+ */
+int unprivileged_userns_clone = 1;
+
 static struct kmem_cache *user_ns_cachep __read_mostly;
 static DEFINE_MUTEX(userns_state_mutex);
 
diff -uNr linux-4.3.3-5.16nodeb/lib/rhashtable.c linux-4.3.3-6.17nodeb/lib/rhashtable.c
--- linux-4.3.3-5.16nodeb/lib/rhashtable.c	2015-12-02 01:21:07.000000000 +0000
+++ linux-4.3.3-6.17nodeb/lib/rhashtable.c	2016-01-11 21:15:50.000000000 +0000
@@ -503,10 +503,11 @@
 	if (!iter->walker)
 		return -ENOMEM;
 
-	mutex_lock(&ht->mutex);
-	iter->walker->tbl = rht_dereference(ht->tbl, ht);
+	spin_lock(&ht->lock);
+	iter->walker->tbl =
+		rcu_dereference_protected(ht->tbl, lockdep_is_held(&ht->lock));
 	list_add(&iter->walker->list, &iter->walker->tbl->walkers);
-	mutex_unlock(&ht->mutex);
+	spin_unlock(&ht->lock);
 
 	return 0;
 }
@@ -520,10 +521,10 @@
  */
 void rhashtable_walk_exit(struct rhashtable_iter *iter)
 {
-	mutex_lock(&iter->ht->mutex);
+	spin_lock(&iter->ht->lock);
 	if (iter->walker->tbl)
 		list_del(&iter->walker->list);
-	mutex_unlock(&iter->ht->mutex);
+	spin_unlock(&iter->ht->lock);
 	kfree(iter->walker);
 }
 EXPORT_SYMBOL_GPL(rhashtable_walk_exit);
@@ -547,14 +548,12 @@
 {
 	struct rhashtable *ht = iter->ht;
 
-	mutex_lock(&ht->mutex);
+	rcu_read_lock();
 
+	spin_lock(&ht->lock);
 	if (iter->walker->tbl)
 		list_del(&iter->walker->list);
-
-	rcu_read_lock();
-
-	mutex_unlock(&ht->mutex);
+	spin_unlock(&ht->lock);
 
 	if (!iter->walker->tbl) {
 		iter->walker->tbl = rht_dereference_rcu(ht->tbl, ht);
diff -uNr linux-4.3.3-5.16nodeb/net/ipv4/tcp_ipv4.c linux-4.3.3-6.17nodeb/net/ipv4/tcp_ipv4.c
--- linux-4.3.3-5.16nodeb/net/ipv4/tcp_ipv4.c	2015-12-16 21:38:19.000000000 +0000
+++ linux-4.3.3-6.17nodeb/net/ipv4/tcp_ipv4.c	2016-01-11 21:15:50.000000000 +0000
@@ -1509,7 +1509,7 @@
 	if (likely(sk->sk_rx_dst))
 		skb_dst_drop(skb);
 	else
-		skb_dst_force(skb);
+		skb_dst_force_safe(skb);
 
 	__skb_queue_tail(&tp->ucopy.prequeue, skb);
 	tp->ucopy.memory += skb->truesize;
@@ -1710,8 +1710,7 @@
 {
 	struct dst_entry *dst = skb_dst(skb);
 
-	if (dst) {
-		dst_hold(dst);
+	if (dst && dst_hold_safe(dst)) {
 		sk->sk_rx_dst = dst;
 		inet_sk(sk)->rx_dst_ifindex = skb->skb_iif;
 	}
diff -uNr linux-4.3.3-5.16nodeb/net/ipv6/tcp_ipv6.c linux-4.3.3-6.17nodeb/net/ipv6/tcp_ipv6.c
--- linux-4.3.3-5.16nodeb/net/ipv6/tcp_ipv6.c	2015-12-16 21:38:19.000000000 +0000
+++ linux-4.3.3-6.17nodeb/net/ipv6/tcp_ipv6.c	2016-01-11 21:15:50.000000000 +0000
@@ -93,10 +93,9 @@
 {
 	struct dst_entry *dst = skb_dst(skb);
 
-	if (dst) {
+	if (dst && dst_hold_safe(dst)) {
 		const struct rt6_info *rt = (const struct rt6_info *)dst;
 
-		dst_hold(dst);
 		sk->sk_rx_dst = dst;
 		inet_sk(sk)->rx_dst_ifindex = skb->skb_iif;
 		inet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);
