diff -uNr a/arch/x86/kernel/dumpstack_32.c b/arch/x86/kernel/dumpstack_32.c
--- a/arch/x86/kernel/dumpstack_32.c	2016-01-05 19:54:14.000000000 +0000
+++ b/arch/x86/kernel/dumpstack_32.c	2016-01-05 19:22:52.000000000 +0000
@@ -42,7 +42,7 @@
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
-	const unsigned cpu = get_cpu();
+	unsigned cpu;
 	int graph = 0;
 	u32 *prev_esp;
 
@@ -64,6 +64,7 @@
 	if (!bp)
 		bp = stack_frame(task, regs);
 
+	cpu = get_cpu();
 	for (;;) {
 		struct thread_info *context;
 		void *end_stack;
diff -uNr a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c
--- a/arch/x86/kernel/dumpstack_64.c	2016-01-05 19:54:14.000000000 +0000
+++ b/arch/x86/kernel/dumpstack_64.c	2016-01-05 19:22:52.000000000 +0000
@@ -153,9 +153,9 @@
 		unsigned long *stack, unsigned long bp,
 		const struct stacktrace_ops *ops, void *data)
 {
-	const unsigned cpu = get_cpu();
+	unsigned cpu;
 	struct thread_info *tinfo;
-	unsigned long *irq_stack = (unsigned long *)per_cpu(irq_stack_ptr, cpu);
+	unsigned long *irq_stack;
 	unsigned long dummy;
 	unsigned used = 0;
 	int graph = 0;
@@ -165,10 +165,8 @@
 		task = current;
 
 	bp = stack_frame(task, regs);
-	if (try_stack_unwind(task, regs, &stack, &bp, ops, data)) {
-		put_cpu();
+	if (try_stack_unwind(task, regs, &stack, &bp, ops, data))
 		return;
-	}
 
 	if (!stack) {
 		if (regs)
@@ -187,6 +185,8 @@
 	 * exceptions
 	 */
 	tinfo = task_thread_info(task);
+	cpu = get_cpu();
+	irq_stack = (unsigned long *)per_cpu(irq_stack_ptr, cpu);
 	while (!done) {
 		unsigned long *stack_end;
 		enum stack_type stype;
diff -uNr a/drivers/char/Kconfig b/drivers/char/Kconfig
--- a/drivers/char/Kconfig	2016-01-05 19:54:14.000000000 +0000
+++ b/drivers/char/Kconfig	2016-01-05 19:22:52.000000000 +0000
@@ -592,8 +592,9 @@
 
 config CRASHER
 	tristate "Crasher Module"
+	depends on m
 	help
-	  Slab cache memory tester.  Only use this as a module
+	  Slab cache memory tester and crasher on will.
 
 config TILE_SROM
 	bool "Character-device access via hypervisor to the Tilera SPI ROM"
diff -uNr a/drivers/char/crasher.c b/drivers/char/crasher.c
--- a/drivers/char/crasher.c	2016-01-05 19:54:14.000000000 +0000
+++ b/drivers/char/crasher.c	2016-01-05 19:22:52.000000000 +0000
@@ -2,40 +2,40 @@
  * crasher.c, it breaks things
  */
 
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/completion.h>
+#include <linux/init.h>
 #include <linux/jiffies.h>
-#include <linux/sched.h>
-#include <linux/moduleparam.h>
+#include <linux/kernel.h>
 #include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/types.h>
 
-static int module_exiting;
-static struct completion startup = COMPLETION_INITIALIZER(startup);
-static unsigned long rand_seed = 152L;
-static unsigned long seed = 152L;
-static int threads = 1;
+static DECLARE_BITMAP(module_exiting, 1);
+static DECLARE_COMPLETION(startup);
+static unsigned int threads = 1;
+static unsigned int timer;
 static bool call_panic, call_bug, call_warn;
 static bool trap_null, call_null, jump_null;
-static long trap_read, trap_write, call_bad, jump_bad;
+static unsigned long trap_read, trap_write, call_bad, jump_bad;
 
-module_param(seed, ulong, 0);
+module_param(timer, uint, 0);
 module_param(call_panic, bool, 0);
 module_param(call_bug, bool, 0);
 module_param(call_warn, bool, 0);
 module_param(trap_null, bool, 0);
-module_param(trap_read, long, 0);
-module_param(trap_write, long, 0);
+module_param(trap_read, ulong, 0);
+module_param(trap_write, ulong, 0);
 module_param(call_null, bool, 0);
-module_param(call_bad, long, 0);
+module_param(call_bad, ulong, 0);
 module_param(jump_null, bool, 0);
-module_param(jump_bad, long, 0);
-module_param(threads, int, 0);
-MODULE_PARM_DESC(seed, "random seed for memory tests");
+module_param(jump_bad, ulong, 0);
+module_param(threads, uint, 0);
+MODULE_PARM_DESC(timer, "perform the selected crash action from the timer context in the specified number of ms");
 MODULE_PARM_DESC(call_panic, "test option. call panic() and render the system unusable.");
 MODULE_PARM_DESC(call_bug, "test option. call BUG() and render the system unusable.");
 MODULE_PARM_DESC(call_warn, "test option. call WARN() and leave the system usable.");
@@ -50,86 +50,65 @@
 MODULE_LICENSE("GPL");
 
 #define NUM_ALLOC 24
-#define NUM_SIZES 8
-static int sizes[]  = { 32, 64, 128, 192, 256, 1024, 2048, 4096 };
+static const unsigned int sizes[] = { 32, 64, 128, 192, 256, 1024, 2048, 4096 };
+#define NUM_SIZES ARRAY_SIZE(sizes)
 
 struct mem_buf {
 	char *buf;
-	int size;
+	unsigned int size;
 };
 
-static unsigned long crasher_random(void)
+static inline char crasher_hash(unsigned int i)
 {
-	rand_seed = rand_seed*69069L+1;
-	return rand_seed^jiffies;
+	return (i % 119) + 8;
 }
 
-void crasher_srandom(unsigned long entropy)
+static void mem_alloc(struct mem_buf *b)
 {
-	rand_seed ^= entropy;
-	crasher_random();
-}
+	unsigned int i, size = sizes[prandom_u32_max(NUM_SIZES)];
+
+	b->buf = kmalloc(size, GFP_KERNEL);
+	if (!b->buf)
+		return;
+
+	b->size = size;
 
-static char *mem_alloc(int size) {
-	char *p = kmalloc(size, GFP_KERNEL);
-	int i;
-	if (!p)
-		return p;
 	for (i = 0 ; i < size; i++)
-		p[i] = (i % 119) + 8;
-	return p;
+		b->buf[i] = crasher_hash(i);
 }
 
-static void mem_check(char *p, int size) {
-	int i;
-	if (!p)
-		return;
-	for (i = 0 ; i < size; i++) {
-		if (p[i] != ((i % 119) + 8)) {
-			printk(KERN_CRIT "verify error at %lX offset %d "
-			       " wanted %d found %d size %d\n",
-			       (unsigned long)(p + i), i, (i % 119) + 8,
-			       p[i], size);
+static void mem_check_free(struct mem_buf *b)
+{
+	unsigned int i;
+
+	for (i = 0 ; i < b->size; i++) {
+		if (b->buf[i] != crasher_hash(i)) {
+			pr_crit("crasher: verify error at %p, offset %u, wanted %d, found %d, size %u\n",
+					&b->buf[i], i, crasher_hash(i),
+					b->buf[i], b->size);
 		}
 	}
-	// try and trigger slab poisoning for people using this buffer
-	// wrong
-	memset(p, 0, size);
-}
-
-static void mem_verify(void) {
-	struct mem_buf bufs[NUM_ALLOC];
-	struct mem_buf *b;
-	int index;
-	int size;
-	unsigned long sleep;
-	memset(bufs, 0, sizeof(struct mem_buf) * NUM_ALLOC);
-	while(!module_exiting) {
-		index = crasher_random() % NUM_ALLOC;
-		b = bufs + index;
-		if (b->size) {
-			mem_check(b->buf, b->size);
-			kfree(b->buf);
-			b->buf = NULL;
-			b->size = 0;
-		} else {
-			size = crasher_random() % NUM_SIZES;
-			size = sizes[size];
-			b->buf = mem_alloc(size);
-			b->size = size;
-		}
-		sleep = crasher_random() % (HZ / 10);
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(sleep);
-		set_current_state(TASK_RUNNING);
-	}
-	for (index = 0 ; index < NUM_ALLOC ; index++) {
-		b = bufs + index;
-		if (b->size) {
-			mem_check(b->buf, b->size);
-			kfree(b->buf);
-		}
+	kfree(b->buf);
+	b->buf = NULL;
+	b->size = 0;
+}
+
+static void mem_verify(void)
+{
+	struct mem_buf *b, bufs[NUM_ALLOC] = {};
+
+	while (!test_bit(0, module_exiting)) {
+		b = &bufs[prandom_u32_max(NUM_ALLOC)];
+		if (b->size)
+			mem_check_free(b);
+		else
+			mem_alloc(b);
+		schedule_timeout_interruptible(prandom_u32_max(HZ / 10));
 	}
+
+	for (b = bufs; b < &bufs[NUM_ALLOC]; b++)
+		if (b->size)
+			mem_check_free(b);
 }
 
 static int crasher_thread(void *unused)
@@ -137,90 +116,119 @@
 	complete(&startup);
 	mem_verify();
 	complete(&startup);
+
 	return 0;
 }
 
-static int __init crasher_init(void)
+static int crash_now(void)
 {
-	int i;
-	init_completion(&startup);
-	crasher_srandom(seed);
-
 	if (call_panic) {
-		panic("test panic from crasher module. Good Luck.\n");
+		panic("test panic from crasher module. Good luck!");
 		return -EFAULT;
 	}
 	if (call_bug) {
-		printk("triggering BUG\n");
-		BUG_ON(1);
+		pr_crit("crasher: triggering BUG\n");
+		BUG();
 		return -EFAULT;
 	}
-	if (WARN(call_warn, "triggering WARN\n"))
+	if (WARN(call_warn, "crasher: triggering WARN\n"))
 		return -EFAULT;
 
 	if (trap_null) {
 		volatile char *p = NULL;
-		printk("dereferencing NULL pointer.\n");
+		pr_crit("crasher: dereferencing NULL pointer\n");
 		p[0] = '\n';
 		return -EFAULT;
 	}
 	if (trap_read) {
 		const volatile char *p = (char *)trap_read;
-		printk("reading from invalid(?) address %p.\n", p);
+		pr_crit("crasher: reading from invalid(?) address %p\n", p);
 		return p[0] ? -EFAULT : -EACCES;
 	}
 	if (trap_write) {
 		volatile char *p = (char *)trap_write;
-		printk("writing to invalid(?) address %p.\n", p);
+		pr_crit("crasher: writing to invalid(?) address %p\n", p);
 		p[0] = ' ';
 		return -EFAULT;
 	}
 
 	if (call_null) {
-		void(*f)(void) = NULL;
-		printk("calling NULL pointer.\n");
+		void (*f)(void) = NULL;
+		pr_crit("crasher: calling NULL pointer\n");
 		f();
 		return -EFAULT;
 	}
 	if (call_bad) {
-		void(*f)(void) = (void(*)(void))call_bad;
-		printk("calling invalid(?) address %p.\n", f);
+		void (*f)(void) = (void(*)(void))call_bad;
+		pr_crit("crasher: calling invalid(?) address %p\n", f);
 		f();
 		return -EFAULT;
 	}
 
-	/* These two depend on the compiler doing tail call optimization. */
+	/* These two depend on the compiler doing tail call optimization */
 	if (jump_null) {
-		int(*f)(void) = NULL;
-		printk("jumping to NULL.\n");
+		int (*f)(void) = NULL;
+		pr_crit("crasher: jumping to NULL\n");
 		return f();
 	}
 	if (jump_bad) {
-		int(*f)(void) = (int(*)(void))jump_bad;
-		printk("jumping to invalid(?) address %p.\n", f);
+		int (*f)(void) = (int(*)(void))jump_bad;
+		pr_crit("crasher: jumping to invalid(?) address %p\n", f);
 		return f();
 	}
 
-	printk("crasher module (%d threads).  Testing sizes: ", threads);
-	for (i = 0 ; i < NUM_SIZES ; i++)
-		printk("%d ", sizes[i]);
-	printk("\n");
-
-	for (i = 0 ; i < threads ; i++)
-		kthread_run(crasher_thread, crasher_thread, "crasher");
-	for (i = 0 ; i < threads ; i++)
+	return 0;
+}
+
+static void crash_timer_cb(unsigned long unused)
+{
+	crash_now();
+}
+
+static DEFINE_TIMER(crash_timer, crash_timer_cb, 0, 0);
+
+static int __init crasher_init(void)
+{
+	int ret, i;
+
+	if (timer) {
+		pr_info("crasher: crashing in %u miliseconds...\n", timer);
+		mod_timer(&crash_timer, jiffies + msecs_to_jiffies(timer));
+		return 0;
+	}
+
+	ret = crash_now();
+	if (ret)
+		return ret;
+
+	pr_info("crasher: running %u threads. Testing sizes: ", threads);
+	for (i = 0; i < NUM_SIZES; i++)
+		pr_cont("%u ", sizes[i]);
+	pr_cont("\n");
+
+	for (i = 0; i < threads; i++)
+		kthread_run(crasher_thread, NULL, "crasher");
+	for (i = 0; i < threads; i++)
 		wait_for_completion(&startup);
+
 	return 0;
 }
 
 static void __exit crasher_exit(void)
 {
-	int i;
-	module_exiting = 1;
-	for (i = 0 ; i < threads ; i++)
+	unsigned int i;
+
+	if (timer) {
+		del_timer_sync(&crash_timer);
+		return;
+	}
+
+	set_bit(0, module_exiting);
+
+	for (i = 0; i < threads; i++)
 		wait_for_completion(&startup);
-	printk("all crasher threads done\n");
-	return;
+
+	pr_info("crasher: all threads done\n");
 }
 
 module_init(crasher_init);
diff -uNr a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
--- a/drivers/gpu/drm/i915/intel_display.c	2015-11-02 00:05:25.000000000 +0000
+++ b/drivers/gpu/drm/i915/intel_display.c	2016-01-05 19:22:52.000000000 +0000
@@ -6225,9 +6225,11 @@
 	if (to_intel_plane_state(crtc->primary->state)->visible) {
 		intel_crtc_wait_for_pending_flips(crtc);
 		intel_pre_disable_primary(crtc);
+
+		intel_crtc_disable_planes(crtc, 1 << drm_plane_index(crtc->primary));
+		to_intel_plane_state(crtc->primary->state)->visible = false;
 	}
 
-	intel_crtc_disable_planes(crtc, crtc->state->plane_mask);
 	dev_priv->display.crtc_disable(crtc);
 	intel_disable_shared_dpll(intel_crtc);
 
@@ -12427,7 +12429,6 @@
 	if (INTEL_INFO(dev)->gen < 8) {
 		PIPE_CONF_CHECK_M_N(dp_m_n);
 
-		PIPE_CONF_CHECK_I(has_drrs);
 		if (current_config->has_drrs)
 			PIPE_CONF_CHECK_M_N(dp_m2_n2);
 	} else
diff -uNr a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
--- a/drivers/gpu/drm/i915/intel_dp.c	2015-11-02 00:05:25.000000000 +0000
+++ b/drivers/gpu/drm/i915/intel_dp.c	2016-01-05 19:22:52.000000000 +0000
@@ -4921,7 +4921,8 @@
 	enum intel_display_power_domain power_domain;
 	enum irqreturn ret = IRQ_NONE;
 
-	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP &&
+	    intel_dig_port->base.type != INTEL_OUTPUT_HDMI)
 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
 
 	if (long_hpd && intel_dig_port->base.type == INTEL_OUTPUT_EDP) {
diff -uNr a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c
--- a/drivers/net/ethernet/atheros/alx/main.c	2015-11-02 00:05:25.000000000 +0000
+++ b/drivers/net/ethernet/atheros/alx/main.c	2016-01-05 19:22:52.000000000 +0000
@@ -1534,6 +1534,8 @@
 	  .driver_data = ALX_DEV_QUIRK_MSI_INTX_DISABLE_BUG },
 	{ PCI_VDEVICE(ATTANSIC, ALX_DEV_ID_E2200),
 	  .driver_data = ALX_DEV_QUIRK_MSI_INTX_DISABLE_BUG },
+	{ PCI_VDEVICE(ATTANSIC, ALX_DEV_ID_E2400),
+	  .driver_data = ALX_DEV_QUIRK_MSI_INTX_DISABLE_BUG },
 	{ PCI_VDEVICE(ATTANSIC, ALX_DEV_ID_AR8162),
 	  .driver_data = ALX_DEV_QUIRK_MSI_INTX_DISABLE_BUG },
 	{ PCI_VDEVICE(ATTANSIC, ALX_DEV_ID_AR8171) },
diff -uNr a/drivers/net/ethernet/atheros/alx/reg.h b/drivers/net/ethernet/atheros/alx/reg.h
--- a/drivers/net/ethernet/atheros/alx/reg.h	2015-11-02 00:05:25.000000000 +0000
+++ b/drivers/net/ethernet/atheros/alx/reg.h	2016-01-05 19:22:52.000000000 +0000
@@ -37,6 +37,7 @@
 
 #define ALX_DEV_ID_AR8161				0x1091
 #define ALX_DEV_ID_E2200				0xe091
+#define ALX_DEV_ID_E2400				0xe0a1
 #define ALX_DEV_ID_AR8162				0x1090
 #define ALX_DEV_ID_AR8171				0x10A1
 #define ALX_DEV_ID_AR8172				0x10A0
diff -uNr a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c
--- a/drivers/platform/x86/thinkpad_acpi.c	2015-11-02 00:05:25.000000000 +0000
+++ b/drivers/platform/x86/thinkpad_acpi.c	2016-01-05 19:22:52.000000000 +0000
@@ -6459,8 +6459,7 @@
 		pr_info("detected a 8-level brightness capable ThinkPad\n");
 		break;
 	default:
-		pr_err("Unsupported brightness interface, "
-		       "please contact %s\n", TPACPI_MAIL);
+		pr_info("Unsupported brightness interface\n");
 		tp_features.bright_unkfw = 1;
 		bright_maxlvl = b - 1;
 	}
diff -uNr a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
--- a/fs/overlayfs/inode.c	2015-11-02 00:05:25.000000000 +0000
+++ b/fs/overlayfs/inode.c	2016-01-05 19:22:52.000000000 +0000
@@ -49,13 +49,13 @@
 	if (err)
 		goto out;
 
-	upperdentry = ovl_dentry_upper(dentry);
-	if (upperdentry) {
+	err = ovl_copy_up(dentry);
+	if (!err) {
+		upperdentry = ovl_dentry_upper(dentry);
+
 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
-	} else {
-		err = ovl_copy_up_last(dentry, attr, false);
 	}
 	ovl_drop_write(dentry);
 out:
diff -uNr a/net/bridge/br_if.c b/net/bridge/br_if.c
--- a/net/bridge/br_if.c	2016-01-05 19:54:14.000000000 +0000
+++ b/net/bridge/br_if.c	2015-11-02 00:05:25.000000000 +0000
@@ -351,19 +351,12 @@
 	if (!dev)
 		return -ENOMEM;
 
-	if (!try_module_get(THIS_MODULE)) {
-		free_netdev(dev);
-		return -ENOENT;
-	}
-
 	dev_net_set(dev, net);
 	dev->rtnl_link_ops = &br_link_ops;
 
 	res = register_netdev(dev);
-	if (res) {
+	if (res)
 		free_netdev(dev);
-		module_put(THIS_MODULE);
-	}
 	return res;
 }
 
@@ -391,8 +384,6 @@
 		br_dev_delete(dev, NULL);
 
 	rtnl_unlock();
-	if (ret == 0)
-		module_put(THIS_MODULE);
 	return ret;
 }
 
diff -uNr a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
--- a/sound/pci/hda/patch_realtek.c	2015-11-02 00:05:25.000000000 +0000
+++ b/sound/pci/hda/patch_realtek.c	2016-01-05 19:22:52.000000000 +0000
@@ -111,6 +111,7 @@
 	void (*power_hook)(struct hda_codec *codec);
 #endif
 	void (*shutup)(struct hda_codec *codec);
+	void (*reboot_notify)(struct hda_codec *codec);
 
 	int init_amp;
 	int codec_variant;	/* flag for other variants */
@@ -773,6 +774,25 @@
 		snd_hda_shutup_pins(codec);
 }
 
+static void alc_reboot_notify(struct hda_codec *codec)
+{
+	struct alc_spec *spec = codec->spec;
+
+	if (spec && spec->reboot_notify)
+		spec->reboot_notify(codec);
+	else
+		alc_shutup(codec);
+}
+
+/* power down codec to D3 at reboot/shutdown; set as reboot_notify ops */
+static void alc_d3_at_reboot(struct hda_codec *codec)
+{
+	snd_hda_codec_set_power_to_all(codec, codec->core.afg, AC_PWRST_D3);
+	snd_hda_codec_write(codec, codec->core.afg, 0,
+			    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);
+	msleep(10);
+}
+
 #define alc_free	snd_hda_gen_free
 
 #ifdef CONFIG_PM
@@ -818,7 +838,7 @@
 	.suspend = alc_suspend,
 	.check_power_status = snd_hda_gen_check_power_status,
 #endif
-	.reboot_notify = alc_shutup,
+	.reboot_notify = alc_reboot_notify,
 };
 
 
@@ -4200,6 +4220,8 @@
 	struct alc_spec *spec = codec->spec;
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
+		spec->shutup = alc_no_shutup; /* reduce click noise */
+		spec->reboot_notify = alc_d3_at_reboot; /* reduce noise */
 		spec->parse_flags = HDA_PINCFG_NO_HP_FIXUP;
 		codec->power_save_node = 0; /* avoid click noises */
 		snd_hda_apply_pincfgs(codec, pincfgs);
@@ -4580,6 +4602,7 @@
 	ALC255_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
+	ALC292_FIXUP_TPT440,
 	ALC283_FIXUP_BXBT2807_MIC,
 	ALC255_FIXUP_DELL_WMI_MIC_MUTE_LED,
 	ALC282_FIXUP_ASPIRE_V5_PINS,
@@ -5050,6 +5073,12 @@
 		.chained = true,
 		.chain_id = ALC269_FIXUP_LIMIT_INT_MIC_BOOST
 	},
+	[ALC292_FIXUP_TPT440] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_disable_aamix,
+		.chained = true,
+		.chain_id = ALC292_FIXUP_TPT440_DOCK,
+	},
 	[ALC283_FIXUP_BXBT2807_MIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -5299,13 +5328,14 @@
 	SND_PCI_QUIRK(0x17aa, 0x21fb, "Thinkpad T430s", ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2203, "Thinkpad X230 Tablet", ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2208, "Thinkpad T431s", ALC269_FIXUP_LENOVO_DOCK),
-	SND_PCI_QUIRK(0x17aa, 0x220c, "Thinkpad T440s", ALC292_FIXUP_TPT440_DOCK),
+	SND_PCI_QUIRK(0x17aa, 0x220c, "Thinkpad T440s", ALC292_FIXUP_TPT440),
 	SND_PCI_QUIRK(0x17aa, 0x220e, "Thinkpad T440p", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2210, "Thinkpad T540p", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2211, "Thinkpad W541", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2212, "Thinkpad T440", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, "Thinkpad X240", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, "Thinkpad", ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
+	SND_PCI_QUIRK(0x17aa, 0x2218, "Thinkpad X1 Carbon 2nd", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2223, "ThinkPad T550", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2226, "ThinkPad X250", ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x3977, "IdeaPad S210", ALC283_FIXUP_INT_MIC),
@@ -5397,6 +5427,7 @@
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = "alc283-dac-wcaps"},
 	{.id = ALC283_FIXUP_SENSE_COMBO_JACK, .name = "alc283-sense-combo"},
 	{.id = ALC292_FIXUP_TPT440_DOCK, .name = "tpt440-dock"},
+	{.id = ALC292_FIXUP_TPT440, .name = "tpt440"},
 	{}
 };
 
