diff -uNr linux-4.3.3-4.13nodeb/arch/powerpc/include/asm/reg.h linux-4.3-5.16nodeb/arch/powerpc/include/asm/reg.h
--- linux-4.3.3-4.13nodeb/arch/powerpc/include/asm/reg.h	2015-12-02 01:21:06.000000000 +0000
+++ linux-4.3-5.16nodeb/arch/powerpc/include/asm/reg.h	2015-12-16 21:38:19.000000000 +0000
@@ -108,6 +108,7 @@
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	/*  Transaction Transactional */
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */
 #define MSR_TM_ACTIVE(x) (((x) & MSR_TS_MASK) != 0) /* Transaction active? */
+#define MSR_TM_RESV(x) (((x) & MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */
 #define MSR_TM_TRANSACTIONAL(x)	(((x) & MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) & MSR_TS_MASK) == MSR_TS_S)
 
diff -uNr linux-4.3.3-4.13nodeb/arch/powerpc/kernel/process.c linux-4.3-5.16nodeb/arch/powerpc/kernel/process.c
--- linux-4.3.3-4.13nodeb/arch/powerpc/kernel/process.c	2015-12-02 01:21:06.000000000 +0000
+++ linux-4.3-5.16nodeb/arch/powerpc/kernel/process.c	2015-12-16 21:38:19.000000000 +0000
@@ -551,6 +551,24 @@
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
+	/*
+	 * Use the current MSR TM suspended bit to track if we have
+	 * checkpointed state outstanding.
+	 * On signal delivery, we'd normally reclaim the checkpointed
+	 * state to obtain stack pointer (see:get_tm_stackpointer()).
+	 * This will then directly return to userspace without going
+	 * through __switch_to(). However, if the stack frame is bad,
+	 * we need to exit this thread which calls __switch_to() which
+	 * will again attempt to reclaim the already saved tm state.
+	 * Hence we need to check that we've not already reclaimed
+	 * this state.
+	 * We do this using the current MSR, rather tracking it in
+	 * some specific thread_struct bit, as it has the additional
+	 * benifit of checking for a potential TM bad thing exception.
+	 */
+	if (!MSR_TM_SUSPENDED(mfmsr()))
+		return;
+
 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
diff -uNr linux-4.3.3-4.13nodeb/arch/powerpc/kernel/signal_32.c linux-4.3-5.16nodeb/arch/powerpc/kernel/signal_32.c
--- linux-4.3.3-4.13nodeb/arch/powerpc/kernel/signal_32.c	2015-10-28 13:34:57.000000000 +0000
+++ linux-4.3-5.16nodeb/arch/powerpc/kernel/signal_32.c	2015-12-16 21:38:19.000000000 +0000
@@ -875,6 +875,15 @@
 		return 1;
 #endif /* CONFIG_SPE */
 
+	/* Get the top half of the MSR from the user context */
+	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
+		return 1;
+	msr_hi <<= 32;
+	/* If TM bits are set to the reserved value, it's an invalid context */
+	if (MSR_TM_RESV(msr_hi))
+		return 1;
+	/* Pull in the MSR TM bits from the user context */
+	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
@@ -884,11 +893,6 @@
 	current->thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&current->thread, msr);
-	/* Get the top half of the MSR */
-	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
-		return 1;
-	/* Pull in MSR TM from user context */
-	regs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr & MSR_FP) {
diff -uNr linux-4.3.3-4.13nodeb/arch/powerpc/kernel/signal_64.c linux-4.3-5.16nodeb/arch/powerpc/kernel/signal_64.c
--- linux-4.3.3-4.13nodeb/arch/powerpc/kernel/signal_64.c	2015-12-02 01:21:06.000000000 +0000
+++ linux-4.3-5.16nodeb/arch/powerpc/kernel/signal_64.c	2015-12-16 21:38:19.000000000 +0000
@@ -438,6 +438,10 @@
 
 	/* get MSR separately, transfer the LE bit if doing signal return */
 	err |= __get_user(msr, &sc->gp_regs[PT_MSR]);
+	/* Don't allow reserved mode. */
+	if (MSR_TM_RESV(msr))
+		return -EINVAL;
+
 	/* pull in MSR TM from user context */
 	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);
 
diff -uNr linux-4.3.3-4.13nodeb/certs/.gitignore linux-4.3-5.16nodeb/certs/.gitignore
--- linux-4.3.3-4.13nodeb/certs/.gitignore	2015-12-19 00:16:31.000000000 +0000
+++ linux-4.3-5.16nodeb/certs/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-#
-# Generated files
-#
-x509_certificate_list
diff -uNr linux-4.3.3-4.13nodeb/fs/btrfs/inode.c linux-4.3-5.16nodeb/fs/btrfs/inode.c
--- linux-4.3.3-4.13nodeb/fs/btrfs/inode.c	2015-12-19 00:16:31.000000000 +0000
+++ linux-4.3-5.16nodeb/fs/btrfs/inode.c	2015-12-16 21:38:19.000000000 +0000
@@ -4264,47 +4264,6 @@
 	return 0;
 }
 
-static int truncate_inline_extent(struct inode *inode,
-				  struct btrfs_path *path,
-				  struct btrfs_key *found_key,
-				  const u64 item_end,
-				  const u64 new_size)
-{
-	struct extent_buffer *leaf = path->nodes[0];
-	int slot = path->slots[0];
-	struct btrfs_file_extent_item *fi;
-	u32 size = (u32)(new_size - found_key->offset);
-	struct btrfs_root *root = BTRFS_I(inode)->root;
-
-	fi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);
-
-	if (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {
-		loff_t offset = new_size;
-		loff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);
-
-		/*
-		 * Zero out the remaining of the last page of our inline extent,
-		 * instead of directly truncating our inline extent here - that
-		 * would be much more complex (decompressing all the data, then
-		 * compressing the truncated data, which might be bigger than
-		 * the size of the inline extent, resize the extent, etc).
-		 * We release the path because to get the page we might need to
-		 * read the extent item from disk (data not in the page cache).
-		 */
-		btrfs_release_path(path);
-		return btrfs_truncate_page(inode, offset, page_end - offset, 0);
-	}
-
-	btrfs_set_file_extent_ram_bytes(leaf, fi, size);
-	size = btrfs_file_extent_calc_inline_size(size);
-	btrfs_truncate_item(root, path, size, 1);
-
-	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
-		inode_sub_bytes(inode, item_end + 1 - new_size);
-
-	return 0;
-}
-
 /*
  * this can truncate away extent items, csum items and directory items.
  * It starts at a high offset and removes keys until it can't find
